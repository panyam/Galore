---
title: Arithmetic Expressions
description: Parsing arithmetic expressions with operator precedence
section: examples
useExampleRunner: true
---

<h1>Arithmetic Expressions</h1>

<p>This classic example demonstrates how grammar structure naturally enforces operator precedence and associativity without explicit precedence declarations.</p>

<h2>Try It</h2>

<p>Edit the expression below and click <strong>Run</strong> to see the parse tree:</p>

<div id="arithmetic-example"></div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const actionCode = `function evaluate(node) {
  if (!node) return 0;
  const label = node.sym?.label;

  // Terminal: NUMBER
  if (label === "NUMBER") {
    return parseFloat(node.value);
  }

  // Non-terminal with children
  if (node.children) {
    const values = node.children.map(evaluate);

    // Find operator and compute
    for (const child of node.children) {
      if (child.value === "+") return values[0] + values[2];
      if (child.value === "-") return values[0] - values[2];
      if (child.value === "*") return values[0] * values[2];
      if (child.value === "/") return values[0] / values[2];
    }

    // No operator - return first meaningful value
    return values.find(v => typeof v === "number" && !isNaN(v)) ?? 0;
  }

  return 0;
}`;

  function evaluate(node) {
    if (!node) return 0;
    const label = node.sym?.label;
    if (label === "NUMBER") {
      return parseFloat(node.value);
    }
    if (node.children) {
      const values = node.children.map(evaluate);
      for (const child of node.children) {
        if (child.value === "+") return values[0] + values[2];
        if (child.value === "-") return values[0] - values[2];
        if (child.value === "*") return values[0] * values[2];
        if (child.value === "/") return values[0] / values[2];
      }
      return values.find(v => typeof v === "number" && !isNaN(v)) ?? 0;
    }
    return 0;
  }

  new ExampleRunner('arithmetic-example', {
    grammarName: 'Arithmetic',
    actionCode: actionCode,
    actionFn: evaluate
  });
});
</script>

<h2>How Precedence Works</h2>

<p>The grammar structure enforces precedence through nesting:</p>

<table class="precedence-table">
    <thead>
        <tr>
            <th>Rule</th>
            <th>Operators</th>
            <th>Precedence</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>Expr</code></td>
            <td><code>+</code> <code>-</code></td>
            <td>Lowest</td>
        </tr>
        <tr>
            <td><code>Term</code></td>
            <td><code>*</code> <code>/</code></td>
            <td>Higher</td>
        </tr>
        <tr>
            <td><code>Factor</code></td>
            <td><code>( )</code></td>
            <td>Highest</td>
        </tr>
    </tbody>
</table>

<h2>Parse Tree Structure</h2>

<p>For the input <code>1 + 2 * 3</code>, notice how the parse tree groups <code>2 * 3</code> as a <code>Term</code> before adding <code>1</code>:</p>

<pre><code>Expr
├── Expr
│   └── Term
│       └── Factor
│           └── NUMBER: "1"
├── "+"
└── Term
    ├── Term
    │   └── Factor
    │       └── NUMBER: "2"
    ├── "*"
    └── Factor
        └── NUMBER: "3"</code></pre>

<h2>Left Associativity</h2>

<p>The grammar uses left-recursion (<code>Expr -> Expr "+" Term</code>), which makes operators left-associative. For <code>1 - 2 - 3</code>, this means <code>(1 - 2) - 3 = -4</code>, not <code>1 - (2 - 3) = 2</code>.</p>

<h2>Example Expressions</h2>

<p>Try these expressions:</p>
<ul>
    <li><code>1 + 2 + 3</code> - Left associative addition</li>
    <li><code>10 - 3 - 2</code> - Left associative subtraction</li>
    <li><code>2 * 3 + 4</code> - Multiplication before addition</li>
    <li><code>(2 + 3) * 4</code> - Parentheses override precedence</li>
    <li><code>2 * (3 + 4)</code> - Parentheses change evaluation order</li>
</ul>

<style>
.precedence-table {
    width: 100%;
    border-collapse: collapse;
    margin: 1rem 0;
}
.precedence-table th,
.precedence-table td {
    border: 1px solid var(--color-border);
    padding: 0.5rem 1rem;
    text-align: left;
}
.precedence-table th {
    background: var(--color-bg-alt);
}
</style>
