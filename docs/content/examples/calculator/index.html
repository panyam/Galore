---
title: Calculator
description: Building a working calculator with semantic actions
section: examples
useExampleRunner: true
---

<h1>Calculator</h1>

<p>This example shows a more advanced calculator grammar that supports variables, assignments, and function calls. The grammar defines operator precedence naturally through its structure.</p>

<h2>Try It</h2>

<p>Edit the input below and click <strong>Run</strong> to see the parse tree and computed result:</p>

<div id="calculator-example"></div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const actionCode = `function evaluate(node) {
  if (!node) return 0;
  const label = node.sym?.label;

  // Terminal: NUMBER
  if (label === "NUMBER") {
    return parseFloat(node.value);
  }

  // Non-terminal with children
  if (node.children) {
    const values = node.children.map(evaluate);

    // Find operator and compute
    for (const child of node.children) {
      if (child.value === "+") return values[0] + values[2];
      if (child.value === "-") return values[0] - values[2];
      if (child.value === "*") return values[0] * values[2];
      if (child.value === "/") return values[0] / values[2];
    }

    // No operator - return first meaningful value
    return values.find(v => typeof v === "number" && !isNaN(v)) ?? 0;
  }

  return 0;
}`;

  // The actual function to execute
  function evaluate(node) {
    if (!node) return 0;
    const label = node.sym?.label;
    if (label === "NUMBER") {
      return parseFloat(node.value);
    }
    if (node.children) {
      const values = node.children.map(evaluate);
      for (const child of node.children) {
        if (child.value === "+") return values[0] + values[2];
        if (child.value === "-") return values[0] - values[2];
        if (child.value === "*") return values[0] * values[2];
        if (child.value === "/") return values[0] / values[2];
      }
      return values.find(v => typeof v === "number" && !isNaN(v)) ?? 0;
    }
    return 0;
  }

  new ExampleRunner('calculator-example', {
    grammarName: 'Calculator',
    actionCode: actionCode,
    actionFn: evaluate
  });
});
</script>

<h2>How It Works</h2>

<h3>Grammar Features</h3>

<p>This calculator grammar supports:</p>
<ul>
    <li><strong>Variables</strong> - Identifiers like <code>x</code>, <code>y</code>, <code>total</code></li>
    <li><strong>Assignments</strong> - <code>x = 10</code></li>
    <li><strong>Expressions</strong> - <code>x + y * 2</code></li>
    <li><strong>Function calls</strong> - <code>sin(x)</code>, <code>max(a, b)</code></li>
    <li><strong>Operator precedence</strong> - <code>*</code> and <code>/</code> bind tighter than <code>+</code> and <code>-</code></li>
</ul>

<h3>Evaluation</h3>

<p>The <code>evaluate</code> function recursively walks the parse tree to compute numeric results. Note that this simple evaluator doesn't track variable assignments - a full implementation would need a symbol table.</p>

<h2>Example Inputs</h2>

<p>Try these inputs:</p>
<ul>
    <li><code>1 + 2 * 3</code> - Basic arithmetic</li>
    <li><code>x = 10</code> - Variable assignment</li>
    <li><code>x + y * 2</code> - Expression with variables</li>
</ul>
