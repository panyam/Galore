---
title: Calculator
description: Building a working calculator with semantic actions
section: examples
useExampleRunner: true
---

<h1>Calculator</h1>

<p>This example shows a more advanced calculator grammar that supports variables, assignments, and function calls. The grammar defines operator precedence naturally through its structure.</p>

<h2>Try It</h2>

<p>Edit the input below and click <strong>Run</strong> to see the parse tree and computed result:</p>

<div id="calculator-example"></div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const actionCode = `// Built-in functions
const funcs = {
  sin: Math.sin, cos: Math.cos, tan: Math.tan,
  sqrt: Math.sqrt, abs: Math.abs,
  floor: Math.floor, ceil: Math.ceil, round: Math.round,
  log: Math.log, exp: Math.exp, pow: Math.pow,
  min: Math.min, max: Math.max,
  pi: () => Math.PI, e: () => Math.E
};

// Convert parse tree node back to source text
function nodeToString(node) {
  if (!node) return "";
  if (node.value !== undefined && !node.children?.length) {
    return node.value;
  }
  if (node.children) {
    return node.children.map(nodeToString).join(" ");
  }
  return "";
}

// Create fresh evaluator with new symbol table
function createEvaluator() {
  const vars = {};

  function evaluate(node) {
    if (!node) return null;
    const label = node.sym?.label;

    // Terminals
    if (label === "NUMBER") return parseFloat(node.value);
    if (label === "ID") return vars[node.value] ?? 0;

    // Skip punctuation (no children)
    if (!node.children?.length) return null;

    // Assignment: ID "=" Expr (use positions)
    if (label === "Assignment") {
      const idNode = node.children[0]; // First child is ID
      const exprNode = node.children[2]; // Third child is Expr
      if (idNode && exprNode) {
        const value = evaluate(exprNode);
        vars[idNode.value] = value;
        return { text: idNode.value + " = " + value, result: value };
      }
    }

    // FuncCall: ID "(" args ")"
    if (label === "FuncCall") {
      const funcName = node.children[0]?.value;
      const fn = funcs[funcName];
      if (!fn) return NaN;
      const args = node.children.slice(2, -1) // Skip ID, "(", and ")"
        .filter(c => c.value !== ",")
        .map(evaluate)
        .map(v => typeof v === "object" ? v.result : v)
        .filter(v => v !== null);
      return fn(...args);
    }

    // Program: evaluate all direct children (statements)
    if (label === "Program") {
      const results = [];
      for (const child of node.children || []) {
        const text = nodeToString(child).trim();
        if (text) {
          const val = evaluate(child);
          if (val !== null) {
            const result = typeof val === "object" ? val.result : val;
            results.push({ text, result });
          }
        }
      }
      return results;
    }

    // Binary operators
    for (let i = 0; i < node.children.length; i++) {
      const op = node.children[i].value;
      if (["+", "-", "*", "/"].includes(op)) {
        let left = evaluate(node.children[i - 1]);
        let right = evaluate(node.children[i + 1]);
        left = typeof left === "object" ? left.result : left;
        right = typeof right === "object" ? right.result : right;
        if (op === "+") return left + right;
        if (op === "-") return left - right;
        if (op === "*") return left * right;
        if (op === "/") return left / right;
      }
    }

    // Pass through
    for (const child of node.children) {
      const val = evaluate(child);
      if (val !== null) return val;
    }
    return null;
  }

  return evaluate;
}`;

  // The actual function to execute
  const funcs = {
    sin: Math.sin, cos: Math.cos, tan: Math.tan,
    sqrt: Math.sqrt, abs: Math.abs,
    floor: Math.floor, ceil: Math.ceil, round: Math.round,
    log: Math.log, exp: Math.exp, pow: Math.pow,
    min: Math.min, max: Math.max,
    pi: () => Math.PI, e: () => Math.E
  };

  function nodeToString(node) {
    if (!node) return "";
    if (node.value !== undefined && !node.children?.length) return node.value;
    if (node.children) return node.children.map(nodeToString).join(" ");
    return "";
  }

  function createEvaluator() {
    const vars = {};

    function evaluate(node) {
      if (!node) return null;
      const label = node.sym?.label;

      // Terminals
      if (label === "NUMBER") return parseFloat(node.value);
      if (label === "ID") return vars[node.value] ?? 0;

      // Skip punctuation
      if (!node.children?.length) return null;

      // Assignment: ID "=" Expr
      if (label === "Assignment") {
        const idNode = node.children[0];
        const exprNode = node.children[2];
        if (idNode && exprNode) {
          const value = evaluate(exprNode);
          const numValue = typeof value === "object" ? value.result : value;
          vars[idNode.value] = numValue;
          return { text: idNode.value + " = " + numValue, result: numValue };
        }
      }

      // FuncCall: ID "(" args ")"
      if (label === "FuncCall") {
        const funcName = node.children[0]?.value;
        const fn = funcs[funcName];
        if (!fn) return NaN;
        const args = node.children.slice(2, -1)
          .filter(c => c.value !== ",")
          .map(evaluate)
          .map(v => typeof v === "object" ? v.result : v)
          .filter(v => v !== null);
        return fn(...args);
      }

      // Program: evaluate all direct children (statements)
      if (label === "Program") {
        const results = [];
        const children = node.children || [];
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          const text = nodeToString(child).trim();
          if (text) {
            const val = evaluate(child);
            if (val !== null) {
              const result = typeof val === "object" ? val.result : val;
              results.push({ text, result });
            }
          }
        }
        return results.length > 0 ? results : [{ text: "No statements", result: null }];
      }

      // Binary operators
      for (let i = 0; i < node.children.length; i++) {
        const op = node.children[i].value;
        if (["+", "-", "*", "/"].includes(op)) {
          let left = evaluate(node.children[i - 1]);
          let right = evaluate(node.children[i + 1]);
          left = typeof left === "object" ? left.result : left;
          right = typeof right === "object" ? right.result : right;
          if (op === "+") return left + right;
          if (op === "-") return left - right;
          if (op === "*") return left * right;
          if (op === "/") return left / right;
        }
      }

      // Pass through
      for (const child of node.children) {
        const val = evaluate(child);
        if (val !== null) return val;
      }
      return null;
    }

    return evaluate;
  }

  new ExampleRunner('calculator-example', {
    grammarName: 'Calculator',
    actionCode: actionCode,
    actionFn: (node) => {
      const result = createEvaluator()(node);
      // Format as "statement => result" for display
      if (Array.isArray(result)) {
        return result.map(r => `${r.text}  â†’  ${r.result}`).join("\n");
      }
      return result;
    }
  });
});
</script>

<h2>How It Works</h2>

<h3>Grammar Features</h3>

<p>This calculator grammar supports:</p>
<ul>
    <li><strong>Variables</strong> - Identifiers like <code>x</code>, <code>y</code>, <code>total</code></li>
    <li><strong>Assignments</strong> - <code>x = 10</code></li>
    <li><strong>Expressions</strong> - <code>x + y * 2</code></li>
    <li><strong>Function calls</strong> - <code>sin(x)</code>, <code>max(a, b)</code></li>
    <li><strong>Operator precedence</strong> - <code>*</code> and <code>/</code> bind tighter than <code>+</code> and <code>-</code></li>
</ul>

<h3>Evaluation</h3>

<p>The <code>evaluate</code> function recursively walks the parse tree to compute numeric results. It maintains a symbol table for variables and supports built-in math functions.</p>

<h2>Example Inputs</h2>

<p>Try these inputs:</p>
<ul>
    <li><code>1 + 2 * 3</code> - Basic arithmetic (result: 7)</li>
    <li><code>x = 10
y = 20
x + y</code> - Variables (result: 30)</li>
    <li><code>sqrt(16) + abs(-5)</code> - Function calls (result: 9)</li>
    <li><code>sin(pi() / 2)</code> - Trig functions (result: 1)</li>
    <li><code>pow(2, 10)</code> - Power function (result: 1024)</li>
    <li><code>max(10, 20, 5)</code> - Multi-argument function</li>
</ul>

<h3>Available Functions</h3>
<p><code>sin</code>, <code>cos</code>, <code>tan</code>, <code>sqrt</code>, <code>abs</code>, <code>floor</code>, <code>ceil</code>, <code>round</code>, <code>log</code>, <code>exp</code>, <code>pow</code>, <code>min</code>, <code>max</code>, <code>pi</code>, <code>e</code></p>
