---
title: Calculator
description: Building a working calculator with semantic actions
section: examples
useExampleRunner: true
---

<h1>Calculator</h1>

<p>This example extends the arithmetic grammar with semantic actions to evaluate expressions. The grammar defines operator precedence naturally through its structure, and the action code walks the parse tree to compute the result.</p>

<h2>Try It</h2>

<p>Edit the input below and click <strong>Run</strong> to see the parse tree and computed result:</p>

<div id="calculator-example"></div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const grammar = `Expr   -> Expr "+" Term | Expr "-" Term | Term
Term   -> Term "*" Factor | Term "/" Factor | Factor
Factor -> "(" Expr ")" | NUMBER
NUMBER -> /[0-9]+(\\.[0-9]+)?/`;

  const input = `1 + 2 * 3`;

  const actionCode = `function evaluate(node) {
  if (!node) return 0;

  const label = node.sym?.label;

  // Terminal: NUMBER
  if (label === "NUMBER") {
    return parseFloat(node.value);
  }

  // Non-terminal with children
  if (node.children) {
    const values = node.children.map(evaluate);

    // Find operator and compute
    for (const child of node.children) {
      if (child.value === "+") return values[0] + values[2];
      if (child.value === "-") return values[0] - values[2];
      if (child.value === "*") return values[0] * values[2];
      if (child.value === "/") return values[0] / values[2];
    }

    // No operator - return first meaningful value
    return values.find(v => typeof v === "number" && !isNaN(v)) ?? 0;
  }

  return 0;
}`;

  // The actual function to execute
  function evaluate(node) {
    if (!node) return 0;
    const label = node.sym?.label;
    if (label === "NUMBER") {
      return parseFloat(node.value);
    }
    if (node.children) {
      const values = node.children.map(evaluate);
      for (const child of node.children) {
        if (child.value === "+") return values[0] + values[2];
        if (child.value === "-") return values[0] - values[2];
        if (child.value === "*") return values[0] * values[2];
        if (child.value === "/") return values[0] / values[2];
      }
      return values.find(v => typeof v === "number" && !isNaN(v)) ?? 0;
    }
    return 0;
  }

  new ExampleRunner('calculator-example', {
    grammar: grammar,
    input: input,
    actionCode: actionCode,
    actionFn: evaluate
  });
});
</script>

<h2>How It Works</h2>

<h3>Grammar Structure</h3>

<p>The grammar enforces operator precedence through its structure:</p>
<ul>
    <li><code>Expr</code> handles <code>+</code> and <code>-</code> (lowest precedence)</li>
    <li><code>Term</code> handles <code>*</code> and <code>/</code> (higher precedence)</li>
    <li><code>Factor</code> handles parentheses and numbers (highest precedence)</li>
</ul>

<h3>Evaluation</h3>

<p>The <code>evaluate</code> function recursively walks the parse tree:</p>
<ol>
    <li>For <code>NUMBER</code> nodes, return the parsed float value</li>
    <li>For nodes with children, recursively evaluate all children</li>
    <li>Find the operator and apply it to the operands</li>
    <li>For nodes without operators, return the first numeric value</li>
</ol>

<h2>Example Calculations</h2>

<p>Try these inputs:</p>
<ul>
    <li><code>1 + 2 * 3</code> = 7 (multiplication first)</li>
    <li><code>(1 + 2) * 3</code> = 9 (parentheses override)</li>
    <li><code>10 / 2 + 3</code> = 8 (division first)</li>
    <li><code>2.5 * 4</code> = 10 (floating point)</li>
</ul>
