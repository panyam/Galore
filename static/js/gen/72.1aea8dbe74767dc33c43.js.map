{"version":3,"file":"72.1aea8dbe74767dc33c43.js","mappings":"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","sources":["webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/parser.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/grammar.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/ll.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/dsl.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/ptables.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/lr.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/sets.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/graph.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/factory.js","webpack://galore/./node_modules/.pnpm/@panyam+tsappkit@file+..+..+..+golang+goapplib+tsappkit_ace-builds@1.43.5/node_modules/@panyam/tsappkit/dist/docs/index.mjs","webpack://galore/./node_modules/.pnpm/tlex@1.0.2/node_modules/tlex/lib/esm/builder.js","webpack://galore/./node_modules/.pnpm/tlex@1.0.2/node_modules/tlex/lib/esm/tokenizer.js","webpack://galore/./node_modules/.pnpm/tlex@1.0.2/node_modules/tlex/lib/esm/samples.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/lritems.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/errors.js"],"sourcesContent":["import * as TLEX from \"tlex\";\nexport class PFNode {\n    constructor(id, sym, value, ...children) {\n        this.id = id;\n        this.sym = sym;\n        this.value = value;\n        this.children = [];\n        this.children = children || [];\n    }\n    get childCount() {\n        return this.children.length;\n    }\n    childAt(index) {\n        if (index < 0)\n            return this.children[this.children.length + index];\n        return this.children[index];\n    }\n    get isTerminal() {\n        return this.sym.isTerminal;\n    }\n    add(node, index = -1) {\n        if (this.isTerminal) {\n            throw new Error(`Cannot add children (${node.sym.label}) to a terminal node: ${this.sym.label}`);\n        }\n        if (index < 0) {\n            this.children.push(node);\n        }\n        else {\n            this.children.splice(index, 0, node);\n        }\n        return this;\n    }\n    splice(index, numToDelete, ...nodes) {\n        this.children.splice(index, numToDelete, ...nodes);\n        return this;\n    }\n    get reprString() {\n        return this.debugValue(false).join(\"\\n\");\n    }\n    debugValue(raw = true) {\n        if (raw) {\n            const out = [this.sym.label];\n            if (this.value)\n                out.push(this.value);\n            if (this.children.length > 0)\n                out.push(this.children.map((c) => c.debugValue(raw)));\n            return out;\n        }\n        else {\n            const out = [];\n            const value = this.value;\n            out.push(this.value == null ? this.sym.label : this.sym.label + \" - \" + this.value);\n            this.children.forEach((node) => node.debugValue(raw).forEach((l) => out.push(\"  \" + l)));\n            return out;\n        }\n    }\n}\nexport class PTNode extends PFNode {\n    constructor() {\n        super(...arguments);\n        this.parent = null;\n    }\n    add(node, index = -1) {\n        super.add(node, index);\n        node.parent = this;\n        return this;\n    }\n    splice(index, numToDelete, ...nodes) {\n        for (const node of nodes)\n            node.parent = this;\n        return super.splice(index, numToDelete, ...nodes);\n    }\n}\nexport class ParserBase {\n    setTokenizer(tokenizer) {\n        this.tokenbuffer = new TLEX.TokenBuffer(tokenizer, null);\n        return this;\n    }\n    getSym(token) {\n        const out = this.grammar.getSym(token.tag);\n        if (out == null) {\n            throw new Error(\"Invalid token tag: \" + token.tag + \", Value: \" + token.value);\n        }\n        return out;\n    }\n}\nexport class SimpleParser extends ParserBase {\n    parse(input, delegate = null) {\n        if (typeof input === \"string\") {\n            input = new TLEX.Tape(input);\n        }\n        return this.parseInput(input, delegate);\n    }\n}\nexport class ParallelParser extends ParserBase {\n    parse(input, delegate = null) {\n        if (typeof input === \"string\") {\n            input = new TLEX.Tape(input);\n        }\n        return this.parseInput(input, delegate);\n    }\n}\n//# sourceMappingURL=parser.js.map","import * as TSU from \"@panyam/tsutils\";\nimport { allMinimalCycles } from \"./graph\";\nimport { IDSet, SymbolSet, FollowSets } from \"./sets\";\nexport class Sym {\n    constructor(grammar, label, isTerminal, id = null) {\n        this.grammar = grammar;\n        this.label = label;\n        this.isTerminal = isTerminal;\n        this.isAuxiliary = false;\n        this.auxType = null;\n        this.precedence = 1;\n        this.assocLeft = true;\n        this.creationId = -1;\n        this.isTerminal = isTerminal;\n        this.label = label;\n        if (id == null) {\n            this.id = Sym.idCounter--;\n        }\n        else {\n            this.id = id;\n        }\n    }\n    compareTo(another) {\n        return this.label.localeCompare(another.label);\n    }\n    equals(another) {\n        return this.label == another.label;\n    }\n    toString() {\n        return this.label;\n    }\n}\nSym.idCounter = -1;\nexport class Str {\n    constructor(...syms) {\n        this.syms = syms || [];\n    }\n    append(...lits) {\n        for (const l of lits)\n            this.syms.push(l);\n        return this;\n    }\n    extend(...strs) {\n        for (const s of strs)\n            this.append(...s.syms);\n        return this;\n    }\n    copy() {\n        return new Str(...this.syms);\n    }\n    add(lit) {\n        this.syms.push(lit);\n    }\n    isTerminal(index) {\n        return this.syms[index].isTerminal;\n    }\n    get length() {\n        return this.syms.length;\n    }\n    toString() {\n        return this.syms.map((s) => s.toString()).join(\" \");\n    }\n    slice(startIndex, endIndex) {\n        return new Str(...this.syms.slice(startIndex, endIndex));\n    }\n    splice(index, numToDelete, ...itemsToAdd) {\n        this.syms.splice(index, numToDelete, ...itemsToAdd);\n        return this;\n    }\n    compareTo(another) {\n        for (let i = 0; i < this.syms.length && i < another.syms.length; i++) {\n            const diff = this.syms[i].compareTo(another.syms[i]);\n            if (diff != 0)\n                return diff;\n        }\n        return this.syms.length - another.syms.length;\n    }\n    equals(another) {\n        return this.compareTo(another) == 0;\n    }\n    containsAt(offset, another) {\n        let i = 0;\n        for (; i < another.length && offset + i < this.syms.length; i++) {\n            if (!this.syms[offset + i].equals(another.syms[i]))\n                return false;\n        }\n        return i == another.length;\n    }\n    get debugString() {\n        return this.syms.map((lit) => lit.label).join(\" \");\n    }\n}\nexport class RuleAction {\n    constructor(value) {\n        this.value = value;\n    }\n    get isFunction() {\n        return typeof this.value === \"string\";\n    }\n    get isChildPosition() {\n        return typeof this.value === \"number\";\n    }\n}\nexport class Rule {\n    constructor(nt, rhs, action = null) {\n        this.nt = nt;\n        this.rhs = rhs;\n        this.action = action;\n        if (nt.isTerminal) {\n            throw new Error(\"Cannot add rules to a terminal\");\n        }\n    }\n    get debugString() {\n        return `${this.nt.label} -> ${this.rhs.debugString}`;\n    }\n    equals(another) {\n        return this.compareTo(another) == 0;\n    }\n    compareTo(another) {\n        TSU.assert(!isNaN(this.id));\n        const diff = this.nt.compareTo(another.nt);\n        if (diff == 0) {\n            this.rhs.compareTo(another.rhs);\n        }\n        return diff;\n    }\n}\nexport class Grammar {\n    static make(callback) {\n        const g = new Grammar();\n        callback(g);\n        return g;\n    }\n    constructor(config) {\n        this.startSymbol = null;\n        this.modified = true;\n        this.symbolSet = new IDSet((s) => s.label);\n        this.allRules = [];\n        this._rulesForNT = null;\n        this._followSets = null;\n        this._hasNull = false;\n        this.auxNTCount = 0;\n        config = config || {};\n        this.auxNTPrefix = config.auxNTPrefix || \"$\";\n        this.Null = this.newTerm(\"\");\n        this.Eof = this.newTerm(\"$end\");\n    }\n    rulesForNT(nt) {\n        TSU.assert(!nt.isTerminal);\n        if (this._rulesForNT == null) {\n            this._rulesForNT = {};\n            for (const rule of this.allRules) {\n                if (!(rule.nt.label in this._rulesForNT)) {\n                    this._rulesForNT[rule.nt.label] = [];\n                }\n                this._rulesForNT[rule.nt.label].push(rule);\n            }\n        }\n        if (!(nt.label in this._rulesForNT)) {\n            this._rulesForNT[nt.label] = [];\n        }\n        return this._rulesForNT[nt.label];\n    }\n    get nullables() {\n        return this.firstSets.nullables;\n    }\n    get firstSets() {\n        return this.followSets.firstSets;\n    }\n    get followSets() {\n        if (this.modified || this._followSets == null) {\n            this.refresh();\n        }\n        TSU.assert(this._followSets != null);\n        return this._followSets;\n    }\n    get augStartRule() {\n        return this._AugStartRule;\n    }\n    augmentStartSymbol(label = \"$accept\") {\n        TSU.assert(this._AugStartRule == null, \"Ensure this grammar has not yet been augmented.\");\n        TSU.assert(this.startSymbol != null, \"Start symbol not yet set\");\n        const augSym = this.newNT(label);\n        this._AugStartRule = new Rule(augSym, new Str(this.startSymbol));\n        this.addRule(this._AugStartRule, 0);\n        return this;\n    }\n    refresh() {\n        this.symbolSet.entries.forEach((s, i) => (s.id = i));\n        this._rulesForNT = null;\n        this.allRules.forEach((rule, i) => {\n            rule.id = i;\n        });\n        this._followSets = new FollowSets(this);\n        this.modified = false;\n        return this;\n    }\n    addTerminals(...terminals) {\n        for (const t of terminals) {\n            this.newTerm(t);\n        }\n    }\n    get terminals() {\n        return this.symbolSet.entries.filter((x) => x.isTerminal);\n    }\n    get allNonTerminals() {\n        return this.symbolSet.entries.filter((x) => !x.isTerminal);\n    }\n    get nonTerminals() {\n        return this.symbolSet.entries.filter((x) => !x.isTerminal && !x.isAuxiliary);\n    }\n    get auxNonTerminals() {\n        return this.symbolSet.entries.filter((x) => x.isAuxiliary);\n    }\n    get allSymbols() {\n        return this.symbolSet.entries;\n    }\n    forEachNT(visitor) {\n        for (const sym of this.symbolSet.entries) {\n            if (sym.isTerminal)\n                continue;\n            if (visitor(sym) == false)\n                return;\n        }\n    }\n    forEachRule(nt, visitor) {\n        const rules = nt == null ? this.allRules : this.rulesForNT(nt) || [];\n        for (let i = 0; i < rules.length; i++) {\n            if (visitor(rules[i], i) == false)\n                return false;\n        }\n        return true;\n    }\n    getRule(nt, index) {\n        if (typeof nt === \"string\")\n            nt = this.getSym(nt);\n        TSU.assert(nt != null);\n        return this.rulesForNT(nt)[index];\n    }\n    findRule(nt, production) {\n        return this.rulesForNT(nt).findIndex((r) => r.nt == nt && r.rhs.equals(production));\n    }\n    add(nt, production, action = null) {\n        let nonterm = null;\n        if (typeof nt === \"string\") {\n            nonterm = this.getSym(nt);\n            if (nonterm == null) {\n                nonterm = this.newNT(nt);\n            }\n        }\n        else {\n            nonterm = this.ensureSym(nt);\n        }\n        return this.addRule(new Rule(nonterm, production, action));\n    }\n    addRule(rule, index = -1) {\n        if (this.findRule(rule.nt, rule.rhs) >= 0) {\n            throw new Error(\"Duplicate rule: \" + rule.debugString);\n        }\n        rule.id = this.allRules.length;\n        if (rule.rhs.length == 0)\n            this._hasNull = true;\n        if (index < 0) {\n            this.allRules.push(rule);\n        }\n        else {\n            this.allRules.splice(index, 0, rule);\n        }\n        this._rulesForNT = null;\n        this.modified = true;\n        return rule;\n    }\n    removeRules(pred) {\n        this.allRules = this.allRules.filter((r) => !pred(r));\n        this._rulesForNT = null;\n        this.modified = true;\n        return true;\n    }\n    removeSymbols(pred) {\n        let modified = false;\n        const newRules = [];\n        this.allRules.forEach((r) => {\n            if (pred(r.nt))\n                return;\n            if (r.rhs.length == 0) {\n                newRules.push(r);\n            }\n            else {\n                const newRhs = new Str(...r.rhs.syms.filter((s) => !pred(s)));\n                modified = modified || r.rhs.length != newRhs.length;\n                if (newRhs.length > 0) {\n                    newRules.push(new Rule(r.nt, newRhs));\n                }\n            }\n        });\n        this.allRules = newRules;\n        modified = this.symbolSet.remove(pred) || modified;\n        this.modified = this.modified || modified;\n        return modified;\n    }\n    getSymById(id) {\n        return this.symbolSet.get(id);\n    }\n    getSym(label) {\n        return this.symbolSet.getByKey(label);\n    }\n    ensureSym(sym, throwIfExists = false) {\n        const sym2 = this.symbolSet.ensure(sym, throwIfExists);\n        if (sym == sym2) {\n            if (sym2.creationId < 0) {\n                sym2.creationId = this.symbolSet.size;\n            }\n        }\n        else {\n            TSU.assert(!throwIfExists, \"Should have already thrown error\");\n        }\n        return sym2;\n    }\n    T(label, throwIfExists = false) {\n        let t = this.getSym(label);\n        if (t != null) {\n            if (throwIfExists)\n                throw new Error(`Terminal ${label} is already exists`);\n            if (!t.isTerminal)\n                throw new Error(`Symbol (${label}) already exists as a non-terminal`);\n        }\n        else {\n            t = new Sym(this, label, true);\n            t = this.ensureSym(t, true);\n        }\n        return t;\n    }\n    NT(label, isAuxiliary = false, throwIfExists = false) {\n        let nt = this.getSym(label);\n        if (nt != null) {\n            if (throwIfExists)\n                throw new Error(`Non-terminal ${label} is already exists`);\n            if (nt.isTerminal)\n                throw new Error(`Symbol (${label}) already exists as a terminal`);\n        }\n        else {\n            nt = new Sym(this, label, false);\n            nt.isAuxiliary = isAuxiliary;\n            nt = this.ensureSym(nt, true);\n            if (!isAuxiliary && this.startSymbol == null) {\n                this.startSymbol = nt;\n            }\n        }\n        return nt;\n    }\n    newTerm(label) {\n        return this.T(label, true);\n    }\n    newNT(label, isAuxiliary = false) {\n        return this.NT(label, isAuxiliary, true);\n    }\n    isTerminal(label) {\n        const t = this.getSym(label);\n        return t != null && t.isTerminal;\n    }\n    isNT(label) {\n        const t = this.getSym(label);\n        return t != null && !t.isTerminal && !t.isAuxiliary;\n    }\n    isAuxNT(label) {\n        const t = this.getSym(label);\n        return t != null && !t.isTerminal && t.isAuxiliary;\n    }\n    seq(...exps) {\n        if (exps.length == 1) {\n            return this.normalizeRule(exps[0]);\n        }\n        else {\n            const out = new Str();\n            for (const e of exps) {\n                const s = this.normalizeRule(e);\n                for (let i = 0; i < s.length; i++) {\n                    out.add(s.syms[i]);\n                }\n            }\n            return out;\n        }\n    }\n    anyof(...rules) {\n        if (rules.length == 1) {\n            return this.normalizeRule(rules[0]);\n        }\n        else {\n            return new Str(this.ensureAuxNT(...rules.map((r) => this.normalizeRule(r))));\n        }\n    }\n    opt(exp) {\n        const out = this.anyof(exp, new Str());\n        const nt = out.syms[0];\n        TSU.assert(out.syms.length == 1 && nt.isAuxiliary, \"NT must be an auxiliary symbol\");\n        nt.auxType = \"opt\";\n        return out;\n    }\n    atleast0(exp, leftRec = true) {\n        const s = this.normalizeRule(exp);\n        let auxNT = this.findAuxNT((auxNT) => {\n            const rules = this.rulesForNT(auxNT);\n            if (rules.length != 2)\n                return false;\n            let which = 0;\n            if (rules[0].rhs.length == 0) {\n                which = 1;\n            }\n            else if (rules[1].rhs.length == 0) {\n                which = 0;\n            }\n            else {\n                return false;\n            }\n            const rule = rules[which].rhs;\n            if (rule.length != 1 + exp.length)\n                return false;\n            if (rule.syms[0].equals(auxNT)) {\n                return rule.containsAt(1, s);\n            }\n            else if (rule.syms[rule.length - 1].equals(auxNT)) {\n                return rule.containsAt(0, s);\n            }\n            return false;\n        });\n        if (auxNT == null) {\n            auxNT = this.newAuxNT();\n            auxNT.auxType = leftRec ? \"atleast0:left\" : \"atleast0\";\n            this.add(auxNT, new Str());\n            if (leftRec) {\n                this.add(auxNT, new Str(auxNT).extend(s));\n            }\n            else {\n                this.add(auxNT, s.copy().append(auxNT));\n            }\n        }\n        return new Str(auxNT);\n    }\n    atleast1(exp, leftRec = true) {\n        const s = this.normalizeRule(exp);\n        let auxNT = this.findAuxNT((auxNT) => {\n            const rules = this.rulesForNT(auxNT);\n            if (rules.length != 2)\n                return false;\n            let which = 0;\n            if (rules[0].rhs.equals(s)) {\n                which = 1;\n            }\n            else if (rules[1].rhs.equals(s)) {\n                which = 0;\n            }\n            else {\n                return false;\n            }\n            const rule = rules[which].rhs;\n            if (rule.length != 1 + exp.length)\n                return false;\n            if (rule.syms[0].equals(auxNT)) {\n                return rule.containsAt(1, s);\n            }\n            else if (rule.syms[rule.length - 1].equals(auxNT)) {\n                return rule.containsAt(0, s);\n            }\n            return false;\n        });\n        if (auxNT == null) {\n            auxNT = this.newAuxNT();\n            auxNT.auxType = leftRec ? \"atleast1:left\" : \"atleast1\";\n            this.add(auxNT, s);\n            if (leftRec) {\n                this.add(auxNT, new Str(auxNT).extend(s));\n            }\n            else {\n                this.add(auxNT, s.copy().append(auxNT));\n            }\n        }\n        return new Str(auxNT);\n    }\n    normalizeRule(exp) {\n        if (typeof exp === \"string\") {\n            const lit = this.getSym(exp);\n            if (lit == null)\n                throw new Error(`Invalid symbol: '${exp}'`);\n            return new Str(lit);\n        }\n        else {\n            return exp;\n        }\n    }\n    newAuxNTName() {\n        return this.auxNTPrefix + this.auxNTCount++;\n    }\n    newAuxNT(name = \"\") {\n        if (name == \"\")\n            name = this.newAuxNTName();\n        return this.newNT(name, true);\n    }\n    ensureAuxNT(...rules) {\n        let nt = this.findAuxNTByRules(...rules);\n        if (nt == null) {\n            nt = this.newAuxNT();\n            nt.auxType = \"anyof\";\n            for (const rule of rules)\n                this.add(nt, rule);\n        }\n        return nt;\n    }\n    findAuxNT(filter) {\n        for (const auxNT of this.symbolSet.entries) {\n            if (!auxNT.isAuxiliary)\n                continue;\n            if (filter(auxNT))\n                return auxNT;\n        }\n        return null;\n    }\n    findAuxNTByRules(...rules) {\n        return this.findAuxNT((auxNT) => {\n            const ntRules = this.rulesForNT(auxNT);\n            if (ntRules.length != rules.length)\n                return false;\n            for (let i = 0; i < ntRules.length; i++) {\n                if (!ntRules[i].rhs.equals(rules[i]))\n                    return false;\n            }\n            return true;\n        });\n    }\n    print(options = null) {\n        options = options || {};\n        const ruleSep = options.ruleSep || \"->\";\n        const includeSemiColon = options.includeSemiColon || false;\n        const lambdaSymbol = options.lambdaSymbol || \"\";\n        const out = [];\n        this.forEachRule(null, (rule, index) => {\n            let r = `${rule.nt.label} ${ruleSep} `;\n            if (rule.rhs.length > 0)\n                r += rule.rhs.debugString;\n            else\n                r += lambdaSymbol;\n            if (includeSemiColon)\n                r += \" ;\";\n            out.push(r);\n        });\n        return out;\n    }\n    get debugValue() {\n        const out = [];\n        this.forEachRule(null, (rule, index) => {\n            out.push(`${rule.nt.label} -> ${rule.rhs.debugString}`);\n        });\n        return out;\n    }\n    get terminalDerivingSymbols() {\n        const out = new SymbolSet(this, null);\n        let nadded = -1;\n        let allDerive = true;\n        while (nadded != 0) {\n            nadded = 0;\n            for (const rule of this.allRules) {\n                allDerive = true;\n                for (const sym of rule.rhs.syms) {\n                    if (!out.has(sym)) {\n                        if (sym.isTerminal) {\n                            out.add(sym);\n                            nadded++;\n                        }\n                        else {\n                            allDerive = false;\n                        }\n                    }\n                }\n                if (allDerive && !out.has(rule.nt)) {\n                    out.add(rule.nt);\n                    nadded++;\n                }\n            }\n        }\n        return out;\n    }\n    reachableSymbols(fromSymbol = null) {\n        if (fromSymbol == null) {\n            fromSymbol = this._AugStartRule ? this._AugStartRule.nt : this.startSymbol;\n        }\n        TSU.assert(fromSymbol != null, \"Start symbol does not exist\");\n        const reachable = new SymbolSet(this, false).add(fromSymbol);\n        let queue = [fromSymbol];\n        while (queue.length > 0) {\n            const newQueue = [];\n            for (const curr of queue) {\n                for (const rule of this.rulesForNT(curr)) {\n                    for (const sym of rule.rhs.syms) {\n                        if (!sym.isTerminal && !reachable.has(sym)) {\n                            newQueue.push(sym);\n                            reachable.add(sym);\n                        }\n                    }\n                }\n            }\n            queue = newQueue;\n        }\n        return reachable;\n    }\n    get cycles() {\n        const edgeFunctor = (node) => {\n            const out = [];\n            this.forEachRule(node, (rule, ruleIndex) => {\n                rule.rhs.syms.forEach((s, j) => {\n                    if (s.isTerminal)\n                        return;\n                    if (this.nullables.isStrNullable(rule.rhs, 0, j - 1) && this.nullables.isStrNullable(rule.rhs, j + 1)) {\n                        out.push([s, [node, ruleIndex]]);\n                    }\n                });\n            });\n            return out;\n        };\n        return allMinimalCycles(this.allNonTerminals, (val) => val.label, edgeFunctor);\n    }\n    get leftRecursion() {\n        const edgeFunctor = (node) => {\n            const out = [];\n            this.forEachRule(node, (rule, ruleIndex) => {\n                rule.rhs.syms.forEach((s, j) => {\n                    if (s.isTerminal)\n                        return;\n                    out.push([s, ruleIndex]);\n                    return this.nullables.isNullable(s);\n                });\n            });\n            return out;\n        };\n        return allMinimalCycles(this.allNonTerminals, (val) => val.id, edgeFunctor);\n    }\n}\n//# sourceMappingURL=grammar.js.map","import * as TSU from \"@panyam/tsutils\";\nimport { Sym } from \"./grammar\";\nimport { PTNode, SimpleParser as ParserBase } from \"./parser\";\nimport { printGrammar } from \"./utils\";\nexport class ParseTable {\n    constructor(grammar) {\n        this.grammar = grammar;\n        this.refresh();\n    }\n    refresh() {\n        this.entries = new Map();\n        this.grammar.followSets.refresh();\n        this.grammar.forEachRule(null, (rule, index) => {\n            this.processRule(rule, index);\n        });\n        const printed = printGrammar(this.grammar, false);\n        const t1 = this.grammar.cycles;\n        const t2 = this.grammar.leftRecursion;\n        return this;\n    }\n    get count() {\n        let c = 0;\n        for (const nt of this.entries.values()) {\n            for (const term of nt.values()) {\n                c += term.length;\n            }\n        }\n        return c;\n    }\n    ensureEntry(nt, term) {\n        TSU.assert(!nt.isTerminal && term.isTerminal);\n        let entriesForNT = this.entries.get(nt.id);\n        if (!entriesForNT) {\n            entriesForNT = new Map();\n            this.entries.set(nt.id, entriesForNT);\n        }\n        let entries = entriesForNT.get(term.id);\n        if (!entries) {\n            entries = [];\n            entriesForNT.set(term.id, entries);\n        }\n        return entries;\n    }\n    add(nt, term, entry) {\n        const entries = this.ensureEntry(nt, term);\n        if (entries.findIndex((e) => e.equals(entry)) < 0) {\n            entries.push(entry);\n        }\n        return entries.length == 1;\n    }\n    get(nt, term) {\n        return this.ensureEntry(nt, term);\n    }\n    forEachEntry(visitor) {\n        for (const ntId of this.entries.keys()) {\n            const ntMap = this.entries.get(ntId) || null;\n            TSU.assert(ntMap != null);\n            const nonterm = this.grammar.getSymById(ntId);\n            TSU.assert(nonterm != null);\n            for (const termId of ntMap.keys()) {\n                const term = this.grammar.getSymById(termId);\n                TSU.assert(term != null);\n                const items = ntMap.get(termId) || [];\n                if (visitor(nonterm, term, items) == false)\n                    return;\n            }\n        }\n    }\n    get debugValue() {\n        const out = {};\n        this.forEachEntry((nt, term, items) => {\n            out[nt.label] = out[nt.label] || {};\n            out[nt.label][term.label] = out[nt.label][term.label] || [];\n            const entries = out[nt.label][term.label];\n            for (const item of items) {\n                entries.push(item.debugString);\n            }\n        });\n        return out;\n    }\n    processRule(rule, index) {\n        const firstSets = this.grammar.firstSets;\n        let ruleIsNullable = false;\n        firstSets.forEachTermIn(rule.rhs, 0, (term) => {\n            if (term == null) {\n                ruleIsNullable = true;\n            }\n            else {\n                this.add(rule.nt, term, rule);\n            }\n        });\n        if (ruleIsNullable) {\n            this.grammar.followSets.forEachTerm(rule.nt, (term) => {\n                TSU.assert(term != null, \"Follow sets cannot have null\");\n                this.add(rule.nt, term, rule);\n            });\n        }\n    }\n}\nexport class ParseStack {\n    constructor(parseTable) {\n        this.idCounter = 0;\n        this.parseTable = parseTable;\n        this.stack = [];\n        const g = parseTable.grammar;\n        TSU.assert(g.startSymbol != null, \"Start symbol not selected\");\n        this.docNode = this.push(g.Eof, new PTNode(this.idCounter++, new Sym(g, \"<DOC>\", false), null));\n        this.rootNode = this.push(g.startSymbol);\n        this.docNode.add(this.rootNode);\n    }\n    get debugString() {\n        return \"Stack: [\" + this.stack.map((x) => x[0].label).join(\", \") + \"]\";\n    }\n    push(sym, node = null) {\n        if (!node)\n            node = new PTNode(this.idCounter++, sym, null);\n        this.stack.push([sym, node]);\n        return node;\n    }\n    top() {\n        return this.stack[this.stack.length - 1];\n    }\n    pop() {\n        if (this.stack.length == 0) {\n            TSU.assert(false, \"Stacks are empty\");\n        }\n        return this.stack.pop();\n    }\n    get isEmpty() {\n        return this.stack.length == 0;\n    }\n}\nexport class Parser extends ParserBase {\n    constructor(parseTable) {\n        super();\n        this.parseTable = parseTable;\n        TSU.assert(parseTable.grammar.startSymbol != null, \"Start symbol not selected\");\n    }\n    get grammar() {\n        return this.parseTable.grammar;\n    }\n    parseInput(input, delegate = null) {\n        this.stack = new ParseStack(this.parseTable);\n        const tokenbuffer = this.tokenbuffer;\n        const stack = this.stack;\n        const g = this.grammar;\n        let token;\n        let topItem;\n        let topNode;\n        do {\n            token = tokenbuffer.peek(input);\n            [topItem, topNode] = stack.top();\n            const nextSym = token == null ? g.Eof : this.getSym(token);\n            const nextValue = token == null ? null : token.value;\n            if (topItem.isTerminal) {\n                if (topItem == nextSym) {\n                    this.consumeTokenAndPop(input, nextSym, token);\n                }\n                else {\n                    this.processInvalidToken(nextSym, token);\n                }\n            }\n            else {\n                const entries = this.parseTable.get(topItem, nextSym);\n                if (entries.length != 1) {\n                    console.log(\"TopItem: \", topItem);\n                    console.log(\"nextSym: \", nextSym);\n                    this.processInvalidReductions(topNode, topItem, nextSym, nextValue, entries);\n                }\n                else {\n                    const [sym, ptnode] = this.stack.pop();\n                    TSU.assert(ptnode == topNode);\n                    TSU.assert(sym == entries[0].nt);\n                    TSU.assert(ptnode.sym == sym);\n                    this.popSymAndPushRule(ptnode, entries[0]);\n                }\n            }\n            [topItem, topNode] = stack.top();\n        } while (topItem != g.Eof);\n        return stack.rootNode;\n    }\n    popSymAndPushRule(parentNode, rule) {\n        for (let i = rule.rhs.syms.length - 1; i >= 0; i--) {\n            const sym = rule.rhs.syms[i];\n            const node = this.stack.push(sym);\n            parentNode.add(node, 0);\n        }\n    }\n    consumeTokenAndPop(tape, nextSym, nextToken) {\n        const [sym, ptnode] = this.stack.top();\n        TSU.assert(sym == nextSym);\n        TSU.assert(ptnode.sym == nextSym);\n        ptnode.value = nextToken.value;\n        this.tokenbuffer.next(tape);\n        this.stack.pop();\n    }\n    processInvalidToken(nextSym, nextValue) {\n        throw new Error(\"Invalid token: \" + nextSym.label);\n        return true;\n    }\n    processInvalidReductions(topNode, currSym, nextSym, nextValue, entries) {\n        throw new Error(`Invalid # reductions ${entries.length} found ${currSym.label} -> ${nextSym.label}`);\n        return true;\n    }\n}\n//# sourceMappingURL=ll.js.map","import * as TSU from \"@panyam/tsutils\";\nimport * as TLEX from \"tlex\";\nimport { Grammar, Str, RuleAction } from \"./grammar\";\nconst str2regex = (s) => {\n    if (typeof s === \"number\")\n        return \"\" + s;\n    return s.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n};\nexport var TokenType;\n(function (TokenType) {\n    TokenType[\"STRING\"] = \"STRING\";\n    TokenType[\"REGEX\"] = \"REGEX\";\n    TokenType[\"NUMBER\"] = \"NUMBER\";\n    TokenType[\"SPACES\"] = \"SPACES\";\n    TokenType[\"IDENT\"] = \"IDENT\";\n    TokenType[\"PCT_IDENT\"] = \"PCT_IDENT\";\n    TokenType[\"STAR\"] = \"STAR\";\n    TokenType[\"PLUS\"] = \"PLUS\";\n    TokenType[\"QMARK\"] = \"QMARK\";\n    TokenType[\"PIPE\"] = \"PIPE\";\n    TokenType[\"DOLLAR_NUM\"] = \"DOLLAR_NUM\";\n    TokenType[\"DOLLAR_IDENT\"] = \"DOLLAR_IDENT\";\n    TokenType[\"OPEN_PAREN\"] = \"OPEN_PAREN\";\n    TokenType[\"CLOSE_PAREN\"] = \"CLOSE_PAREN\";\n    TokenType[\"OPEN_BRACE\"] = \"OPEN_BRACE\";\n    TokenType[\"CLOSE_BRACE\"] = \"CLOSE_BRACE\";\n    TokenType[\"OPEN_SQ\"] = \"OPEN_SQ\";\n    TokenType[\"CLOSE_SQ\"] = \"CLOSE_SQ\";\n    TokenType[\"COMMENT\"] = \"COMMENT\";\n    TokenType[\"ARROW\"] = \"ARROW\";\n    TokenType[\"COLCOLHYPHEN\"] = \"COLCOLHYPHEN\";\n    TokenType[\"COLON\"] = \"COLON\";\n    TokenType[\"SEMI_COLON\"] = \"SEMI_COLON\";\n})(TokenType || (TokenType = {}));\nexport function load(input, params) {\n    params = params || {};\n    const g = new Grammar(params.grammar || {});\n    const eparser = new Loader(input, { ...params, grammar: g });\n    const tokenFunc = eparser.generatedTokenizer.next.bind(eparser.generatedTokenizer);\n    const debug = params.debug || \"\";\n    if (debug.split(\"|\").findIndex((p) => p == \"all\" || p == \"lexer\") >= 0) {\n        console.log(\"Prog: \\n\", `${eparser.generatedTokenizer.vm.prog.debugValue().join(\"\\n\")}`);\n    }\n    return [g, tokenFunc];\n}\nexport function Tokenizer() {\n    const lexer = new TLEX.Tokenizer();\n    lexer.add(/->/, { tag: TokenType.ARROW });\n    lexer.add(/\\[/, { tag: TokenType.OPEN_SQ });\n    lexer.add(/\\]/, { tag: TokenType.CLOSE_SQ });\n    lexer.add(/\\(/, { tag: TokenType.OPEN_PAREN });\n    lexer.add(/\\)/, { tag: TokenType.CLOSE_PAREN });\n    lexer.add(/\\{/, { tag: TokenType.OPEN_BRACE });\n    lexer.add(/\\}/, { tag: TokenType.CLOSE_BRACE });\n    lexer.add(/\\*/, { tag: TokenType.STAR });\n    lexer.add(/\\+/, { tag: TokenType.PLUS });\n    lexer.add(/\\?/, { tag: TokenType.QMARK });\n    lexer.add(/;/, { tag: TokenType.SEMI_COLON });\n    lexer.add(/:/, { tag: TokenType.COLON });\n    lexer.add(/\\|/, { tag: TokenType.PIPE });\n    lexer.add(/\\s+/m, { tag: TokenType.SPACES }, () => null);\n    lexer.add(/\\/\\*.*?\\*\\//s, { tag: TokenType.COMMENT }, () => null);\n    lexer.add(/\\/\\/.*$/m, { tag: TokenType.COMMENT }, () => null);\n    lexer.add(TLEX.Samples.DOUBLE_QUOTE_STRING, { tag: TokenType.STRING }, (rule, tape, token) => {\n        token.value = tape.substring(token.start + 1, token.end - 1);\n        return token;\n    });\n    lexer.add(TLEX.Samples.SINGLE_QUOTE_STRING, { tag: TokenType.STRING }, (rule, tape, token) => {\n        token.value = tape.substring(token.start + 1, token.end - 1);\n        return token;\n    });\n    lexer.add(TLEX.Samples.JS_REGEX, { tag: TokenType.REGEX }, (rule, tape, token) => {\n        const pattern = tape.substring(token.positions[1][0], token.positions[1][1]);\n        const flags = tape.substring(token.positions[3][0], token.positions[3][1]);\n        token.value = [pattern, flags];\n        return token;\n    });\n    lexer.add(/\\d+/, { tag: TokenType.NUMBER }, (rule, tape, token) => {\n        token.value = parseInt(tape.substring(token.start, token.end));\n        return token;\n    });\n    lexer.add(/%([\\w][\\w\\d_]*)/, { tag: TokenType.PCT_IDENT }, (rule, tape, token) => {\n        token.value = tape.substring(token.start + 1, token.end);\n        return token;\n    });\n    lexer.add(/\\$\\d+/, { tag: TokenType.DOLLAR_NUM }, (rule, tape, token) => {\n        token.value = parseInt(tape.substring(token.start + 1, token.end));\n        return token;\n    });\n    lexer.add(/\\$([\\w][\\w\\d_]*)/, { tag: TokenType.DOLLAR_IDENT }, (rule, tape, token) => {\n        token.value = tape.substring(token.start + 1, token.end);\n        return token;\n    });\n    lexer.add(/[\\w][\\w\\d_]*/, { tag: TokenType.IDENT });\n    return lexer;\n}\nexport var NodeType;\n(function (NodeType) {\n    NodeType[\"GRAMMAR\"] = \"GRAMMAR\";\n    NodeType[\"DECL\"] = \"DECL\";\n    NodeType[\"RULE\"] = \"RULE\";\n    NodeType[\"PROD_NULL\"] = \"PROD_NULL\";\n    NodeType[\"PROD_STR\"] = \"PROD_STR\";\n    NodeType[\"PROD_UNION\"] = \"PROD_UNION\";\n    NodeType[\"PROD_NAME\"] = \"PROD_NAME\";\n    NodeType[\"PROD_STRING\"] = \"PROD_STRING\";\n    NodeType[\"PROD_NUM\"] = \"PROD_NUM\";\n    NodeType[\"PROD_IDENT\"] = \"PROD_IDENT\";\n    NodeType[\"PROD_STAR\"] = \"PROD_STAR\";\n    NodeType[\"PROD_PLUS\"] = \"PROD_PLUS\";\n    NodeType[\"PROD_OPTIONAL\"] = \"PROD_OPTIONAL\";\n    NodeType[\"IDENT\"] = \"IDENT\";\n    NodeType[\"ERROR\"] = \"ERROR\";\n    NodeType[\"COMMENT\"] = \"COMMENT\";\n})(NodeType || (NodeType = {}));\nexport class Loader {\n    constructor(input, config) {\n        this.leftRecursive = false;\n        this.generatedTokenizer = new TLEX.Tokenizer();\n        this.regexSyntax = \"js\";\n        config = config || {};\n        this.symbolsByLabel = {};\n        this.grammar = config.grammar || new Grammar();\n        this.leftRecursive = \"leftRecursive\" in config ? config.leftRecursive || false : true;\n        this.newSymbolCallback = config.newSymbolCallback || null;\n        this.tokenHandlers = config.tokenHandlers || {};\n        this.parse(input);\n    }\n    symbolForLabel(label) {\n        return this.symbolsByLabel[label] || null;\n    }\n    registerSymbol(label, sym) {\n        TSU.assert(!(label in this.symbolsByLabel), `${label} is already registered`);\n        this.symbolsByLabel[label] = sym;\n    }\n    ensureSymbol(label, assumedTerminal) {\n        let currSym = this.symbolForLabel(label);\n        if (currSym != null)\n            return currSym;\n        else if (this.newSymbolCallback) {\n            currSym = this.newSymbolCallback(label, assumedTerminal) || null;\n        }\n        if (currSym == null) {\n            if (assumedTerminal) {\n                currSym = this.grammar.newTerm(label);\n            }\n            else {\n                currSym = this.grammar.newNT(label);\n            }\n        }\n        this.registerSymbol(label, currSym);\n        return currSym;\n    }\n    parse(input) {\n        const et = Tokenizer();\n        const ntFunc = (tape, owner) => {\n            const out = et.next(tape, this);\n            return out;\n        };\n        this.tokenizer = new TLEX.TokenBuffer(ntFunc, this);\n        this.parseGrammar(new TLEX.Tape(input));\n    }\n    parseRegex(tape, tag, priority = 0, syntax = \"\") {\n        if (syntax == \"\")\n            syntax = this.regexSyntax;\n        if (syntax == \"js\") {\n            const tokPattern = this.tokenizer.expectToken(tape, TokenType.STRING, TokenType.NUMBER, TokenType.REGEX);\n            let rule;\n            if (!tag || tag.length == 0) {\n                tag = \"/\" + tokPattern.value[0] + \"/\" + tokPattern.value[1];\n            }\n            if (tokPattern.tag == TokenType.STRING || tokPattern.tag == TokenType.NUMBER) {\n                const pattern = str2regex(tokPattern.value);\n                rule = TLEX.Builder.build(pattern, { tag: tag, priority: priority + 20 });\n            }\n            else if (tokPattern.tag == TokenType.REGEX) {\n                let re = tokPattern.value[0];\n                if (tokPattern.value[1].length > 0) {\n                    re = new RegExp(tokPattern.value[0], tokPattern.value[1]);\n                }\n                rule = TLEX.Builder.build(re, { tag: tag, priority: priority + 10 });\n            }\n            else {\n                throw new TLEX.UnexpectedTokenError(tokPattern);\n            }\n            return rule;\n        }\n        else {\n            let patternStr = \"\";\n            while (tape.hasMore && tape.currCh != \"\\n\") {\n                patternStr += tape.currCh;\n                tape.advance();\n            }\n            patternStr = patternStr.trim();\n            if (!tag || tag.length == 0) {\n                tag = \"/\" + patternStr + \"/\";\n            }\n            return new TLEX.Rule(TLEX.Builder.exprFromFlexRE(patternStr), { tag: tag, priority: priority });\n        }\n    }\n    parseGrammar(tape) {\n        let peeked = this.tokenizer.peek(tape);\n        while (peeked != null) {\n            if (peeked.tag == TokenType.IDENT) {\n                this.parseDecl(tape);\n            }\n            else if (peeked.tag == TokenType.PCT_IDENT) {\n                this.tokenizer.next(tape);\n                this.parseDirective(tape, peeked.value);\n            }\n            else {\n                throw new SyntaxError(`Declaration must start with IDENT or PCT_IDENT.  Found: '${peeked.value}' instead.`);\n            }\n            peeked = this.tokenizer.peek(tape);\n        }\n    }\n    parseDirective(tape, directive) {\n        if (directive == \"start\") {\n            const next = this.tokenizer.expectToken(tape, TokenType.IDENT);\n            this.grammar.startSymbol = this.ensureSymbol(next.value, false);\n        }\n        else if (directive == \"resyntax\") {\n            const next = this.tokenizer.expectToken(tape, TokenType.IDENT);\n            if (next.value != \"js\" && next.value != \"flex\") {\n                throw new SyntaxError(\"Invalid regex syntax: \" + next.value);\n            }\n            this.regexSyntax = next.value;\n        }\n        else if (directive.startsWith(\"skip\")) {\n            const rule = this.parseRegex(tape, \"\", 30, directive.endsWith(\"flex\") ? \"flex\" : \"\");\n            const tokenHandler = this.parseTokenHandler(tape);\n            if (tokenHandler) {\n                this.generatedTokenizer.addRule(rule, (rule, tape, token) => {\n                    tokenHandler(rule, tape, token, this);\n                    return null;\n                });\n            }\n            else {\n                this.generatedTokenizer.addRule(rule, () => null);\n            }\n        }\n        else if (directive.startsWith(\"token\") || directive.startsWith(\"define\")) {\n            const isDef = directive.startsWith(\"define\");\n            const tokName = this.tokenizer.expectToken(tape, TokenType.IDENT, TokenType.STRING);\n            let label = tokName.value;\n            if (tokName.tag == TokenType.STRING || tokName.tag == TokenType.NUMBER) {\n                label = `\"${tokName.value}\"`;\n            }\n            const rule = this.parseRegex(tape, label, 0, directive.endsWith(\"flex\") ? \"flex\" : \"\");\n            if (isDef) {\n                this.generatedTokenizer.addVar(label, rule.expr);\n            }\n            else {\n                const tokenHandler = this.parseTokenHandler(tape);\n                this.generatedTokenizer.addRule(rule, tokenHandler);\n                this.ensureSymbol(label, true);\n            }\n        }\n        else {\n            throw new Error(\"Invalid directive: \" + directive);\n        }\n    }\n    parseTokenHandler(tape) {\n        if (!this.tokenizer.consumeIf(tape, TokenType.OPEN_BRACE)) {\n            return null;\n        }\n        const funcName = this.tokenizer.expectToken(tape, TokenType.IDENT);\n        const out = (rule, tape, token, owner) => {\n            const handler = this.tokenHandlers[funcName.value];\n            if (!handler)\n                throw new Error(\"Handler method not found: \" + funcName.value);\n            token = handler(token, tape, owner);\n            return token;\n        };\n        this.tokenizer.expectToken(tape, TokenType.CLOSE_BRACE);\n        return out;\n    }\n    parseDecl(tape) {\n        const ident = this.tokenizer.expectToken(tape, TokenType.IDENT);\n        if (this.tokenizer.consumeIf(tape, TokenType.ARROW, TokenType.COLON)) {\n            const nt = this.ensureSymbol(ident.value, false);\n            if (nt.isTerminal) {\n                nt.isTerminal = false;\n            }\n            else if (nt.isAuxiliary) {\n                throw new Error(\"NT is already auxiliary and cannot be reused.\");\n            }\n            for (const [rhs, action] of this.parseProductions(tape, this.grammar, nt)) {\n                const rule = this.grammar.add(nt, rhs, action);\n            }\n            this.tokenizer.expectToken(tape, TokenType.SEMI_COLON);\n        }\n    }\n    parseProductions(tape, grammar, nt) {\n        const out = [];\n        while (this.tokenizer.peek(tape) != null) {\n            const rule = this.parseProd(tape, grammar);\n            out.push(rule);\n            if (this.tokenizer.consumeIf(tape, TokenType.PIPE)) {\n                continue;\n            }\n            else if (this.tokenizer.nextMatches(tape, TokenType.CLOSE_SQ, TokenType.CLOSE_PAREN, TokenType.SEMI_COLON)) {\n                break;\n            }\n        }\n        return out;\n    }\n    parseProd(tape, grammar) {\n        const out = new Str();\n        while (true) {\n            if (this.tokenizer.nextMatches(tape, TokenType.CLOSE_PAREN, TokenType.CLOSE_SQ, TokenType.SEMI_COLON, TokenType.PIPE, TokenType.OPEN_BRACE)) {\n                break;\n            }\n            let curr = null;\n            if (this.tokenizer.consumeIf(tape, TokenType.OPEN_PAREN)) {\n                const rules = this.parseProductions(tape, grammar, null);\n                if (rules.length == 0) {\n                }\n                else if (rules.length == 1) {\n                    curr = rules[0][0];\n                }\n                else {\n                    curr = grammar.anyof(...rules.map((r) => r[0]));\n                }\n                this.tokenizer.expectToken(tape, TokenType.CLOSE_PAREN);\n            }\n            else if (this.tokenizer.consumeIf(tape, TokenType.OPEN_SQ)) {\n                const rules = this.parseProductions(tape, grammar, null);\n                if (rules.length == 0) {\n                }\n                else if (rules.length == 1) {\n                    curr = grammar.opt(rules[0][0]);\n                }\n                else {\n                    curr = grammar.opt(grammar.anyof(...rules.map((r) => r[0])));\n                }\n                this.tokenizer.expectToken(tape, TokenType.CLOSE_SQ);\n            }\n            else if (this.tokenizer.nextMatches(tape, TokenType.IDENT, TokenType.STRING, TokenType.NUMBER, TokenType.REGEX)) {\n                const token = this.tokenizer.next(tape);\n                let label = token.value;\n                if (token.tag == TokenType.STRING || token.tag == TokenType.NUMBER) {\n                    label = `\"${token.value}\"`;\n                    const pattern = str2regex(token.value);\n                    const rule = TLEX.Builder.build(pattern, { tag: label, priority: 20 });\n                    this.generatedTokenizer.addRule(rule);\n                }\n                else if (token.tag == TokenType.REGEX) {\n                    label = \"/\" + token.value[0] + \"/\" + token.value[1];\n                    let re = token.value[0];\n                    if (token.value[1].length > 0) {\n                        re = new RegExp(token.value[0], token.value[1]);\n                    }\n                    const rule = TLEX.Builder.build(re, { tag: label, priority: 10 });\n                    this.generatedTokenizer.addRule(rule);\n                }\n                else {\n                }\n                const currSym = this.ensureSymbol(label, true);\n                curr = new Str(currSym);\n            }\n            else {\n                throw new TLEX.UnexpectedTokenError(this.tokenizer.peek(tape));\n            }\n            if (curr == null) {\n                throw new Error(\"Could not determine node\");\n            }\n            if (this.tokenizer.consumeIf(tape, TokenType.STAR)) {\n                curr = grammar.atleast0(curr, this.leftRecursive);\n            }\n            else if (this.tokenizer.consumeIf(tape, TokenType.PLUS)) {\n                curr = grammar.atleast1(curr, this.leftRecursive);\n            }\n            else if (this.tokenizer.consumeIf(tape, TokenType.QMARK)) {\n                curr = grammar.opt(curr);\n            }\n            out.extend(curr);\n        }\n        let action = null;\n        if (this.tokenizer.consumeIf(tape, TokenType.OPEN_BRACE)) {\n            const next = this.tokenizer.expectToken(tape, TokenType.DOLLAR_NUM, TokenType.IDENT);\n            action = new RuleAction(next.value);\n            this.tokenizer.expectToken(tape, TokenType.CLOSE_BRACE);\n        }\n        return [out, action];\n    }\n}\n//# sourceMappingURL=dsl.js.map","import * as TSU from \"@panyam/tsutils\";\nimport { Grammar, Str, Sym, Rule } from \"./grammar\";\nimport { LRAction, ParseTable } from \"./lr\";\nimport { LRItem, LR0ItemGraph, LR1ItemGraph } from \"./lritems\";\nexport function makeParseTable(g, type = \"lr1\") {\n    switch (type) {\n        case \"lr1\":\n            return makeLRParseTable(g);\n        case \"lalr\":\n            return makeLALRParseTable(g);\n    }\n    return makeSLRParseTable(g);\n}\nexport function makeSLRParseTable(grammar) {\n    const ig = makeSLRAutomaton(grammar);\n    return [makeParseTableFromLA(ig, grammar), ig];\n}\nexport function makeSLRAutomaton(grammar) {\n    const ig = new LR0ItemGraph(grammar).refresh();\n    for (const itemSet of ig.itemSets.entries) {\n        evalLASetsForSLRItem(grammar, ig, itemSet);\n    }\n    return ig;\n}\nexport function evalLASetsForSLRItem(grammar, ig, itemSet) {\n    for (const itemId of itemSet.values) {\n        const item = ig.items.get(itemId);\n        const rule = item.rule;\n        if (item.position >= rule.rhs.length) {\n            grammar.followSets.forEachTerm(rule.nt, (term) => {\n                if (term != null) {\n                    TSU.assert(term.isTerminal);\n                    itemSet.addLookAhead(item, term);\n                }\n            });\n        }\n    }\n}\nexport function makeLRParseTable(grammar) {\n    const ig = new LR1ItemGraph(grammar).refresh();\n    const parseTable = makeParseTableFromLA(ig, grammar);\n    return [parseTable, ig];\n}\nexport function makeLALRParseTable(grammar) {\n    const [parseTable, ig] = makeSLRParseTable(grammar);\n    if (!parseTable.hasConflicts) {\n        return [parseTable, ig];\n    }\n    const g2 = grammarFromLR0ItemGraph(ig, grammar);\n    const prevSets = {};\n    for (const startState in ig.gotoSets) {\n        for (const symId in ig.gotoSets[startState]) {\n            const nextSet = ig.gotoSets[startState][symId];\n            if (!(nextSet.id in prevSets)) {\n                prevSets[nextSet.id] = {};\n            }\n            if (!(symId in prevSets[nextSet.id])) {\n                prevSets[nextSet.id][symId] = new Set();\n            }\n            prevSets[nextSet.id][symId].add(startState);\n        }\n    }\n    for (const startState in parseTable.conflictActions) {\n        const itemSet = ig.itemSets.get(startState);\n        evalLASetsForLALRItem(grammar, g2, ig, itemSet, prevSets);\n    }\n    return [makeParseTableFromLA(ig, grammar), ig];\n}\nexport function makeParseTableFromLA(ig, grammar) {\n    const parseTable = new ParseTable(grammar);\n    for (const itemSet of ig.itemSets.entries) {\n        for (const itemId of itemSet.values) {\n            const item = ig.items.get(itemId);\n            const rule = item.rule;\n            if (item.position < rule.rhs.length) {\n                const sym = rule.rhs.syms[item.position];\n                if (sym.isTerminal) {\n                    const nextSet = ig.getGoto(itemSet, sym);\n                    if (nextSet) {\n                        parseTable.addAction(itemSet.id, sym, LRAction.Shift(nextSet.id));\n                    }\n                }\n            }\n            else if (!rule.nt.equals(grammar.augStartRule.nt)) {\n                const lookaheads = itemSet.getLookAheads(item);\n                for (const lookahead of lookaheads) {\n                    parseTable.addAction(itemSet.id, lookahead, LRAction.Reduce(rule));\n                }\n            }\n        }\n        ig.forEachGoto(itemSet, (sym, next) => {\n            if (sym != null && !sym.isTerminal) {\n                parseTable.addAction(itemSet.id, sym, LRAction.Goto(next.id));\n            }\n        });\n        const lr1Item = ig.items.ensure(new LRItem(grammar.augStartRule, 1));\n        itemSet.addLookAhead(lr1Item, grammar.Eof);\n        if (itemSet.has(lr1Item.id)) {\n            parseTable.addAction(itemSet.id, grammar.Eof, LRAction.Accept());\n        }\n    }\n    return parseTable;\n}\nexport function evalLASetsForLALRItem(grammar, augGrammar, ig, itemSet, prevSets) {\n    function findP(rule, i, currState, states) {\n        if (i < 0) {\n            const transitions = ig.gotoSets[currState];\n            TSU.assert((transitions[rule.nt.id] || null) != null, \"Transition on rule.nt missing from start state\");\n            states.add(currState);\n        }\n        else {\n            const sym = rule.rhs.syms[i];\n            const prevStates = prevSets[currState][sym.id] || null;\n            TSU.assert(prevStates != null, \"Prev set should not be null\");\n            prevStates.forEach((nextState) => findP(rule, i - 1, nextState, states));\n        }\n    }\n    itemSet.clearLookAheads();\n    for (const itemId of itemSet.values) {\n        const item = ig.items.get(itemId);\n        const rule = item.rule;\n        if (item.position >= rule.rhs.length) {\n            const pSet = new Set();\n            findP(rule, rule.rhs.length - 1, itemSet.id, pSet);\n            pSet.forEach((p) => {\n                const pALabel = `[${p}:${rule.nt.label}]`;\n                const pA = augGrammar.getSym(pALabel);\n                TSU.assert(pA != null, \"Augmented grammar symbol [p:A] not found\");\n                augGrammar.followSets.forEachTerm(pA, (term) => {\n                    if (term != null && term != augGrammar.Eof) {\n                        TSU.assert(term.isTerminal);\n                        const label = term.label.substring(term.label.indexOf(\":\") + 1, term.label.length - 1).trim();\n                        const T = grammar.getSym(label);\n                        TSU.assert(T != null, `T (${label}) in [r:T] cannot be null`);\n                        itemSet.addLookAhead(item, T);\n                    }\n                });\n            });\n        }\n    }\n}\nexport function grammarFromLR0ItemGraph(ig, g) {\n    const g2 = new Grammar();\n    function ensureG2Sym(pi, sym) {\n        const newSymLabel = `[${pi}:${sym.label}]`;\n        const newSym = g2.ensureSym(new Sym(g2, newSymLabel, sym.isTerminal), false);\n        if (pi == 0 && g.startSymbol == sym && g.startSymbol != newSym && !sym.isTerminal) {\n            g2.startSymbol = newSym;\n        }\n        return newSym;\n    }\n    for (const startState in ig.gotoSets) {\n        const transitions = ig.gotoSets[startState];\n        for (const symId in transitions) {\n            const sym = g.getSymById(symId);\n            ensureG2Sym(startState, sym);\n        }\n    }\n    function buildRuleFrom(startSet, A, rule) {\n        let pi = startSet;\n        const newSyms = rule.rhs.syms.map((xi, index) => {\n            const nextSym = ensureG2Sym(pi, xi);\n            const transitions = ig.gotoSets[pi];\n            const nextSet = transitions[xi.id] || null;\n            TSU.assert(nextSet != null, \"Next set transition *must* be valid\");\n            pi = nextSet.id;\n            return nextSym;\n        });\n        return new Str(...newSyms);\n    }\n    for (const startState in ig.gotoSets) {\n        const transitions = ig.gotoSets[startState];\n        for (const symId in transitions) {\n            const startSym = g.getSymById(symId);\n            const p1 = startState;\n            if (!startSym.isTerminal) {\n                const newA = ensureG2Sym(p1, startSym);\n                g.forEachRule(startSym, (rule, index) => {\n                    const newRHS = buildRuleFrom(p1, startSym, rule);\n                    const newRule = new Rule(newA, newRHS);\n                    g2.addRule(newRule);\n                });\n            }\n        }\n    }\n    return g2;\n}\n//# sourceMappingURL=ptables.js.map","import * as TSU from \"@panyam/tsutils\";\nimport { PTNode, SimpleParser as ParserBase, } from \"./parser\";\nimport { ParseError } from \"./errors\";\nexport var LRActionType;\n(function (LRActionType) {\n    LRActionType[LRActionType[\"ACCEPT\"] = 0] = \"ACCEPT\";\n    LRActionType[LRActionType[\"SHIFT\"] = 1] = \"SHIFT\";\n    LRActionType[LRActionType[\"REDUCE\"] = 2] = \"REDUCE\";\n    LRActionType[LRActionType[\"GOTO\"] = 3] = \"GOTO\";\n})(LRActionType || (LRActionType = {}));\nexport class LRAction {\n    constructor() {\n        this.gotoState = null;\n        this.rule = null;\n    }\n    toString() {\n        if (this.tag == LRActionType.ACCEPT)\n            return \"Acc\";\n        else if (this.tag == LRActionType.SHIFT) {\n            return \"S\" + this.gotoState;\n        }\n        else if (this.tag == LRActionType.REDUCE) {\n            return \"R \" + this.rule.id;\n        }\n        else {\n            return \"\" + this.gotoState;\n        }\n    }\n    equals(another) {\n        return this.tag == another.tag && this.gotoState == another.gotoState && this.rule == another.rule;\n    }\n    static Shift(goto) {\n        const out = new LRAction();\n        out.tag = LRActionType.SHIFT;\n        out.gotoState = goto;\n        return out;\n    }\n    static Reduce(rule) {\n        const out = new LRAction();\n        out.tag = LRActionType.REDUCE;\n        out.rule = rule;\n        return out;\n    }\n    static Goto(gotoState) {\n        const out = new LRAction();\n        out.tag = LRActionType.GOTO;\n        out.gotoState = gotoState;\n        return out;\n    }\n    static Accept() {\n        const out = new LRAction();\n        out.tag = LRActionType.ACCEPT;\n        return out;\n    }\n}\nexport class ParseTable {\n    constructor(grammar) {\n        this.grammar = grammar;\n        this.conflictActions = {};\n        this.actions = {};\n    }\n    get hasConflicts() {\n        return Object.keys(this.conflictActions).length > 0;\n    }\n    getActions(stateId, next, ensure = false) {\n        let l1;\n        if (stateId in this.actions) {\n            l1 = this.actions[stateId];\n        }\n        else if (ensure) {\n            l1 = this.actions[stateId] = {};\n        }\n        else {\n            return [];\n        }\n        if (next.id in l1) {\n            return l1[next.id];\n        }\n        else if (ensure) {\n            return (l1[next.id] = []);\n        }\n        return [];\n    }\n    addAction(stateId, next, action) {\n        const actions = this.getActions(stateId, next, true);\n        if (actions.findIndex((ac) => ac.equals(action)) < 0) {\n            actions.push(action);\n        }\n        if (actions.length > 1) {\n            this.conflictActions[stateId] = this.conflictActions[stateId] || {};\n            this.conflictActions[stateId][next.label] = true;\n        }\n        return this;\n    }\n    get debugValue() {\n        const out = {};\n        for (const fromId in this.actions) {\n            out[fromId] = {};\n            for (const symId in this.actions[fromId]) {\n                const sym = this.grammar.getSymById(symId);\n                const actions = this.actions[fromId][sym.id] || [];\n                if (actions.length > 0) {\n                    out[fromId][sym.label] = actions.map((a) => a.toString());\n                }\n            }\n        }\n        return out;\n    }\n}\nexport class ParseStack {\n    constructor() {\n        this.stateStack = [];\n        this.nodeStack = [];\n    }\n    push(state, node) {\n        this.stateStack.push(state);\n        this.nodeStack.push(node);\n    }\n    top(nth = 0) {\n        return [this.stateStack[this.stateStack.length - 1 - nth], this.nodeStack[this.nodeStack.length - 1 - nth]];\n    }\n    pop() {\n        const out = this.top();\n        this.stateStack.pop();\n        this.nodeStack.pop();\n        return out;\n    }\n    popN(n = 1) {\n        const L = this.stateStack.length;\n        this.stateStack.splice(L - n, n);\n        this.nodeStack.splice(L - n, n);\n    }\n    get isEmpty() {\n        return this.stateStack.length == 0 || this.nodeStack.length == 0;\n    }\n}\nexport class Parser extends ParserBase {\n    constructor(parseTable, config = {}) {\n        super();\n        this.parseTable = parseTable;\n    }\n    get grammar() {\n        return this.parseTable.grammar;\n    }\n    parseInput(input, context) {\n        context = context || {};\n        this.tokenbuffer.tokenizerContext = context.tokenizerContext;\n        if (context.buildParseTree != false)\n            context.buildParseTree = true;\n        if (context.copySingleChild != false)\n            context.copySingleChild = true;\n        let idCounter = 0;\n        const stack = new ParseStack();\n        stack.push(0, new PTNode(idCounter++, this.grammar.augStartRule.nt, null));\n        const tokenbuffer = this.tokenbuffer;\n        const g = this.grammar;\n        let output = null;\n        function resolveActions(actions) {\n            if (context?.actionResolver) {\n                return context.actionResolver(actions, stack, tokenbuffer);\n            }\n            else {\n                if (actions.length > 1) {\n                    throw new Error(\"Multiple actions found.\");\n                }\n                return actions[0];\n            }\n        }\n        function nextToken() {\n            try {\n                return tokenbuffer.peek(input);\n            }\n            catch (err) {\n                if (!context?.onTokenError || !context?.onTokenError(err, input)) {\n                    throw err;\n                }\n                return nextToken();\n            }\n        }\n        while (true) {\n            let token = nextToken();\n            if (token == null) {\n                if (stack.isEmpty) {\n                    break;\n                }\n            }\n            else if (context.onNextToken) {\n                token = context.onNextToken(token);\n            }\n            const nextSym = token == null ? g.Eof : this.getSym(token);\n            const nextValue = token == null ? null : token.value;\n            let [topState, topNode] = stack.top();\n            const actions = this.parseTable.getActions(topState, nextSym);\n            if (actions == null || actions.length == 0) {\n                throw new ParseError(`Unexpected Token: '${nextSym.label}'`, \"UnexpectedToken\", {\n                    state: topState,\n                    token: token,\n                    nextSym: nextSym,\n                });\n            }\n            const action = resolveActions(actions);\n            if (action.tag == LRActionType.ACCEPT) {\n                break;\n            }\n            else if (action.tag == LRActionType.SHIFT) {\n                tokenbuffer.next(input);\n                const newNode = new PTNode(idCounter++, nextSym, nextValue);\n                stack.push(action.gotoState, newNode);\n            }\n            else {\n                TSU.assert(action.rule != null, \"Nonterm and ruleindex must be provided for a reduction action\");\n                const ruleLen = action.rule.rhs.length;\n                let newNode = new PTNode(idCounter++, action.rule.nt, null);\n                if (context.buildParseTree) {\n                    for (let i = ruleLen - 1; i >= 0; i--) {\n                        const childNode = stack.top(i)[1];\n                        if (context.beforeAddingChildNode) {\n                            for (const node of context.beforeAddingChildNode(newNode, childNode)) {\n                                newNode.add(node);\n                            }\n                        }\n                        else if (childNode != null) {\n                            newNode.add(childNode);\n                        }\n                    }\n                }\n                if (action.rule.action) {\n                    if (action.rule.action.isFunction) {\n                        const handlerName = action.rule.action.value;\n                        const handler = context.ruleHandlers[handlerName];\n                        if (!handler)\n                            throw new Error(\"Action handler not found: \" + handlerName);\n                        newNode.value = handler(action.rule, newNode, ...newNode.children);\n                    }\n                    else {\n                        newNode.value = newNode.children[action.rule.action.value - 1].value;\n                    }\n                }\n                else if (context.onReduction) {\n                    newNode = context.onReduction(newNode, action.rule);\n                }\n                else if (newNode.children.length == 1 && context.copySingleChild) {\n                    newNode.value = newNode.children[0].value;\n                }\n                stack.popN(ruleLen);\n                [topState, topNode] = stack.top();\n                const newAction = resolveActions(this.parseTable.getActions(topState, action.rule.nt));\n                TSU.assert(newAction != null && newAction.gotoState != null, \"Top item does not have an action.\");\n                stack.push(newAction.gotoState, newNode);\n                output = newNode;\n            }\n        }\n        return output;\n    }\n}\n//# sourceMappingURL=lr.js.map","import * as TSU from \"@panyam/tsutils\";\nconst defaultKeyFunc = (x) => x.key;\nexport class Trie {\n    constructor(keyFunc) {\n        this.root = new TrieNode();\n        this.keyFunc = keyFunc;\n    }\n    add(values, fromIndex = 0) {\n        let curr = this.root;\n        for (let i = fromIndex; i < values.length; i++) {\n            const key = this.keyFunc(values[i]);\n            if (curr.children.has(key)) {\n                curr = curr.children.get(key);\n            }\n            else {\n                const newNode = new TrieNode();\n                newNode.value = values[i];\n                newNode.parent = curr;\n                curr.children.set(key, newNode);\n                curr = newNode;\n            }\n        }\n        curr.isLeaf = true;\n        return curr;\n    }\n    get debugValue() {\n        return this.root.debugValue;\n    }\n}\nexport class TrieNode {\n    constructor() {\n        this.isLeaf = false;\n        this.value = null;\n        this.parent = null;\n        this.children = new Map();\n    }\n    get debugValue() {\n        const out = { value: this.value, children: {} };\n        if (this.isLeaf)\n            out[\"isLeaf\"] = true;\n        for (const [key, value] of this.children.entries()) {\n            out.children[key] = value.debugValue;\n        }\n        return out;\n    }\n}\nexport class IDSet {\n    constructor(keyFunc = defaultKeyFunc) {\n        this._entries = [];\n        this._entriesByKey = {};\n        this.keyFunc = keyFunc;\n    }\n    clear() {\n        this._entries = [];\n        this._entriesByKey = {};\n    }\n    remove(predicate) {\n        const e2 = [];\n        this._entriesByKey = {};\n        let modified = false;\n        for (let l = 0; l < this._entries.length; l++) {\n            const e = this._entries[l];\n            if (!predicate(e)) {\n                e.id = e2.length;\n                e2.push(e);\n                this._entriesByKey[this.keyFunc(e)] = e;\n            }\n            else {\n                modified = true;\n            }\n        }\n        this._entries = e2;\n        return modified;\n    }\n    get entries() {\n        return this._entries;\n    }\n    get(id) {\n        TSU.assert(id >= 0 && id < this._entries.length);\n        return this._entries[id];\n    }\n    getByKey(key) {\n        return this._entriesByKey[key] || null;\n    }\n    ensure(entry, throwIfExists = false) {\n        if (this.has(entry)) {\n            if (throwIfExists)\n                throw new Error(`Entry ${this.keyFunc(entry)} already exists`);\n            return this._entriesByKey[this.keyFunc(entry)];\n        }\n        else {\n            this._entriesByKey[this.keyFunc(entry)] = entry;\n            entry.id = this._entries.length;\n            this._entries.push(entry);\n            return entry;\n        }\n    }\n    has(entry) {\n        return this.keyFunc(entry) in this._entriesByKey;\n    }\n    get size() {\n        return this._entries.length;\n    }\n}\nexport class SymbolSet {\n    constructor(grammar, enforceSymbolType = true) {\n        this.entries = new Set();\n        this.hasNull = false;\n        this.grammar = grammar;\n        this.enforceSymbolType = enforceSymbolType;\n    }\n    get debugString() {\n        return \"<\" + this.labels().sort().join(\", \") + \">\";\n    }\n    labels(skipAux = false) {\n        const out = [];\n        for (const i of this.entries) {\n            const exp = this.grammar.getSymById(i);\n            TSU.assert(exp != null);\n            if (!skipAux || !exp.isAuxiliary)\n                out.push(exp.label);\n        }\n        if (this.hasNull)\n            out.push(\"\");\n        return out;\n    }\n    addFrom(another, includeNull = true) {\n        return another.addTo(this, includeNull);\n    }\n    addTo(another, includeNull = true) {\n        const before = another.entries.size;\n        for (const termid of this.entries) {\n            another.entries.add(termid);\n        }\n        if (includeNull) {\n            another.hasNull = this.hasNull || another.hasNull;\n        }\n        return another.entries.size - before;\n    }\n    has(term) {\n        return this.entries.has(term.id);\n    }\n    add(term) {\n        TSU.assert(this.enforceSymbolType == null || this.enforceSymbolType == term.isTerminal, `Terminal types being enforced: ${this.enforceSymbolType}`);\n        this.entries.add(term.id);\n        return this;\n    }\n    delete(term) {\n        return this.entries.delete(term.id);\n    }\n    get size() {\n        return this.entries.size + (this.hasNull ? 1 : 0);\n    }\n}\nexport class NullableSet {\n    constructor(grammar) {\n        this.grammar = grammar;\n        this.refresh();\n    }\n    get nonterms() {\n        const out = [];\n        this.entries.forEach((id) => {\n            const e = this.grammar.getSymById(id);\n            TSU.assert(e != null && !e.isTerminal);\n            out.push(e);\n        });\n        return out;\n    }\n    refresh() {\n        this.entries = new Set();\n        this.visited = {};\n        let beforeCount = 0;\n        do {\n            beforeCount = this.entries.size;\n            this.grammar.allNonTerminals.forEach((nt) => this.visit(nt));\n        } while (beforeCount != this.entries.size);\n    }\n    visit(nt) {\n        for (const rule of this.grammar.rulesForNT(nt)) {\n            if (this.isStrNullable(rule.rhs)) {\n                this.add(nt);\n                break;\n            }\n        }\n    }\n    isNullable(nt) {\n        return !nt.isTerminal && this.entries.has(nt.id);\n    }\n    isStrNullable(str, fromIndex = 0, toIndex = null) {\n        if (toIndex == null) {\n            toIndex = str.length - 1;\n        }\n        for (let i = fromIndex; i <= toIndex; i++) {\n            if (!this.isNullable(str.syms[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    add(nt) {\n        TSU.assert(!nt.isTerminal);\n        this.entries.add(nt.id);\n    }\n}\nclass SymSymbolSets {\n    constructor(grammar) {\n        this.entries = {};\n        this._count = 0;\n        this.grammar = grammar;\n    }\n    refresh() {\n        this.entries = {};\n        this._count = 0;\n    }\n    forEachTerm(nt, visitor) {\n        const entries = this.entriesFor(nt);\n        entries.entries.forEach((x) => {\n            const term = this.grammar.getSymById(x);\n            TSU.assert(term != null && term.isTerminal);\n            visitor(term);\n        });\n        if (entries.hasNull)\n            visitor(null);\n    }\n    get debugValue() {\n        const out = {};\n        for (const x in this.entries)\n            out[this.grammar.getSymById(x).label] = this.entries[x].debugString;\n        return out;\n    }\n    get count() {\n        let c = 0;\n        for (const x in this.entries)\n            c += this.entries[x].size;\n        return c;\n    }\n    entriesFor(sym) {\n        if (sym.id in this.entries) {\n            return this.entries[sym.id];\n        }\n        else {\n            const out = new SymbolSet(this.grammar);\n            this.entries[sym.id] = out;\n            return out;\n        }\n    }\n    addNull(nt) {\n        const entries = this.entriesFor(nt);\n        if (entries.hasNull)\n            return false;\n        entries.hasNull = true;\n        return true;\n    }\n    add(nt, source, includeNull = true) {\n        if (nt.isTerminal) {\n            TSU.assert(false, \"Should not be here\");\n        }\n        const entries = this.entriesFor(nt);\n        if (source.isTerminal) {\n            if (entries.has(source))\n                return false;\n            entries.add(source);\n            this._count++;\n        }\n        else {\n            const srcEntries = this.entriesFor(source);\n            const destEntries = this.entriesFor(nt);\n            const count = srcEntries.addTo(destEntries, includeNull);\n            this._count += count;\n        }\n        return true;\n    }\n}\nexport class FirstSets extends SymSymbolSets {\n    constructor(grammar, nullables) {\n        super(grammar);\n        if (!nullables) {\n            nullables = new NullableSet(grammar);\n        }\n        this.nullables = nullables;\n        this.refresh();\n    }\n    forEachTermIn(str, fromIndex = 0, visitor) {\n        const syms = str.syms;\n        const visited = {};\n        let allNullable = true;\n        for (let j = fromIndex; allNullable && j < syms.length; j++) {\n            const symj = syms[j];\n            if (symj.isTerminal) {\n                visitor(symj);\n                allNullable = false;\n            }\n            else {\n                const nt = symj;\n                this.forEachTerm(nt, (term) => {\n                    if (term != null && !(term.id in visited)) {\n                        visited[term.id] = true;\n                        visitor(term);\n                    }\n                });\n                if (!this.nullables.isNullable(symj)) {\n                    allNullable = false;\n                }\n            }\n        }\n        if (allNullable)\n            visitor(null);\n    }\n    refresh() {\n        super.refresh();\n        let beforeCount = 0;\n        do {\n            beforeCount = this.count;\n            this.grammar.forEachRule(null, (rule) => {\n                this.processRule(rule);\n            });\n        } while (beforeCount != this.count);\n    }\n    processRule(rule) {\n        const nullables = this.nullables;\n        let allNullable = true;\n        for (const s of rule.rhs.syms) {\n            this.add(rule.nt, s, false);\n            if (s.isTerminal || !nullables.isNullable(s)) {\n                allNullable = false;\n                break;\n            }\n        }\n        if (allNullable)\n            this.addNull(rule.nt);\n    }\n}\nexport class FollowSets extends SymSymbolSets {\n    constructor(grammar, firstSets) {\n        super(grammar);\n        this.firstSets = firstSets || new FirstSets(grammar);\n        this.refresh();\n    }\n    get nullables() {\n        return this.firstSets.nullables;\n    }\n    refresh() {\n        super.refresh();\n        const g = this.grammar;\n        TSU.assert(g.startSymbol != null, \"Select start symbol of the grammar\");\n        this.add(g.startSymbol, g.Eof);\n        let beforeCount = 0;\n        do {\n            beforeCount = this.count;\n            this.grammar.forEachRule(null, (rule) => this.processRule(rule));\n        } while (beforeCount != this.count);\n    }\n    processRule(rule) {\n        const syms = rule.rhs.syms;\n        const firstSets = this.firstSets;\n        const nullables = this.firstSets.nullables;\n        for (let i = 0; i < syms.length; i++) {\n            const sym = syms[i];\n            if (sym.isTerminal)\n                continue;\n            firstSets.forEachTermIn(rule.rhs, i + 1, (term) => {\n                if (term != null)\n                    this.add(sym, term);\n            });\n        }\n        for (let i = syms.length - 1; i >= 0; i--) {\n            if (syms[i].isTerminal)\n                continue;\n            let allNullable = true;\n            for (let j = i + 1; j < syms.length; j++) {\n                const symj = syms[j];\n                if (symj.isTerminal || !nullables.isNullable(symj)) {\n                    allNullable = false;\n                    break;\n                }\n            }\n            if (allNullable) {\n                this.add(syms[i], rule.nt);\n            }\n        }\n    }\n}\n//# sourceMappingURL=sets.js.map","import * as TSU from \"@panyam/tsutils\";\nexport function allMinimalCycles(nodes, idFunc, edges) {\n    const cycles = [];\n    const inACycle = {};\n    nodes.forEach((node) => {\n        if (!(idFunc(node) in inACycle)) {\n            const startNode = node;\n            const visited = {};\n            let queue = [[node, []]];\n            while (queue.length > 0) {\n                const newQueue = [];\n                for (let i = 0; i < queue.length; i++) {\n                    const [node, c] = queue[i];\n                    TSU.assert(node != null);\n                    const e = edges(node);\n                    let cycle = [...c];\n                    for (const [nextNode, edgeData] of e) {\n                        if (nextNode == startNode) {\n                            cycle.push([edgeData, nextNode]);\n                            cycle.forEach(([e, n], i) => (inACycle[n] = true));\n                            cycles.push([startNode, cycle]);\n                            cycle = cycle.slice(0, cycle.length - 1);\n                        }\n                        else if (!(idFunc(nextNode) in visited)) {\n                            visited[idFunc(nextNode)] = true;\n                            newQueue.push([nextNode, [...cycle, [edgeData, nextNode]]]);\n                        }\n                    }\n                }\n                queue = newQueue;\n            }\n        }\n    });\n    return cycles;\n}\nexport function digraph() {\n}\n//# sourceMappingURL=graph.js.map","import { load as loadGrammar } from \"./dsl\";\nimport { makeParseTable } from \"./ptables\";\nimport { Parser } from \"./lr\";\nimport { logParserDebug } from \"./debug\";\nexport function newLRParser(input, params = null) {\n    const options = params || {};\n    const [ptable, tokenFunc, itemGraph] = newParseTable(input, options);\n    const parser = new Parser(ptable);\n    if (options.tokenizer || tokenFunc) {\n        parser.setTokenizer(options.tokenizer || tokenFunc);\n    }\n    const debug = options.debug || \"\";\n    if (debug.split(\"|\").findIndex((p) => p == \"all\" || p == \"parser\") >= 0) {\n        logParserDebug(parser, itemGraph);\n    }\n    return [parser, tokenFunc, itemGraph];\n}\nexport function newParseTable(input, params = null) {\n    const options = params || {};\n    const [g, tokenFunc] = loadGrammar(input, options);\n    g.augmentStartSymbol();\n    const [ptable, itemGraph] = makeParseTable(g, options.type);\n    return [ptable, tokenFunc, itemGraph];\n}\n//# sourceMappingURL=factory.js.map","// src/docs/CodeBlock.ts\nvar CodeBlock = class {\n  constructor(preElement) {\n    this.codeElement = preElement.querySelector(\"code\") || preElement;\n    this.container = document.createElement(\"div\");\n    this.container.className = \"code-block\";\n    preElement.parentNode?.insertBefore(this.container, preElement);\n    this.container.appendChild(preElement);\n    this.copyButton = document.createElement(\"button\");\n    this.copyButton.className = \"code-block-copy\";\n    this.copyButton.setAttribute(\"aria-label\", \"Copy code\");\n    this.copyButton.innerHTML = this.getCopyIcon();\n    this.copyButton.addEventListener(\"click\", () => this.copyCode());\n    this.container.appendChild(this.copyButton);\n  }\n  getCopyIcon() {\n    return `<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n      <rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect>\n      <path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path>\n    </svg>`;\n  }\n  getCheckIcon() {\n    return `<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n      <polyline points=\"20 6 9 17 4 12\"></polyline>\n    </svg>`;\n  }\n  async copyCode() {\n    const text = this.codeElement.textContent || \"\";\n    try {\n      await navigator.clipboard.writeText(text);\n      this.showSuccess();\n    } catch (err) {\n      this.fallbackCopy(text);\n    }\n  }\n  fallbackCopy(text) {\n    const textarea = document.createElement(\"textarea\");\n    textarea.value = text;\n    textarea.style.position = \"fixed\";\n    textarea.style.opacity = \"0\";\n    document.body.appendChild(textarea);\n    textarea.select();\n    try {\n      document.execCommand(\"copy\");\n      this.showSuccess();\n    } catch (err) {\n      console.error(\"Failed to copy:\", err);\n    }\n    document.body.removeChild(textarea);\n  }\n  showSuccess() {\n    this.copyButton.innerHTML = this.getCheckIcon();\n    this.copyButton.classList.add(\"copied\");\n    setTimeout(() => {\n      this.copyButton.innerHTML = this.getCopyIcon();\n      this.copyButton.classList.remove(\"copied\");\n    }, 2e3);\n  }\n};\nfunction initCodeBlocks(selector = \".content-body pre\") {\n  const preElements = document.querySelectorAll(selector);\n  preElements.forEach((pre) => {\n    if (pre.parentElement?.classList.contains(\"code-block\")) {\n      return;\n    }\n    if (pre.querySelector(\"pre\")) {\n      return;\n    }\n    new CodeBlock(pre);\n  });\n}\n\n// src/docs/pageSetup.ts\nfunction highlightActiveSidebarLink(sidebarSelector = \".sidebar .section-nav a\") {\n  const currentPath = window.location.pathname;\n  const sidebarLinks = document.querySelectorAll(sidebarSelector);\n  sidebarLinks.forEach((link) => {\n    const href = link.getAttribute(\"href\");\n    if (href && currentPath.endsWith(href.replace(/\\/$/, \"\") + \"/\")) {\n      link.classList.add(\"active\");\n    } else if (href && currentPath === href) {\n      link.classList.add(\"active\");\n    }\n  });\n}\nfunction initPageSetup(options = {}) {\n  highlightActiveSidebarLink(options.sidebarSelector);\n}\n\n// src/docs/ActionCompiler.ts\nvar ActionCompiler = class {\n  constructor(editor, statusEl = null, onCompile = null) {\n    this.editor = null;\n    this.compiledFn = null;\n    this.compileError = null;\n    this.statusEl = null;\n    this.onCompile = null;\n    this.editor = editor;\n    this.statusEl = statusEl;\n    this.onCompile = onCompile;\n    let compileTimeout = null;\n    this.editor.session.on(\"change\", () => {\n      if (compileTimeout) clearTimeout(compileTimeout);\n      compileTimeout = window.setTimeout(() => this.compile(), 300);\n    });\n  }\n  /**\n   * Compile the current editor content\n   */\n  compile() {\n    if (!this.editor) {\n      return { success: false, fn: null, error: \"No editor\", line: null };\n    }\n    const code = this.editor.getValue().trim();\n    const session = this.editor.session;\n    session.clearAnnotations();\n    this.compiledFn = null;\n    this.compileError = null;\n    if (!code) {\n      this.updateStatus(\"\", \"\");\n      const result = { success: true, fn: null, error: null, line: null };\n      this.onCompile?.(result);\n      return result;\n    }\n    try {\n      this.compiledFn = new Function(\"node\", code);\n      this.updateStatus(\"\\u2713\", \"success\");\n      const result = { success: true, fn: this.compiledFn, error: null, line: null };\n      this.onCompile?.(result);\n      return result;\n    } catch (e) {\n      this.compileError = e.message;\n      this.updateStatus(\"\\u2717 Compile Error\", \"error\");\n      const lineMatch = e.message.match(/(?:at line |line |:|\\()(\\d+)(?::|,|\\))/i);\n      const line = lineMatch ? parseInt(lineMatch[1], 10) - 1 : 0;\n      session.setAnnotations([\n        {\n          row: line,\n          column: 0,\n          text: e.message,\n          type: \"error\"\n        }\n      ]);\n      const result = { success: false, fn: null, error: e.message, line };\n      this.onCompile?.(result);\n      return result;\n    }\n  }\n  /**\n   * Run the compiled action on a parse tree node\n   */\n  run(node) {\n    if (!node) {\n      return { success: false, result: null, error: \"No parse result available\", line: null };\n    }\n    if (this.compileError) {\n      return { success: false, result: null, error: `Compile Error: ${this.compileError}`, line: null };\n    }\n    if (!this.compiledFn) {\n      return { success: true, result: null, error: null, line: null };\n    }\n    try {\n      const result = this.compiledFn(node);\n      if (this.editor) {\n        this.editor.session.clearAnnotations();\n      }\n      this.updateStatus(\"\\u2713\", \"success\");\n      return { success: true, result, error: null, line: null };\n    } catch (e) {\n      const stack = e.stack || \"\";\n      const lineMatch = stack.match(/<anonymous>:(\\d+):/);\n      const line = lineMatch ? parseInt(lineMatch[1], 10) - 1 : null;\n      if (this.editor && line !== null) {\n        this.editor.session.setAnnotations([\n          {\n            row: line,\n            column: 0,\n            text: e.message,\n            type: \"error\"\n          }\n        ]);\n      }\n      this.updateStatus(\"\\u2717 Runtime Error\", \"error\");\n      return { success: false, result: null, error: e.message, line };\n    }\n  }\n  /**\n   * Get the current compile error (if any)\n   */\n  getCompileError() {\n    return this.compileError;\n  }\n  /**\n   * Check if there's a compiled action function\n   */\n  hasCompiledAction() {\n    return this.compiledFn !== null;\n  }\n  /**\n   * Update status element\n   */\n  updateStatus(text, statusClass) {\n    if (this.statusEl) {\n      this.statusEl.textContent = text;\n      this.statusEl.classList.remove(\"success\", \"error\");\n      if (statusClass) {\n        this.statusEl.classList.add(statusClass);\n      }\n    }\n  }\n  /**\n   * Clear annotations and status\n   */\n  clear() {\n    if (this.editor) {\n      this.editor.session.clearAnnotations();\n    }\n    this.compiledFn = null;\n    this.compileError = null;\n    this.updateStatus(\"\", \"\");\n  }\n};\n\nexport { ActionCompiler, CodeBlock, highlightActiveSidebarLink, initCodeBlocks, initPageSetup };\n//# sourceMappingURL=index.mjs.map\n//# sourceMappingURL=index.mjs.map","import { Rule, Regex } from \"./core\";\nimport { RegexParser as JSREParser } from \"./jsparser\";\nimport { RegexParser as FlexREParser } from \"./flexparser\";\nimport { Tape } from \"./tape\";\nexport function build(pattern, config) {\n    if (typeof pattern === \"string\") {\n        const rule = new Rule(exprFromJSRE(pattern, config), config);\n        rule.pattern = pattern;\n        return rule;\n    }\n    else if (pattern.constructor.name == \"RegExp\") {\n        const rule = new Rule(exprFromJSRE(pattern, config), config);\n        rule.pattern = pattern.source;\n        return rule;\n    }\n    else {\n        return new Rule(pattern, config);\n    }\n}\nexport function flatten(re, index = 0, rules) {\n    rules = rules || [];\n    if (typeof re === \"string\") {\n        rules.push(build(re, { tag: index }));\n    }\n    else if (re.constructor == RegExp) {\n        rules.push(build(re, { tag: index }));\n    }\n    else if (re.constructor == Rule) {\n        rules.push(re);\n    }\n    else if (re.constructor == Regex) {\n        rules.push(new Rule(re));\n    }\n    else {\n        const res = re;\n        for (let i = 0; i < res.length; i++) {\n            flatten(res[i], i, rules);\n        }\n    }\n    return rules;\n}\nexport function exprFromFlexRE(pattern) {\n    const parser = new FlexREParser();\n    try {\n        const expr = parser.parse(new Tape(pattern));\n        if (expr.dotAll == null)\n            expr.dotAll = false;\n        if (expr.multiline == null)\n            expr.multiline = false;\n        return expr;\n    }\n    catch (error) {\n        console.log(\"Error in FLEX RE: \", pattern);\n        throw error;\n    }\n}\nexport function exprFromJSRE(re, config) {\n    config = config || {};\n    const isRegExp = typeof re !== \"string\";\n    const pattern = typeof re === \"string\" ? re : re.source;\n    if (isRegExp)\n        config.unicode = re.unicode;\n    const expr = new JSREParser(pattern, config).parse();\n    if (typeof re !== \"string\") {\n        expr.dotAll = re.dotAll;\n        expr.ignoreCase = re.ignoreCase;\n        expr.multiline = re.multiline;\n    }\n    return expr;\n}\nexport function jsRE(strings, ...keys) {\n    const merged = String.raw(strings, ...keys);\n    return exprFromJSRE(merged);\n}\nexport function flexRE(strings, ...keys) {\n    const merged = String.raw(strings, ...keys);\n    return exprFromFlexRE(merged);\n}\n//# sourceMappingURL=builder.js.map","import { Union } from \"./core\";\nimport { VM } from \"./vm\";\nimport { Compiler } from \"./compiler\";\nimport { Tape as DefaultTape } from \"./tape\";\nimport { TokenizerError } from \"./errors\";\nimport * as Builder from \"./builder\";\nimport { Token } from \"./token\";\nexport function toToken(tag, m, tape) {\n    const out = new Token(tag, m.matchIndex, m.start, m.end);\n    for (let i = 0; i < m.positions.length; i += 2) {\n        if (m.positions[i] >= 0) {\n            out.positions[Math.floor(i / 2)] = [m.positions[i], m.positions[i + 1]];\n        }\n    }\n    for (const [groupIndex, tapeIndex] of m.groups) {\n        const gi = Math.abs(groupIndex);\n        if (!(gi in out.groups)) {\n            out.groups[gi] = [];\n        }\n        out.groups[gi].push(tapeIndex);\n    }\n    if (tape != null)\n        out.value = tape.substring(m.start, m.end);\n    return out;\n}\nexport class BaseTokenizer {\n    constructor() {\n        this._prog = null;\n        this._vm = null;\n        this.onError = null;\n        this.allRules = [];\n        this.onMatchHandlers = [];\n        this.matchHandlersByValue = {};\n        this.variables = new Map();\n        this.compiler = new Compiler((name) => {\n            let out = this.variables.get(name) || null;\n            if (out == null)\n                out = this.findRuleByValue(name)?.expr || null;\n            if (out == null)\n                throw new Error(`Invalid regex reference: ${name}`);\n            return out;\n        });\n    }\n    getVar(name) {\n        return this.variables.get(name) || null;\n    }\n    addVar(name, regex) {\n        let currValue = this.variables.get(name) || null;\n        if (currValue == null) {\n            currValue = regex;\n        }\n        else {\n            currValue = new Union(currValue, regex);\n        }\n        this.variables.set(name, regex);\n        return this;\n    }\n    findRuleByValue(value) {\n        return this.allRules.find((r) => r.tag == value) || null;\n    }\n    add(pattern, config, onMatch = null) {\n        if (typeof config === \"function\") {\n            onMatch = config;\n            config = null;\n        }\n        return this.addRule(Builder.build(pattern, config), onMatch);\n    }\n    addRule(rule, onMatch = null) {\n        rule.matchIndex = this.allRules.length;\n        this.allRules.push(rule);\n        this.onMatchHandlers.push(onMatch);\n        this._prog = null;\n        this._vm = null;\n        return this;\n    }\n    on(tag, onMatch) {\n        this.matchHandlersByValue[tag] = onMatch;\n        return this;\n    }\n    get prog() {\n        if (this._prog == null) {\n            const sortedRules = this.sortRules();\n            this._prog = this.compiler.compile(sortedRules);\n        }\n        return this._prog;\n    }\n    get vm() {\n        if (this._vm == null) {\n            this._vm = new VM(this.prog);\n        }\n        return this._vm;\n    }\n    sortRules() {\n        const sortedRules = this.allRules.map((rule) => rule);\n        sortedRules.sort((r1, r2) => {\n            if (r1.priority != r2.priority)\n                return r2.priority - r1.priority;\n            return r1.matchIndex - r2.matchIndex;\n        });\n        return sortedRules;\n    }\n}\nexport class Tokenizer extends BaseTokenizer {\n    constructor() {\n        super(...arguments);\n        this.idCounter = 0;\n    }\n    getState() {\n        return this.vm.getState();\n    }\n    setState(state) {\n        this.vm.setState(state);\n    }\n    reset() {\n        this.idCounter = 0;\n        if (this._vm) {\n            this._vm.setState(0);\n        }\n    }\n    next(tape, owner) {\n        if (!tape.hasMore) {\n            return null;\n        }\n        const startIndex = tape.index;\n        const startChar = tape.currCh;\n        const m = this.vm.match(tape);\n        if (m == null) {\n            let err = null;\n            if (tape.index == startIndex + 1) {\n                err = new TokenizerError(`Unexpected Character: ${startChar}`, startIndex, 1, \"UnexpectedCharacter\", startChar);\n            }\n            else {\n                err = new TokenizerError(`Unexpected Symbol: ${tape.substring(startIndex, tape.index)}`, startIndex, tape.index - startIndex, \"UnexpectedLexeme\");\n            }\n            if (this.onError) {\n                err = this.onError(err, tape, startIndex);\n            }\n            if (err != null) {\n                throw err;\n            }\n            else {\n                return this.next(tape, owner);\n            }\n        }\n        const rule = this.allRules[m.matchIndex];\n        let token = toToken(rule.tag, m, tape);\n        token.id = this.idCounter++;\n        let onMatch = this.onMatchHandlers[m.matchIndex];\n        if (!onMatch) {\n            onMatch = this.matchHandlersByValue[rule.tag];\n        }\n        if (onMatch) {\n            token = onMatch(rule, tape, token, owner);\n            if (token == null) {\n                return this.next(tape, owner);\n            }\n        }\n        else if (rule.skip) {\n            return this.next(tape, owner);\n        }\n        return token;\n    }\n    tokenize(tape, owner = null) {\n        const tokens = [];\n        if (typeof tape === \"string\") {\n            tape = new DefaultTape(tape);\n        }\n        let next = this.next(tape, owner);\n        while (next) {\n            tokens.push(next);\n            try {\n                next = this.next(tape, owner);\n            }\n            catch (err) {\n                tokens.push({\n                    tag: \"ERROR\",\n                    start: err.offset,\n                    end: err.offset + err.length,\n                    value: err.message,\n                });\n                break;\n            }\n        }\n        return tokens;\n    }\n}\n//# sourceMappingURL=tokenizer.js.map","import { flexRE } from \"./builder\";\nexport const SINGLE_QUOTE_STRING = flexRE `[\"]([^\"\\\\\\n]|\\\\.|\\\\\\n)*[\"]`;\nexport const DOUBLE_QUOTE_STRING = flexRE `[']([^'\\\\\\n]|\\\\.|\\\\\\n)*[']`;\nexport const SIMPLE_JS_STRING = '\"(.*?(?<!\\\\\\\\))\"';\nexport const JS_REGEX_WITHOUT_LB = String.raw `/([^\\\\/]|\\\\.)*/([imus]*)`;\nexport const JS_REGEX = String.raw `/(.+?(?<!\\\\))/([imus]*)`;\n//# sourceMappingURL=samples.js.map","import * as TSU from \"@panyam/tsutils\";\nimport { IDSet } from \"./sets\";\nexport class LRItem {\n    constructor(rule, position = 0) {\n        this.id = 0;\n        this.rule = rule;\n        this.position = position;\n    }\n    advance() {\n        TSU.assert(this.position < this.rule.rhs.length);\n        return new LRItem(this.rule, this.position + 1);\n    }\n    copy() {\n        return new LRItem(this.rule, this.position);\n    }\n    get key() {\n        TSU.assert(!isNaN(this.rule.id), \"Rule's ID is not yet set.\");\n        return this.rule.id + \":\" + this.position;\n    }\n    compareTo(another) {\n        let diff = this.rule.id - another.rule.id;\n        if (diff == 0)\n            diff = this.position - another.position;\n        return diff;\n    }\n    equals(another) {\n        return this.compareTo(another) == 0;\n    }\n    get debugString() {\n        const rule = this.rule;\n        const pos = this.position;\n        const pre = rule.rhs.syms.slice(0, pos).join(\" \");\n        const post = rule.rhs.syms.slice(pos).join(\" \");\n        return `${rule.id}  -  ${rule.nt} -> ${pre}  ${post}`;\n    }\n}\nexport class LRItemSet {\n    constructor(ig, ...entries) {\n        this.id = 0;\n        this._key = null;\n        this._lookaheads = {};\n        this._hasLookAheads = false;\n        this.itemGraph = ig;\n        this.values = entries;\n    }\n    copy() {\n        const out = new LRItemSet(this.itemGraph, ...this.values);\n        out._lookaheads = { ...this._lookaheads };\n        out._hasLookAheads = this._hasLookAheads;\n        return out;\n    }\n    addLookAhead(item, sym) {\n        if (!(item.id in this._lookaheads)) {\n            this._lookaheads[item.id] = [];\n        }\n        for (const s of this._lookaheads[item.id])\n            if (s == sym)\n                return false;\n        this._hasLookAheads = true;\n        this._key = null;\n        this._lookaheads[item.id].push(sym);\n        this._lookaheads[item.id].sort((s1, s2) => s1.id - s2.id);\n        return true;\n    }\n    clearLookAheads() {\n        this._lookaheads = {};\n    }\n    getLookAheads(item) {\n        return this._lookaheads[item.id] || [];\n    }\n    get key() {\n        if (this._key == null) {\n            this._key = this.revalKey();\n        }\n        return this._key;\n    }\n    revalKey() {\n        if (this.hasLookAheads) {\n            this.values.sort();\n            return this.values\n                .map((itemId) => {\n                const la = this._lookaheads[itemId] || [];\n                return itemId + \"[\" + la.map((s) => s.id).join(\",\") + \"]\";\n            })\n                .join(\"/\");\n        }\n        else {\n            this.values.sort();\n            return this.values.join(\"/\");\n        }\n    }\n    has(itemId) {\n        return this.values.indexOf(itemId) >= 0;\n    }\n    equals(another) {\n        return this.key == another.key;\n    }\n    add(itemId) {\n        if (!this.has(itemId)) {\n            this.values.push(itemId);\n            this._key = null;\n        }\n        return this;\n    }\n    get size() {\n        return this.values.length;\n    }\n    get debugString() {\n        return this.debugValue.join(\"\\n\");\n    }\n    get hasLookAheads() {\n        return this._hasLookAheads;\n    }\n    get debugValue() {\n        if (this.hasLookAheads) {\n            const items = this.values.map((v) => this.itemGraph.items.get(v));\n            items.sort((i1, i2) => i1.compareTo(i2));\n            return items.map((item) => {\n                const las = this.getLookAheads(item)\n                    .map((s) => s.label)\n                    .sort((s1, s2) => s1.localeCompare(s2))\n                    .join(\", \");\n                return las.length > 0 ? `${item.debugString} / ( ${las} )` : item.debugString;\n            });\n        }\n        else {\n            const items = this.values.map((v) => this.itemGraph.items.get(v));\n            items.sort((i1, i2) => i1.compareTo(i2));\n            return items.map((i) => i.debugString);\n        }\n    }\n}\nexport class LRItemGraph {\n    constructor(grammar) {\n        this.grammar = grammar;\n        this.gotoSets = {};\n        this.items = new IDSet();\n        this.itemSets = new IDSet();\n    }\n    startItem() {\n        const startSymbol = this.grammar.startSymbol;\n        TSU.assert(startSymbol != null, \"Start symbol must be set\");\n        TSU.assert((this.grammar.augStartRule || null) != null, \"Grammar is not augmented\");\n        return this.items.ensure(new LRItem(this.grammar.augStartRule));\n    }\n    reset() {\n        this.grammar.refresh();\n        this.gotoSets = {};\n        this.items.clear();\n        this.itemSets.clear();\n        this.startSet();\n    }\n    refresh() {\n        this.reset();\n        this.grammar.refresh();\n        this.evalGotoSets();\n        return this;\n    }\n    evalGotoSets() {\n        const out = this.itemSets;\n        for (let i = 0; i < out.size; i++) {\n            const currSet = out.get(i);\n            for (const sym of this.grammar.allSymbols) {\n                if (sym != this.grammar.Null) {\n                    const gotoSet = this.goto(currSet, sym);\n                    if (gotoSet.size > 0) {\n                        this.setGoto(currSet, sym, gotoSet);\n                    }\n                }\n            }\n        }\n    }\n    goto(itemSet, sym) {\n        const out = this.newItemSet();\n        for (const itemId of itemSet.values) {\n            const item = this.items.get(itemId);\n            const rule = item.rule;\n            if (item.position < rule.rhs.length) {\n                if (rule.rhs.syms[item.position] == sym) {\n                    this.advanceItemAndAdd(item, itemSet, out);\n                }\n            }\n        }\n        return this.closure(out);\n    }\n    advanceItemAndAdd(itemToAdvance, fromItemSet, toItemSet) {\n        const newItem = this.items.ensure(itemToAdvance.advance());\n        toItemSet.add(newItem.id);\n        for (const laSym of fromItemSet.getLookAheads(itemToAdvance)) {\n            toItemSet.addLookAhead(newItem, laSym);\n        }\n    }\n    newItemSet(...items) {\n        return new LRItemSet(this, ...items.map((item) => item.id));\n    }\n    get size() {\n        return this.itemSets.size;\n    }\n    ensureGotoSet(fromSet) {\n        if (!(fromSet.id in this.gotoSets)) {\n            this.gotoSets[fromSet.id] = {};\n        }\n        return this.gotoSets[fromSet.id];\n    }\n    setGoto(fromSet, sym, toSet) {\n        const entries = this.ensureGotoSet(fromSet);\n        entries[sym.id] = toSet;\n    }\n    getGoto(fromSet, sym) {\n        return (this.gotoSets[fromSet.id] || {})[sym.id] || null;\n    }\n    forEachGoto(itemSet, visitor) {\n        const gotoSet = this.gotoSets[itemSet.id] || {};\n        for (const symid in gotoSet) {\n            const sym = this.grammar.getSymById(symid);\n            const next = gotoSet[symid];\n            if (visitor(sym, next) == false)\n                break;\n        }\n    }\n    gotoSetFor(itemSet) {\n        return this.gotoSets[itemSet.id] || {};\n    }\n    get debugValue() {\n        const out = {};\n        this.itemSets.entries.forEach((iset) => {\n            out[iset.id] = { items: [], goto: {} };\n            out[iset.id][\"items\"] = iset.debugValue;\n            const g = this.gotoSets[iset.id];\n            for (const symid in g) {\n                const sym = this.grammar.getSymById(symid);\n                out[iset.id][\"goto\"] = out[iset.id][\"goto\"] || {};\n                out[iset.id][\"goto\"][sym.label] = g[symid].id;\n            }\n        });\n        return out;\n    }\n}\nexport class LR0ItemGraph extends LRItemGraph {\n    startSet() {\n        const startItem = this.startItem();\n        const newset = this.newItemSet(startItem);\n        return this.closure(newset);\n    }\n    closure(itemSet) {\n        const out = new LRItemSet(this, ...itemSet.values);\n        for (let i = 0; i < out.values.length; i++) {\n            const itemId = out.values[i];\n            const item = this.items.get(itemId);\n            const rule = item.rule;\n            if (item.position < rule.rhs.length) {\n                const sym = rule.rhs.syms[item.position];\n                if (!sym.isTerminal) {\n                    for (const rule of this.grammar.rulesForNT(sym)) {\n                        const newItem = this.items.ensure(new LRItem(rule, 0));\n                        out.add(newItem.id);\n                    }\n                }\n            }\n        }\n        return out.size == 0 ? out : this.itemSets.ensure(out);\n    }\n}\nexport class LR1ItemGraph extends LRItemGraph {\n    startSet() {\n        const startItem = this.startItem();\n        const newset = this.newItemSet(startItem);\n        newset.addLookAhead(startItem, this.grammar.Eof);\n        return this.closure(newset);\n    }\n    closure(itemSet) {\n        const out = itemSet.copy();\n        for (let i = 0; i < out.values.length; i++) {\n            const itemId = out.values[i];\n            const item = this.items.get(itemId);\n            if (item.position >= item.rule.rhs.length)\n                continue;\n            const rhs = item.rule.rhs;\n            const B = rhs.syms[item.position];\n            if (B.isTerminal)\n                continue;\n            for (const lookahead of out.getLookAheads(item)) {\n                const suffix = rhs.copy().append(lookahead);\n                this.grammar.firstSets.forEachTermIn(suffix, item.position + 1, (term) => {\n                    if (term != null) {\n                        const bRules = this.grammar.rulesForNT(B);\n                        for (const br of bRules) {\n                            const newItem = this.items.ensure(new LRItem(br, 0));\n                            out.add(newItem.id);\n                            out.addLookAhead(newItem, term);\n                        }\n                    }\n                });\n            }\n        }\n        return out.size == 0 ? out : this.itemSets.ensure(out);\n    }\n}\n//# sourceMappingURL=lritems.js.map","export class ParseError extends Error {\n    constructor(message, type, value = null) {\n        super(message);\n        this.type = type;\n        this.value = value;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n    get name() {\n        return this.constructor.name;\n    }\n}\n//# sourceMappingURL=errors.js.map"],"names":["PFNode","constructor","id","sym","value","children","this","childCount","length","childAt","index","isTerminal","add","node","Error","label","push","splice","numToDelete","nodes","reprString","debugValue","join","raw","out","map","c","forEach","l","PTNode","super","arguments","parent","ParserBase","setTokenizer","tokenizer","tokenbuffer","getSym","token","grammar","tag","SimpleParser","parse","input","delegate","parseInput","Sym","isAuxiliary","auxType","precedence","assocLeft","creationId","idCounter","compareTo","another","localeCompare","equals","toString","Str","syms","append","lits","extend","strs","s","copy","lit","slice","startIndex","endIndex","itemsToAdd","i","diff","containsAt","offset","debugString","RuleAction","isFunction","isChildPosition","Rule","nt","rhs","action","isNaN","Grammar","make","callback","g","config","startSymbol","modified","symbolSet","allRules","_rulesForNT","_followSets","_hasNull","auxNTCount","auxNTPrefix","Null","newTerm","Eof","rulesForNT","rule","nullables","firstSets","followSets","refresh","augStartRule","_AugStartRule","augmentStartSymbol","augSym","newNT","addRule","entries","addTerminals","terminals","t","filter","x","allNonTerminals","nonTerminals","auxNonTerminals","allSymbols","forEachNT","visitor","forEachRule","rules","getRule","findRule","production","findIndex","r","nonterm","ensureSym","removeRules","pred","removeSymbols","newRules","newRhs","remove","getSymById","get","getByKey","throwIfExists","sym2","ensure","size","T","NT","isNT","isAuxNT","seq","exps","normalizeRule","e","anyof","ensureAuxNT","opt","exp","atleast0","leftRec","auxNT","findAuxNT","which","newAuxNT","atleast1","newAuxNTName","name","findAuxNTByRules","ntRules","print","options","ruleSep","includeSemiColon","lambdaSymbol","terminalDerivingSymbols","nadded","allDerive","has","reachableSymbols","fromSymbol","reachable","queue","newQueue","curr","cycles","allMinimalCycles","val","ruleIndex","j","isStrNullable","leftRecursion","isNullable","str2regex","replace","TokenType","NodeType","load","params","eparser","Loader","tokenFunc","generatedTokenizer","next","bind","debug","split","p","console","log","vm","prog","leftRecursive","regexSyntax","symbolsByLabel","newSymbolCallback","tokenHandlers","symbolForLabel","registerSymbol","ensureSymbol","assumedTerminal","currSym","et","lexer","ARROW","OPEN_SQ","CLOSE_SQ","OPEN_PAREN","CLOSE_PAREN","OPEN_BRACE","CLOSE_BRACE","STAR","PLUS","QMARK","SEMI_COLON","COLON","PIPE","SPACES","COMMENT","STRING","tape","substring","start","end","REGEX","pattern","positions","flags","NUMBER","parseInt","PCT_IDENT","DOLLAR_NUM","DOLLAR_IDENT","IDENT","Tokenizer","owner","parseGrammar","parseRegex","priority","syntax","tokPattern","expectToken","re","RegExp","patternStr","hasMore","currCh","advance","trim","peeked","peek","parseDecl","SyntaxError","parseDirective","directive","startsWith","endsWith","tokenHandler","parseTokenHandler","isDef","tokName","addVar","expr","consumeIf","funcName","handler","ident","parseProductions","parseProd","nextMatches","makeParseTable","type","ig","makeParseTableFromLA","makeLRParseTable","parseTable","makeSLRParseTable","hasConflicts","g2","ensureG2Sym","pi","newSymLabel","newSym","startState","gotoSets","transitions","symId","buildRuleFrom","startSet","A","newSyms","xi","nextSym","nextSet","startSym","p1","newA","newRHS","newRule","grammarFromLR0ItemGraph","prevSets","Set","conflictActions","itemSet","itemSets","evalLASetsForLALRItem","makeLALRParseTable","evalLASetsForSLRItem","makeSLRAutomaton","itemId","values","item","items","position","forEachTerm","term","addLookAhead","getGoto","addAction","Shift","lookaheads","getLookAheads","lookahead","Reduce","forEachGoto","Goto","lr1Item","Accept","augGrammar","findP","currState","states","prevStates","nextState","clearLookAheads","pSet","pALabel","pA","indexOf","LRActionType","LRAction","gotoState","ACCEPT","SHIFT","REDUCE","goto","GOTO","ParseTable","actions","Object","keys","getActions","stateId","l1","ac","fromId","a","ParseStack","stateStack","nodeStack","state","top","nth","pop","popN","n","L","isEmpty","Parser","context","tokenizerContext","buildParseTree","copySingleChild","stack","output","resolveActions","actionResolver","nextToken","err","onTokenError","onNextToken","nextValue","topState","topNode","newNode","ruleLen","childNode","beforeAddingChildNode","handlerName","ruleHandlers","onReduction","newAction","defaultKeyFunc","key","IDSet","keyFunc","_entries","_entriesByKey","clear","predicate","e2","entry","SymbolSet","enforceSymbolType","hasNull","labels","sort","skipAux","addFrom","includeNull","addTo","before","termid","delete","NullableSet","nonterms","visited","beforeCount","visit","str","fromIndex","toIndex","SymSymbolSets","_count","entriesFor","count","addNull","source","srcEntries","destEntries","FirstSets","forEachTermIn","allNullable","symj","processRule","FollowSets","idFunc","edges","inACycle","startNode","cycle","nextNode","edgeData","newLRParser","ptable","itemGraph","newParseTable","parser","initPageSetup","sidebarSelector","currentPath","window","location","pathname","document","querySelectorAll","link","href","getAttribute","classList","highlightActiveSidebarLink","ActionCompiler","editor","statusEl","onCompile","compiledFn","compileError","compileTimeout","session","on","clearTimeout","setTimeout","compile","success","fn","error","line","code","getValue","clearAnnotations","updateStatus","result","Function","message","lineMatch","match","setAnnotations","row","column","text","run","getCompileError","hasCompiledAction","statusClass","textContent","build","exprFromJSRE","flatten","res","exprFromFlexRE","F","dotAll","multiline","isRegExp","unicode","ignoreCase","jsRE","strings","String","flexRE","toToken","m","matchIndex","Math","floor","groupIndex","tapeIndex","groups","gi","abs","BaseTokenizer","_prog","_vm","onError","onMatchHandlers","matchHandlersByValue","variables","Map","compiler","findRuleByValue","getVar","regex","currValue","set","find","onMatch","sortedRules","sortRules","VM","r1","r2","getState","setState","reset","startChar","skip","tokenize","tokens","SINGLE_QUOTE_STRING","DOUBLE_QUOTE_STRING","JS_REGEX","LRItem","pos","pre","post","LRItemSet","_key","_lookaheads","_hasLookAheads","s1","s2","revalKey","hasLookAheads","v","i1","i2","las","LRItemGraph","startItem","evalGotoSets","currSet","gotoSet","setGoto","newItemSet","advanceItemAndAdd","closure","itemToAdvance","fromItemSet","toItemSet","newItem","laSym","ensureGotoSet","fromSet","toSet","symid","gotoSetFor","iset","LR0ItemGraph","newset","LR1ItemGraph","B","suffix","bRules","br","ParseError","setPrototypeOf","prototype"],"ignoreList":[],"sourceRoot":""}