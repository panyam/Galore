{"version":3,"file":"906.c098f4cfaf2592ea34fc.js","mappings":"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","sources":["webpack://galore/./node_modules/.pnpm/tlex@1.0.2/node_modules/tlex/lib/esm/core.js","webpack://galore/./node_modules/.pnpm/tlex@1.0.2/node_modules/tlex/lib/esm/flexparser.js","webpack://galore/./node_modules/.pnpm/tlex@1.0.2/node_modules/tlex/lib/esm/errors.js","webpack://galore/./node_modules/.pnpm/tlex@1.0.2/node_modules/tlex/lib/esm/tape.js","webpack://galore/./node_modules/.pnpm/tlex@1.0.2/node_modules/tlex/lib/esm/token.js","webpack://galore/./node_modules/.pnpm/tlex@1.0.2/node_modules/tlex/lib/esm/vm.js","webpack://galore/./node_modules/.pnpm/tlex@1.0.2/node_modules/tlex/lib/esm/utils.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/debug.js","webpack://galore/./node_modules/.pnpm/tlex@1.0.2/node_modules/tlex/lib/esm/jsparser.js","webpack://galore/./node_modules/.pnpm/@panyam+tsutils@1.0.0/node_modules/@panyam/tsutils/lib/esm/types.js","webpack://galore/./node_modules/.pnpm/@panyam+tsutils@1.0.0/node_modules/@panyam/tsutils/lib/esm/constants.js","webpack://galore/./node_modules/.pnpm/@panyam+tsutils@1.0.0/node_modules/@panyam/tsutils/lib/esm/comms/events.js","webpack://galore/./node_modules/.pnpm/@panyam+tsutils@1.0.0/node_modules/@panyam/tsutils/lib/esm/browser.js","webpack://galore/./node_modules/.pnpm/@panyam+tsutils@1.0.0/node_modules/@panyam/tsutils/lib/esm/numberutils.js","webpack://galore/./node_modules/.pnpm/tlex@1.0.2/node_modules/tlex/lib/esm/charclasses.js","webpack://galore/./node_modules/.pnpm/tlex@1.0.2/node_modules/tlex/lib/esm/propertyescapes.js","webpack://galore/./node_modules/.pnpm/tlex@1.0.2/node_modules/tlex/lib/esm/compiler.js"],"sourcesContent":["import * as TSU from \"@panyam/tsutils\";\nimport { CharClassHelpers } from \"./charclasses\";\nimport * as PropertyEscapes from \"./propertyescapes\";\nexport var RegexType;\n(function (RegexType) {\n    RegexType[RegexType[\"START_OF_INPUT\"] = 0] = \"START_OF_INPUT\";\n    RegexType[RegexType[\"END_OF_INPUT\"] = 1] = \"END_OF_INPUT\";\n    RegexType[RegexType[\"START_OF_WORD\"] = 2] = \"START_OF_WORD\";\n    RegexType[RegexType[\"END_OF_WORD\"] = 3] = \"END_OF_WORD\";\n    RegexType[RegexType[\"UNION\"] = 4] = \"UNION\";\n    RegexType[RegexType[\"CAT\"] = 5] = \"CAT\";\n    RegexType[RegexType[\"VAR\"] = 6] = \"VAR\";\n    RegexType[RegexType[\"BACK_NAMED_REF\"] = 7] = \"BACK_NAMED_REF\";\n    RegexType[RegexType[\"BACK_NUM_REF\"] = 8] = \"BACK_NUM_REF\";\n    RegexType[RegexType[\"QUANT\"] = 9] = \"QUANT\";\n    RegexType[RegexType[\"LOOK_AHEAD\"] = 10] = \"LOOK_AHEAD\";\n    RegexType[RegexType[\"LOOK_BACK\"] = 11] = \"LOOK_BACK\";\n    RegexType[RegexType[\"CHAR\"] = 12] = \"CHAR\";\n})(RegexType || (RegexType = {}));\nfunction stringRep(ch) {\n    return String.fromCharCode(ch)\n        .replace(\"\\n\", \"\\\\n\")\n        .replace(\"\\0\", \"\\\\0\")\n        .replace(\"\\r\", \"\\\\r\")\n        .replace(\"\\t\", \"\\\\t\")\n        .replace(\"\\f\", \"\\\\f\")\n        .replace(\"\\b\", \"\\\\b\");\n}\nexport class Regex {\n    constructor() {\n        this.parent = null;\n        this.reString = null;\n        this.groupIndex = -1;\n        this.groupName = null;\n        this.groupIsSilent = false;\n        this.ignoreCase = null;\n        this.dotAll = null;\n        this.multiline = null;\n    }\n    setOptions(options) {\n        if (\"dotAll\" in options)\n            this.dotAll = options.dotAll;\n        if (\"ignoreCase\" in options)\n            this.ignoreCase = options.ignoreCase;\n        if (\"groupIndex\" in options)\n            this.groupIndex = options.groupIndex;\n        if (\"multiline\" in options)\n            this.multiline = options.multiline;\n        return this;\n    }\n    debugValue() {\n        const out = {};\n        if (this.dotAll)\n            out.dotAll = true;\n        if (this.ignoreCase)\n            out.ignoreCase = true;\n        if (this.multiline)\n            out.multiline = true;\n        if (this.groupIndex >= 0)\n            out.groupIndex = this.groupIndex;\n        return out;\n    }\n    get isVariable() {\n        return false;\n    }\n    get toString() {\n        if (this.reString == null) {\n            this.reString = this.evalREString();\n        }\n        return this.reString;\n    }\n    get modifiers() {\n        let mod = \"\";\n        if (this.dotAll)\n            mod += \"d\";\n        if (this.ignoreCase)\n            mod += \"i\";\n        if (this.multiline)\n            mod += \"m\";\n        if (this.groupIndex >= 0)\n            mod += \"g:\" + this.groupIndex;\n        return mod.length == 0 ? mod : \"<\" + mod + \">\";\n    }\n}\nexport class StartOfInput extends Regex {\n    constructor() {\n        super(...arguments);\n        this.tag = RegexType.START_OF_INPUT;\n    }\n    debugValue() {\n        return \"^\";\n    }\n    reverse() {\n        return this;\n    }\n    evalREString() {\n        return \"^\";\n    }\n}\nexport class EndOfInput extends Regex {\n    constructor() {\n        super(...arguments);\n        this.tag = RegexType.END_OF_INPUT;\n    }\n    debugValue() {\n        return \"$\";\n    }\n    evalREString() {\n        return \"$\";\n    }\n    reverse() {\n        return this;\n    }\n}\nexport class StartOfWord extends Regex {\n    constructor() {\n        super(...arguments);\n        this.tag = RegexType.START_OF_WORD;\n    }\n    debugValue() {\n        return \"\\\\b\";\n    }\n    reverse() {\n        return this;\n    }\n    evalREString() {\n        return \"\\\\b\";\n    }\n}\nexport class EndOfWord extends Regex {\n    constructor() {\n        super(...arguments);\n        this.tag = RegexType.END_OF_WORD;\n    }\n    debugValue() {\n        return \"\\\\b\";\n    }\n    reverse() {\n        return this;\n    }\n    evalREString() {\n        return \"\\\\b\";\n    }\n}\nclass Assertion extends Regex {\n    constructor(expr, cond, negate = false) {\n        super();\n        this.expr = expr;\n        this.cond = cond;\n        this.negate = negate;\n    }\n}\nexport class LookAhead extends Assertion {\n    constructor() {\n        super(...arguments);\n        this.tag = RegexType.LOOK_AHEAD;\n    }\n    evalREString() {\n        return `${this.expr.toString}(?${this.negate ? \"!\" : \"=\"}${this.cond.toString})`;\n    }\n    debugValue() {\n        return [\n            \"LookAhead\",\n            {\n                ...super.debugValue(),\n                negate: this.negate,\n                expr: this.expr.debugValue(),\n                cond: this.cond.debugValue(),\n            },\n        ];\n    }\n    reverse() {\n        return new LookBack(this.expr.reverse(), this.cond.reverse(), this.negate);\n    }\n}\nexport class LookBack extends Assertion {\n    constructor() {\n        super(...arguments);\n        this.tag = RegexType.LOOK_BACK;\n    }\n    evalREString() {\n        return `(?<${this.negate ? \"!\" : \"=\"}${this.cond.toString})${this.expr.toString}`;\n    }\n    debugValue() {\n        return [\n            \"LookBack\",\n            {\n                ...super.debugValue(),\n                negate: this.negate,\n                expr: this.expr.debugValue(),\n                cond: this.cond.debugValue(),\n            },\n        ];\n    }\n    reverse() {\n        return new LookAhead(this.expr.reverse(), this.cond.reverse(), this.negate);\n    }\n}\nexport class Quant extends Regex {\n    constructor(expr, minCount = 1, maxCount = 1, greedy = true) {\n        super();\n        this.expr = expr;\n        this.minCount = minCount;\n        this.maxCount = maxCount;\n        this.greedy = greedy;\n        this.tag = RegexType.QUANT;\n    }\n    get isUnlimited() {\n        return this.maxCount < 0 || this.maxCount == TSU.Constants.MAX_INT;\n    }\n    get isVariable() {\n        return this.minCount != this.maxCount || !this.expr.isVariable;\n    }\n    reverse() {\n        return new Quant(this.expr.reverse(), this.minCount, this.maxCount, this.greedy);\n    }\n    evalREString() {\n        let quant = \"*\";\n        if (this.minCount == 1 && this.isUnlimited)\n            quant = \"+\";\n        else if (this.minCount == 0 && this.isUnlimited)\n            quant = \"*\";\n        else if (this.minCount == 0 && this.maxCount == 1)\n            quant = \"?\";\n        else if (this.minCount != 1 || this.maxCount != 1) {\n            if (this.minCount == this.maxCount) {\n                quant = `{${this.minCount}}`;\n            }\n            else {\n                quant = `{${this.minCount},${this.isUnlimited ? \"\" : this.maxCount}}`;\n            }\n        }\n        return `${this.expr.toString}${quant}`;\n    }\n    debugValue() {\n        let quant = \"*\";\n        if (this.minCount == 1 && this.isUnlimited)\n            quant = this.greedy ? \"+?\" : \"+\";\n        else if (this.minCount == 0 && this.isUnlimited)\n            quant = this.greedy ? \"*?\" : \"*\";\n        else if (this.minCount == 0 && this.maxCount == 1)\n            quant = this.greedy ? \"??\" : \"?\";\n        else if (this.minCount != 1 || this.maxCount != 1) {\n            if (this.minCount == this.maxCount) {\n                quant = `{${this.minCount}}` + (this.greedy ? \"?\" : \"\");\n            }\n            else {\n                quant = `{${this.minCount},${this.maxCount}}` + (this.greedy ? \"?\" : \"\");\n            }\n        }\n        return [quant, super.debugValue(), this.expr.debugValue()];\n    }\n}\nexport class Cat extends Regex {\n    constructor(...children) {\n        super();\n        this.tag = RegexType.CAT;\n        this.children = [];\n        for (const child of children) {\n            this.add(child);\n        }\n    }\n    get isVariable() {\n        for (const child of this.children) {\n            if (child.isVariable)\n                return true;\n        }\n        return false;\n    }\n    evalREString() {\n        const out = this.children.map((c) => c.toString).join(\"\");\n        return this.children.length > 1 ? \"(\" + out + \")\" : out;\n    }\n    reverse() {\n        const out = this.children.map((c) => c.reverse());\n        out.reverse();\n        return new Cat(...out);\n    }\n    add(child) {\n        if (child.tag != RegexType.CAT || child.groupIndex >= 0) {\n            this.children.push(child);\n        }\n        else {\n            for (const opt of child.children) {\n                this.add(opt);\n            }\n        }\n        return this;\n    }\n    debugValue() {\n        return [\"Cat\", { ...super.debugValue() }, this.children.map((c) => c.debugValue())];\n    }\n}\nexport class Union extends Regex {\n    constructor(...options) {\n        super();\n        this.tag = RegexType.UNION;\n        this.options = [];\n        for (const option of options) {\n            this.add(option);\n        }\n    }\n    get isVariable() {\n        for (const child of this.options) {\n            if (child.isVariable)\n                return true;\n        }\n        return false;\n    }\n    evalREString() {\n        const out = this.options.map((c) => c.toString).join(\"|\");\n        return this.options.length > 1 ? \"(\" + out + \")\" : out;\n    }\n    reverse() {\n        const out = this.options.map((c) => c.reverse());\n        return new Union(...out);\n    }\n    add(option) {\n        if (option.tag != RegexType.UNION || option.groupIndex >= 0) {\n            this.options.push(option);\n        }\n        else {\n            for (const opt of option.options) {\n                this.add(opt);\n            }\n        }\n        return this;\n    }\n    debugValue() {\n        return [\"Union\", { ...super.debugValue() }, this.options.map((c) => c.debugValue())];\n    }\n}\nexport var CharType;\n(function (CharType) {\n    CharType[CharType[\"AnyChar\"] = 1] = \"AnyChar\";\n    CharType[CharType[\"SingleChar\"] = 2] = \"SingleChar\";\n    CharType[CharType[\"CharRange\"] = 3] = \"CharRange\";\n    CharType[CharType[\"PropertyEscape\"] = 4] = \"PropertyEscape\";\n    CharType[CharType[\"CharClass\"] = 5] = \"CharClass\";\n    CharType[CharType[\"Union\"] = 6] = \"Union\";\n    CharType[CharType[\"Intersection\"] = 7] = \"Intersection\";\n})(CharType || (CharType = {}));\nexport class Char extends Regex {\n    constructor(op, neg = false) {\n        super();\n        this.op = op;\n        this.neg = neg;\n        this.tag = RegexType.CHAR;\n    }\n    match(ch) {\n        const result = this.matchChar(ch);\n        return (result && !this.neg) || (this.neg && !result);\n        return result;\n    }\n    reverse() {\n        return this;\n    }\n    debugValue() {\n        return this.toString + this.modifiers;\n    }\n}\nexport class LeafChar extends Char {\n    constructor(op, neg = false, args = []) {\n        super(op, neg);\n        this.op = op;\n        this.neg = neg;\n        this.args = args;\n    }\n    static Any(neg = false) {\n        return new LeafChar(CharType.AnyChar, neg);\n    }\n    static Class(charClass, neg = false) {\n        return new LeafChar(CharType.CharClass, neg, [charClass]);\n    }\n    static Single(ch, neg = false) {\n        if (typeof ch === \"string\") {\n            ch = ch.charCodeAt(0);\n        }\n        return new LeafChar(CharType.SingleChar, neg, [ch]);\n    }\n    static PropertyEscape(propNameOrId, propValueOrId, neg = false) {\n        if (typeof propNameOrId === \"string\")\n            propNameOrId = PropertyEscapes.propertyNameFor(propNameOrId);\n        if (typeof propValueOrId === \"string\")\n            propValueOrId = PropertyEscapes.propertyValueFor(propValueOrId);\n        return new LeafChar(CharType.PropertyEscape, neg, [propNameOrId, propValueOrId]);\n    }\n    matchChar(ch) {\n        const args = this.args;\n        switch (this.op) {\n            case CharType.SingleChar:\n                return ch == this.args[0];\n            case CharType.CharClass:\n                return CharClassHelpers[args[0]].matches(ch, false);\n            case CharType.PropertyEscape:\n                throw new Error(\"Property Escape Matching - TBD\");\n            default:\n                throw new Error(\"Custom Chars - TBD i: \" + this.op);\n        }\n        return false;\n    }\n    compareTo(another) {\n        if (this.op != another.op)\n            return this.op - another.op;\n        for (let i = 0; i < this.args.length && i < another.args.length; i++) {\n            if (this.args[i] != another.args[i])\n                return this.args[i] - another.args[i];\n        }\n        return this.args.length - another.args.length;\n    }\n    evalREString() {\n        if (this.op == CharType.AnyChar) {\n            return \".\";\n        }\n        else if (this.op == CharType.SingleChar) {\n            return stringRep(this.args[0]);\n        }\n        else if (this.op == CharType.CharClass) {\n            return CharClassHelpers[this.args[0]].reString(this.neg);\n        }\n        else if (this.op == CharType.PropertyEscape) {\n            return this.neg ? \"\\\\P{\" : \"\\\\p{\" + \"}\";\n            return `${PropertyEscapes.propertyNameString(this.args[0])}=${PropertyEscapes.propertyValueString(this.args[1])}\\}`;\n        }\n        return \"Custom \" + this.args.join(\" \");\n    }\n}\nexport class CharGroup extends Char {\n    constructor(op, neg = false, chars = []) {\n        super(op, neg);\n        this.op = op;\n        this.neg = neg;\n        this.chars = chars;\n    }\n    compareTo(another) {\n        if (this.op != another.op)\n            return this.op - another.op;\n        for (let i = 0; i < this.chars.length && i < another.chars.length; i++) {\n            const d = this.chars[i].compareTo(another.chars[i]);\n            if (d != 0)\n                return d;\n        }\n        return this.chars.length - another.chars.length;\n    }\n    matchChar(ch) {\n        const chars = this.chars;\n        switch (this.op) {\n            case CharType.CharRange:\n                return ch >= chars[0].args[0] && ch <= chars[1].args[0];\n            case CharType.Union: {\n                for (let i = 0; i < chars.length; i++) {\n                    if (chars[i].match(ch))\n                        return true;\n                }\n                return false;\n            }\n            case CharType.Intersection: {\n                for (let i = 0; i < chars.length; i++) {\n                    if (!chars[i].match(ch))\n                        return false;\n                }\n                return true;\n            }\n            default:\n                throw new Error(\"Custom CharGroup - TBD i: \" + this.op);\n        }\n        return false;\n    }\n    evalREString() {\n        const out = this.chars.map((ch) => ch.debugValue()).join(\"\");\n        if (this.op == CharType.CharRange) {\n            return `${this.chars[0].toString}-${this.chars[1].toString}`;\n        }\n        else if (this.op == CharType.Union) {\n            return out.length > 1 ? (this.neg ? \"[^\" : \"[\") + out + \"]\" : out;\n        }\n        else if (this.op == CharType.Intersection) {\n            return out.length > 1 ? (this.neg ? \"[^\" : \"[\") + out + \"]\" : out;\n        }\n        return \"Custom \" + this.chars.join(\" \");\n    }\n    static Range(start, end, neg = false) {\n        return new CharGroup(CharType.CharRange, neg, [start, end]);\n    }\n    static Union(neg = false, chars) {\n        return new CharGroup(CharType.Union, neg, chars);\n    }\n    static Intersection(neg = false, chars) {\n        return new CharGroup(CharType.Intersection, neg, chars);\n    }\n}\nexport class Var extends Regex {\n    constructor(name, reversed = false) {\n        super();\n        this.name = name;\n        this.reversed = reversed;\n        this.tag = RegexType.VAR;\n    }\n    reverse() {\n        return new Var(this.name, !this.reversed);\n    }\n    evalREString() {\n        return \"<\" + this.name + \">\";\n    }\n    debugValue() {\n        return [\"V:\" + this.name, { ...super.debugValue() }];\n    }\n}\nexport class BackNamedRef extends Regex {\n    constructor(name, reversed = false) {\n        super();\n        this.name = name;\n        this.reversed = reversed;\n        this.tag = RegexType.BACK_NAMED_REF;\n    }\n    reverse() {\n        return new BackNamedRef(this.name, !this.reversed);\n    }\n    evalREString() {\n        return \"\\\\k<\" + this.name + \">\";\n    }\n    debugValue() {\n        return { ...super.debugValue, BackRef: this.name };\n    }\n}\nexport class BackNumRef extends Regex {\n    constructor(num, reversed = false) {\n        super();\n        this.num = num;\n        this.reversed = reversed;\n        this.tag = RegexType.BACK_NUM_REF;\n    }\n    reverse() {\n        return new BackNumRef(this.num, !this.reversed);\n    }\n    evalREString() {\n        return \"\\\\\" + this.num;\n    }\n    debugValue() {\n        return \"\\\\\" + this.num;\n    }\n}\nexport class Rule {\n    constructor(expr, config) {\n        this.expr = expr;\n        this.skip = false;\n        config = config || {};\n        this.tag = config.tag || null;\n        if (config.priority == 0) {\n            this.priority = 0;\n        }\n        else {\n            this.priority = config.priority || 10;\n        }\n        if (config.matchIndex == 0) {\n            this.matchIndex = 0;\n        }\n        else {\n            this.matchIndex = config.matchIndex || -1;\n        }\n        this.skip = config.skip || false;\n        this.activeStates = config.activeStates || null;\n    }\n    stateCanActivate(state) {\n        return (this.activeStates == null ||\n            this.activeStates.size == 0 ||\n            this.activeStates.has(\"*\") ||\n            this.activeStates.has(state));\n    }\n    get needsSpecificStates() {\n        return this.activeStates != null && this.activeStates.size > 0 && !this.activeStates.has(\"*\");\n    }\n}\n//# sourceMappingURL=core.js.map","import * as TSU from \"@panyam/tsutils\";\nimport { LookAhead, Quant, RegexType, StartOfInput, EndOfInput, Cat, CharType, LeafChar, CharGroup, Var, Union, } from \"./core\";\nimport { CharClassType } from \"./charclasses\";\nimport { GroupCounter, isSpace } from \"./utils\";\nfunction advanceIf(tape, ch) {\n    const pos = tape.index;\n    for (let i = 0; i < ch.length; i++) {\n        if (tape.currCh != ch.charAt(i)) {\n            tape.index = pos;\n            return false;\n        }\n        tape.advance(1);\n    }\n    return true;\n}\nexport class RegexParser {\n    constructor() {\n        this.counter = new GroupCounter();\n    }\n    parse(pattern, ignoreSpaces = false, obCount = 0) {\n        const stack = [];\n        while (pattern.hasMore) {\n            const currCh = pattern.currCh;\n            if (advanceIf(pattern, \".\")) {\n                stack.push(LeafChar.Any());\n            }\n            else if (advanceIf(pattern, \"^\")) {\n                const x = new StartOfInput();\n                x.multiline = true;\n                stack.push(x);\n            }\n            else if (advanceIf(pattern, \"$\")) {\n                const x = new EndOfInput();\n                x.multiline = true;\n                stack.push(x);\n            }\n            else if (advanceIf(pattern, \"|\")) {\n                const prev = this.reduceLeft(stack);\n                const rest = this.parse(pattern, ignoreSpaces, obCount);\n                return new Union(prev, rest);\n            }\n            else if (currCh == \"[\") {\n                stack.push(this.parseCharGroup(pattern));\n            }\n            else if (currCh == \"*\" || currCh == \"?\" || currCh == \"+\" || currCh == \"{\") {\n                this.parseQuant(pattern, stack);\n            }\n            else if (ignoreSpaces && isSpace(currCh)) {\n                pattern.advance(1);\n            }\n            else if (ignoreSpaces && advanceIf(pattern, \"/*\")) {\n                while (pattern.currCh != \"*\" || pattern.nextCh != \"/\") {\n                    if (!pattern.hasMore) {\n                        this.throwError(pattern, \"Unterminated comment\");\n                    }\n                    pattern.advance(1);\n                }\n                pattern.advance(2);\n            }\n            else if (advanceIf(pattern, \"{-}\")) {\n                throw new Error(\"Intersection Not yet supported\");\n            }\n            else if (advanceIf(pattern, \"{+}\")) {\n                throw new Error(\"Union Not yet supported\");\n            }\n            else if (advanceIf(pattern, \"(\")) {\n                if (advanceIf(pattern, \"?\")) {\n                    if (advanceIf(pattern, \"#\")) {\n                        while (pattern.hasMore && pattern.currCh != \")\")\n                            pattern.advance(1);\n                        TSU.assert(advanceIf(pattern, \")\"), \"Expected ')'\");\n                    }\n                    else {\n                        let ignoreCase = false;\n                        let dotAll = false;\n                        let ignoreSpaces2 = ignoreSpaces;\n                        let neg = false;\n                        while (pattern.hasMore && pattern.currCh != \":\") {\n                            if (pattern.currCh == \"i\") {\n                                ignoreCase = neg ? false : true;\n                            }\n                            else if (pattern.currCh == \"s\") {\n                                dotAll = neg ? false : true;\n                            }\n                            else if (pattern.currCh == \"x\") {\n                                ignoreSpaces2 = neg ? false : true;\n                            }\n                            else if (pattern.currCh == \"-\") {\n                                neg = true;\n                            }\n                            pattern.advance(1);\n                        }\n                        TSU.assert(advanceIf(pattern, \":\"), \"Expected ':'\");\n                        const groupIndex = this.counter.next();\n                        let subExpr = this.parse(pattern, ignoreSpaces2, obCount + 1);\n                        if (subExpr.groupIndex >= 0) {\n                            subExpr = new Cat(subExpr);\n                        }\n                        subExpr.dotAll = dotAll;\n                        subExpr.ignoreCase = ignoreCase;\n                        subExpr.groupIndex = groupIndex;\n                        stack.push(subExpr);\n                        TSU.assert(advanceIf(pattern, \")\"), \"Expected ')'\");\n                    }\n                }\n                else {\n                    const groupIndex = this.counter.next();\n                    let subExpr = this.parse(pattern, ignoreSpaces, obCount + 1);\n                    if (subExpr.groupIndex >= 0) {\n                        subExpr = new Cat(subExpr);\n                    }\n                    subExpr.groupIndex = groupIndex;\n                    stack.push(subExpr);\n                    TSU.assert(advanceIf(pattern, \")\"), \"Expected ')'\");\n                }\n            }\n            else if (currCh == \")\") {\n                if (obCount == 0) {\n                    this.throwError(pattern, `Unmatched ${currCh}.  Try using \\\\${currCh}`);\n                }\n                break;\n            }\n            else if (currCh == \"]\" || currCh == \"}\") {\n                this.throwError(pattern, `Unmatched ${currCh}.  Try using \\\\${currCh}`);\n            }\n            else if (advanceIf(pattern, \"/\")) {\n                const prev = this.reduceLeft(stack);\n                const rest = this.parse(pattern, ignoreSpaces, obCount);\n                return new LookAhead(prev, rest, false);\n            }\n            else if (advanceIf(pattern, '\"')) {\n                while (pattern.currCh != '\"') {\n                    if (!pattern.hasMore) {\n                        this.throwError(pattern, \"Unterminated string\");\n                    }\n                    stack.push(this.parseChar(pattern));\n                }\n                pattern.advance(1);\n            }\n            else {\n                stack.push(this.parseChar(pattern));\n            }\n        }\n        if (stack.length == 1)\n            return stack[0];\n        return new Cat(...stack);\n    }\n    parseQuant(pattern, stack) {\n        let minCount = 1, maxCount = 1;\n        if (advanceIf(pattern, \"*\")) {\n            minCount = 0;\n            maxCount = TSU.Constants.MAX_INT;\n        }\n        else if (advanceIf(pattern, \"+\")) {\n            minCount = Math.min(minCount, 1);\n            maxCount = TSU.Constants.MAX_INT;\n        }\n        else if (advanceIf(pattern, \"?\")) {\n            minCount = 0;\n            maxCount = Math.max(maxCount, 1);\n        }\n        else if (advanceIf(pattern, \"{\")) {\n            let foundComma = false;\n            let p1 = \"\";\n            let p2 = \"\";\n            while (pattern.hasMore && pattern.currCh != \"}\") {\n                if (pattern.currCh == \",\")\n                    foundComma = true;\n                else {\n                    if (!foundComma)\n                        p1 += pattern.currCh;\n                    else\n                        p2 += pattern.currCh;\n                }\n                pattern.advance(1);\n            }\n            if (!pattern.hasMore) {\n                this.throwError(pattern, \"Invalid property escape\");\n            }\n            p1 = p1.trim();\n            p2 = p2.trim();\n            pattern.advance(1);\n            const part1 = parseInt(p1);\n            const part2 = parseInt(p2);\n            if (foundComma) {\n                minCount = isNaN(part1) ? 0 : part1;\n                maxCount = isNaN(part2) ? TSU.Constants.MAX_INT : part2;\n                if (minCount > maxCount) {\n                    this.throwError(pattern, `Invalid Quant /${p1},${p2}/: Min must be <= Max`);\n                }\n            }\n            else {\n                if (isNaN(part1)) {\n                    if (p1.length > 0) {\n                        stack.push(new Var(p1));\n                        return;\n                    }\n                    else {\n                        this.throwError(pattern, `Invalid quantifier: /${p1}/`);\n                    }\n                    minCount = maxCount = 1;\n                }\n                else {\n                    minCount = maxCount = part1;\n                }\n            }\n        }\n        else {\n            this.throwError(pattern, \"Expected '{', '*', '?' or '+', Found: \" + pattern.currCh);\n        }\n        if (stack.length <= 0) {\n            this.throwError(pattern, \"Quantifier cannot appear before an expression\");\n        }\n        const last = stack[stack.length - 1];\n        let quant;\n        if (last.tag == RegexType.QUANT && last.groupIndex < 0) {\n            quant = last;\n            quant.minCount = Math.min(minCount, quant.minCount);\n            quant.maxCount = Math.max(maxCount, quant.maxCount);\n        }\n        else {\n            quant = stack[stack.length - 1] = new Quant(last);\n            quant.minCount = minCount;\n            quant.maxCount = maxCount;\n        }\n        if (quant.greedy && advanceIf(pattern, \"?\")) {\n            quant.greedy = false;\n        }\n    }\n    parseCharGroup(pattern) {\n        const out = [];\n        TSU.assert(advanceIf(pattern, \"[\"), \"Expected '['\");\n        const neg = advanceIf(pattern, \"^\");\n        while (pattern.currCh != \"]\") {\n            const currch = this.parseChar(pattern);\n            if (advanceIf(pattern, \"-\")) {\n                if (pattern.hasMore) {\n                    if (pattern.currCh == \"]\" || pattern.currCh == \"[\") {\n                        out.push(currch);\n                        out.push(LeafChar.Single(\"-\"));\n                    }\n                    else {\n                        const endch = this.parseChar(pattern);\n                        if (currch.op != CharType.SingleChar || endch.op != CharType.SingleChar) {\n                            this.throwError(pattern, \"Char range cannot start or end in a char class\");\n                        }\n                        if (endch.args[0] < currch.args[0]) {\n                            this.throwError(pattern, \"End cannot be less than start\");\n                        }\n                        out.push(CharGroup.Range(currch, endch));\n                    }\n                }\n                else {\n                    this.throwError(pattern, \"Unterminated char class\");\n                }\n            }\n            else {\n                out.push(currch);\n            }\n        }\n        TSU.assert(advanceIf(pattern, \"]\"), \"']' expected\");\n        return CharGroup.Union(neg, out);\n    }\n    parseChar(pattern) {\n        if (pattern.currCh == \"\\\\\") {\n            return this.parseEscapeChar(pattern);\n        }\n        else {\n            return this.parseSingleChar(pattern);\n        }\n    }\n    parseSingleChar(pattern) {\n        const ch = pattern.currCh;\n        pattern.advance(1);\n        return LeafChar.Single(ch);\n    }\n    parsePropertyEscape(pattern) {\n        TSU.assert(advanceIf(pattern, \"\\\\{\"), \"Invalid property escape\");\n        pattern.advance(2);\n        let foundEq = false;\n        let propName = \"\";\n        let propValue = \"\";\n        while (pattern.hasMore && pattern.currCh != \"}\") {\n            if (pattern.currCh == \"=\")\n                foundEq = true;\n            else {\n                if (!foundEq)\n                    propName += pattern.currCh;\n                else\n                    propValue += pattern.currCh;\n            }\n            pattern.advance(1);\n        }\n        if (!pattern.hasMore) {\n            this.throwError(pattern, \"Invalid property escape\");\n        }\n        propName = propName.trim();\n        propValue = propValue.trim();\n        if (!foundEq) {\n            propValue = propName;\n            propName = \"General_Category\";\n        }\n        pattern.advance(1);\n        return LeafChar.PropertyEscape(propName, propValue);\n    }\n    parseEscapeChar(pattern) {\n        TSU.assert(advanceIf(pattern, \"\\\\\"), \"Expected '\\\\'\");\n        if (!pattern.hasMore) {\n            this.throwError(pattern, \"Encounted unexpected end of input after \\\\\");\n        }\n        if (advanceIf(pattern, \"w\")) {\n            return LeafChar.Class(CharClassType.WORD_CHAR);\n        }\n        else if (advanceIf(pattern, \"W\")) {\n            return LeafChar.Class(CharClassType.WORD_CHAR, true);\n        }\n        else if (advanceIf(pattern, \"d\")) {\n            return LeafChar.Class(CharClassType.DIGITS);\n        }\n        else if (advanceIf(pattern, \"D\")) {\n            return LeafChar.Class(CharClassType.DIGITS, true);\n        }\n        else if (advanceIf(pattern, \"s\")) {\n            return LeafChar.Class(CharClassType.SPACES);\n        }\n        else if (advanceIf(pattern, \"S\")) {\n            return LeafChar.Class(CharClassType.SPACES, true);\n        }\n        else if (advanceIf(pattern, \"0\")) {\n            return LeafChar.Single(\"\\0\");\n        }\n        else if (advanceIf(pattern, \"r\")) {\n            return LeafChar.Single(\"\\r\");\n        }\n        else if (advanceIf(pattern, \"n\")) {\n            return LeafChar.Single(\"\\n\");\n        }\n        else if (advanceIf(pattern, \"f\")) {\n            return LeafChar.Single(\"\\f\");\n        }\n        else if (advanceIf(pattern, \"b\")) {\n            return LeafChar.Single(\"\\b\");\n        }\n        else if (advanceIf(pattern, \"v\")) {\n            return LeafChar.Single(\"\\v\");\n        }\n        else if (advanceIf(pattern, \"t\")) {\n            return LeafChar.Single(\"\\t\");\n        }\n        else if (advanceIf(pattern, \"\\\\\")) {\n            return LeafChar.Single(\"\\\\\");\n        }\n        else if (advanceIf(pattern, \"'\")) {\n            return LeafChar.Single(\"'\");\n        }\n        else if (advanceIf(pattern, '\"')) {\n            return LeafChar.Single('\"');\n        }\n        else if (advanceIf(pattern, \"x\")) {\n            if (!pattern.hasMore) {\n                this.throwError(pattern, `Invalid hex sequence at ${pattern.index}`);\n            }\n            const hexSeq = pattern.currCh + pattern.nextCh;\n            const hexVal = parseInt(hexSeq, 16);\n            TSU.assert(!isNaN(hexVal), `Invalid hex sequence: '${hexSeq}'`);\n            pattern.advance(2);\n            return LeafChar.Single(hexVal);\n        }\n        else if (advanceIf(pattern, \"u\")) {\n            if (!pattern.canAdvance(3)) {\n                this.throwError(pattern, `Invalid unicode sequence at ${pattern.index}`);\n            }\n            const ucodeSeq = pattern.substring(pattern.index, pattern.index + 4);\n            const ucodeVal = parseInt(ucodeSeq, 16);\n            if (isNaN(ucodeVal)) {\n                this.throwError(pattern, `Invalid unicode sequence: '${ucodeSeq}'`);\n            }\n            pattern.advance(4);\n            return LeafChar.Single(ucodeVal);\n        }\n        const ch = pattern.currCh;\n        pattern.advance(1);\n        return LeafChar.Single(ch);\n    }\n    reduceLeft(stack) {\n        const r = stack.length == 1 ? stack[0] : new Cat(...stack);\n        stack.splice(0);\n        return r;\n    }\n    throwError(pattern, msg) {\n        throw new Error(msg);\n    }\n}\n//# sourceMappingURL=flexparser.js.map","export class TokenizerError extends Error {\n    constructor(message, offset, length, type, value = null) {\n        super(message);\n        this.offset = offset;\n        this.length = length;\n        this.type = type;\n        this.value = value;\n        this.name = \"TokenizerError\";\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexport class UnexpectedTokenError extends Error {\n    constructor(foundToken, ...expectedTokens) {\n        super(`Found Token: ${foundToken?.tag || \"EOF\"} (${foundToken?.value || \"\"}), Expected: ${expectedTokens.join(\", \")}`);\n        this.foundToken = foundToken;\n        this.name = \"UnexpectedTokenError\";\n        this.expectedTokens = expectedTokens;\n    }\n}\n//# sourceMappingURL=errors.js.map","export class TapeInterface {\n    constructor(forward = true) {\n        this.forward = forward;\n        this.index = 0;\n    }\n    advance(delta = 1) {\n        const next = this.forward ? this.index + delta : this.index - delta;\n        this.index = next;\n        return true;\n    }\n    canAdvance(delta = 1) {\n        const next = this.forward ? this.index + delta : this.index - delta;\n        return this.hasIndex(next);\n    }\n    get hasMore() {\n        const next = this.forward ? this.index : this.index - 1;\n        return this.hasIndex(next);\n    }\n    get currCh() {\n        return this.charAt(this.index);\n    }\n    get prevCh() {\n        return this.charAt(this.index - (this.forward ? 1 : -1));\n    }\n    get nextCh() {\n        const next = this.index + (this.forward ? 1 : -1);\n        return this.charAt(next);\n    }\n    get currChCode() {\n        if (!this.hasMore)\n            return -1;\n        return this.currCh.charCodeAt(0);\n    }\n    get currChCodeLower() {\n        if (!this.hasMore)\n            return -1;\n        return this.currCh.toLowerCase().charCodeAt(0);\n    }\n    get currChCodeUpper() {\n        if (!this.hasMore)\n            return -1;\n        return this.currCh.toUpperCase().charCodeAt(0);\n    }\n    charCodeAt(index) {\n        if (!this.hasIndex(index))\n            return -1;\n        return this.charAt(index).charCodeAt(0);\n    }\n    charCodeAtLower(index) {\n        if (!this.hasIndex(index))\n            return -1;\n        return this.charAt(index).toLowerCase().charCodeAt(0);\n    }\n    charCodeAtUpper(index) {\n        if (!this.hasIndex(index))\n            return -1;\n        return this.charAt(index).toUpperCase().charCodeAt(0);\n    }\n}\nexport class Tape extends TapeInterface {\n    constructor(input, forward = true) {\n        super(forward);\n        this.forward = forward;\n        this._rawInput = input;\n        this.input = [...input];\n    }\n    push(content) {\n        this._rawInput += content;\n        this.input.push(...content);\n    }\n    substring(startIndex, endIndex) {\n        return this._rawInput.substring(startIndex, endIndex);\n    }\n    hasIndex(index) {\n        return index >= 0 && index < this.input.length;\n    }\n    charAt(index) {\n        if (index < 0 || index >= this.input.length)\n            return \"\";\n        return this.input[index];\n    }\n}\nexport class TapeHelper {\n    static advanceAfter(tape, pattern, ensureNoPrefixSlash = true) {\n        let pos = TapeHelper.advanceTo(tape, pattern, ensureNoPrefixSlash);\n        if (pos >= 0) {\n            pos += pattern.length;\n            tape.index = pos;\n        }\n        return pos;\n    }\n    static advanceTo(tape, pattern, ensureNoPrefixSlash = true) {\n        const lastIndex = tape.index;\n        while (tape.hasMore) {\n            const currStart = tape.index;\n            if (TapeHelper.matches(tape, pattern)) {\n                const endIndex = tape.index;\n                tape.index = currStart;\n                let numSlashes = 0;\n                if (ensureNoPrefixSlash) {\n                    for (let i = endIndex - 1; i >= 0; i--) {\n                        if (tape.charAt(i) == \"\\\\\")\n                            numSlashes++;\n                        else\n                            break;\n                    }\n                }\n                if (numSlashes % 2 == 0) {\n                    return tape.index;\n                }\n            }\n            tape.advance(1);\n        }\n        tape.index = lastIndex;\n        throw new Error(`Unexpected end of input before (${pattern})`);\n        return -1;\n    }\n    static matches(tape, prefix, advance = true) {\n        const lastIndex = tape.index;\n        let i = 0;\n        let success = true;\n        for (; i < prefix.length; i++) {\n            if (prefix[i] != tape.currCh) {\n                success = false;\n                break;\n            }\n            tape.advance(1);\n        }\n        if (!advance || !success) {\n            tape.index = lastIndex;\n        }\n        return success;\n    }\n}\n//# sourceMappingURL=tape.js.map","import { TokenizerError, UnexpectedTokenError } from \"./errors\";\nexport class Token {\n    constructor(tag, matchIndex, start, end) {\n        this.tag = tag;\n        this.matchIndex = matchIndex;\n        this.start = start;\n        this.end = end;\n        this.id = Token.idCounter++;\n        this.value = null;\n        this.groups = {};\n        this.positions = {};\n        this.state = 0;\n        this.lookahead = 1;\n        this.lookback = 1;\n    }\n    isOneOf(...expected) {\n        for (const tok of expected) {\n            if (this.tag == tok) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nToken.idCounter = 0;\nexport class TokenBuffer {\n    constructor(nextToken, tokenizerContext) {\n        this.nextToken = nextToken;\n        this.tokenizerContext = tokenizerContext;\n        this.buffer = [];\n    }\n    next(tape) {\n        const out = this.peek(tape);\n        if (out != null) {\n            this.consume();\n        }\n        return out;\n    }\n    peek(tape, nth = 0) {\n        while (this.buffer.length <= nth) {\n            const tok = this.nextToken(tape, this.tokenizerContext);\n            if (tok == null)\n                return null;\n            this.buffer.push(tok);\n        }\n        return this.buffer[nth];\n    }\n    match(tape, matchFunc, ensure = false, consume = true, nextAction) {\n        const token = this.peek(tape);\n        if (token != null) {\n            if (matchFunc(token)) {\n                if (nextAction && nextAction != null) {\n                    nextAction(token);\n                }\n                if (consume) {\n                    this.consume();\n                }\n            }\n            else if (ensure) {\n                throw new UnexpectedTokenError(token);\n            }\n            else {\n                return null;\n            }\n        }\n        else if (ensure) {\n            throw new TokenizerError(\"Unexpected end of input\", -1, 0, \"UnexpectedEndOfInput\");\n        }\n        return token;\n    }\n    consume() {\n        this.buffer.splice(0, 1);\n    }\n    consumeIf(tape, ...expected) {\n        return this.match(tape, (t) => t.isOneOf(...expected));\n    }\n    expectToken(tape, ...expected) {\n        return this.match(tape, (t) => t.isOneOf(...expected), true, true);\n    }\n    ensureToken(tape, ...expected) {\n        return this.match(tape, (t) => t.isOneOf(...expected), true, false);\n    }\n    nextMatches(tape, ...expected) {\n        const token = this.peek(tape);\n        if (token == null)\n            return null;\n        for (const tok of expected) {\n            if (token.tag == tok)\n                return token;\n        }\n        return null;\n    }\n}\n//# sourceMappingURL=token.js.map","import * as TSU from \"@panyam/tsutils\";\nfunction isNewLineChar(ch) {\n    return ch == \"\\r\" || ch == \"\\n\" || ch == \"\\u2028\" || ch == \"\\u2029\";\n}\nexport class Match {\n    constructor(priority = 10, matchIndex = -1, start = -1, end = -1) {\n        this.priority = priority;\n        this.matchIndex = matchIndex;\n        this.start = start;\n        this.end = end;\n        this.groups = [];\n        this.positions = [];\n    }\n}\nexport var OpCode;\n(function (OpCode) {\n    OpCode[OpCode[\"Any\"] = 0] = \"Any\";\n    OpCode[OpCode[\"AnyNonNL\"] = 1] = \"AnyNonNL\";\n    OpCode[OpCode[\"Char\"] = 2] = \"Char\";\n    OpCode[OpCode[\"CIChar\"] = 3] = \"CIChar\";\n    OpCode[OpCode[\"Match\"] = 4] = \"Match\";\n    OpCode[OpCode[\"Noop\"] = 5] = \"Noop\";\n    OpCode[OpCode[\"Save\"] = 6] = \"Save\";\n    OpCode[OpCode[\"Split\"] = 7] = \"Split\";\n    OpCode[OpCode[\"Jump\"] = 8] = \"Jump\";\n    OpCode[OpCode[\"Begin\"] = 9] = \"Begin\";\n    OpCode[OpCode[\"RBegin\"] = 10] = \"RBegin\";\n    OpCode[OpCode[\"End\"] = 11] = \"End\";\n    OpCode[OpCode[\"StartingChar\"] = 12] = \"StartingChar\";\n    OpCode[OpCode[\"EndingChar\"] = 13] = \"EndingChar\";\n    OpCode[OpCode[\"MLStartingChar\"] = 14] = \"MLStartingChar\";\n    OpCode[OpCode[\"MLEndingChar\"] = 15] = \"MLEndingChar\";\n    OpCode[OpCode[\"StartOfWord\"] = 16] = \"StartOfWord\";\n    OpCode[OpCode[\"EndOfWord\"] = 17] = \"EndOfWord\";\n    OpCode[OpCode[\"GroupStart\"] = 18] = \"GroupStart\";\n    OpCode[OpCode[\"GroupEnd\"] = 19] = \"GroupEnd\";\n    OpCode[OpCode[\"EnsureState\"] = 20] = \"EnsureState\";\n})(OpCode || (OpCode = {}));\nexport class Prog {\n    constructor(startCondition = \"INITIAL\", scIsInclusive = true) {\n        this.startCondition = startCondition;\n        this.scIsInclusive = scIsInclusive;\n        this.instrs = [];\n        this.stateMapping = new Map();\n        this.registerState(\"INITIAL\");\n        this.registerState(startCondition);\n    }\n    get length() {\n        return this.instrs.length;\n    }\n    registerState(state) {\n        if (!this.stateMapping.has(state)) {\n            this.stateMapping.set(state, this.stateMapping.size);\n        }\n        return this.stateMapping.get(state) || -1;\n    }\n    add(opcode, char = null, ...args) {\n        const out = new Instr(opcode, char).add(...args);\n        out.offset = this.instrs.length;\n        this.instrs.push(out);\n        return out;\n    }\n    static with(initializer) {\n        const out = new Prog();\n        initializer(out);\n        return out;\n    }\n    debugValue(instrDebugValue = InstrDebugValue) {\n        if (instrDebugValue) {\n            return this.instrs.map((instr, index) => {\n                if (instr.comment.trim().length > 0)\n                    return `L${index}: ${instrDebugValue(instr)}     # ${instr.comment}`;\n                else\n                    return `L${index}: ${instrDebugValue(instr)}`;\n            });\n        }\n        else {\n            return this.instrs.map((instr, index) => `L${index}: ${instr.debugValue}`);\n        }\n    }\n}\nexport class Instr {\n    constructor(opcode, char = null) {\n        this.opcode = opcode;\n        this.char = char;\n        this.offset = 0;\n        this.comment = \"\";\n        this.args = [];\n        this.char = char;\n    }\n    add(...args) {\n        this.args.push(...args);\n        return this;\n    }\n    get debugValue() {\n        let c = this.comment.trim();\n        if (c.length > 0)\n            c = \"    # \" + c;\n        return `${this.opcode} ${this.args.join(\" \")}    ${this.char || \"\"}   ${c}`;\n    }\n}\nexport class Thread {\n    constructor(offset = 0, gen = 0) {\n        this.offset = offset;\n        this.gen = gen;\n        this.parentId = -1;\n        this.id = 0;\n        this.priority = 0;\n        this.groups = [];\n        this.positions = [];\n        this.registers = {};\n    }\n    regIncr(regId) {\n        if (!(regId in this.registers)) {\n            throw new Error(`Register at offset ${regId} is invalid`);\n        }\n        this.registers[regId]++;\n    }\n    regAcquire(regId) {\n        if (regId in this.registers) {\n            throw new Error(`Register at offset ${regId} already acquired.  Release it first`);\n        }\n        this.registers[regId] = 0;\n    }\n    regRelease(regId) {\n        if (!(regId in this.registers)) {\n            throw new Error(`Register at offset ${regId} is invalid`);\n        }\n        delete this.registers[regId];\n    }\n    regValue(regId) {\n        if (!(regId in this.registers)) {\n            throw new Error(`Register at offset ${regId} is invalid`);\n        }\n        return this.registers[regId];\n    }\n}\nexport class VM {\n    getState() {\n        return this.currState;\n    }\n    setState(state) {\n        this.currState = state;\n    }\n    constructor(prog, start = 0, end = -1, forward = true, configs = {}) {\n        this.prog = prog;\n        this.start = start;\n        this.end = end;\n        this.forward = forward;\n        this.threadCounter = 0;\n        this.currThreads = [];\n        this.nextThreads = [];\n        this.startPos = 0;\n        this.currState = 0;\n        this.gen = 0;\n        this.genForOffset = {};\n        if (end < 0) {\n            end = prog.length - 1;\n        }\n        this.end = end;\n    }\n    savePosition(thread, pos, tapeIndex) {\n        while (thread.positions.length <= pos)\n            thread.positions.push(-1);\n        thread.positions[pos] = tapeIndex;\n    }\n    jumpBy(thread, delta = 1) {\n        return this.jumpTo(thread, thread.offset + delta);\n    }\n    jumpTo(thread, newOffset) {\n        const out = new Thread(newOffset, this.gen);\n        out.id = thread.id;\n        out.parentId = thread.parentId;\n        out.priority = thread.priority;\n        out.positions = thread.positions;\n        out.groups = thread.groups;\n        out.registers = thread.registers;\n        return out;\n    }\n    forkTo(thread, newOffset) {\n        const out = new Thread(newOffset, this.gen);\n        out.id = ++this.threadCounter;\n        out.parentId = thread.id;\n        out.priority = thread.priority;\n        out.positions = [...thread.positions];\n        out.groups = [...thread.groups];\n        out.registers = { ...thread.registers };\n        return out;\n    }\n    startGroup(thread, groupIndex, tapeIndex) {\n        const newThread = this.forkTo(thread, thread.offset + 1);\n        newThread.groups.push([groupIndex, tapeIndex]);\n        return newThread;\n    }\n    endGroup(thread, groupIndex, tapeIndex) {\n        const newThread = this.forkTo(thread, thread.offset + 1);\n        newThread.groups.push([-groupIndex, tapeIndex]);\n        return newThread;\n    }\n    addThread(thread, list, tape, delta = 0) {\n        if (thread.offset < this.start ||\n            thread.offset > this.end ||\n            this.genForOffset[thread.offset - this.start] == this.gen) {\n            return;\n        }\n        this.genForOffset[thread.offset - this.start] = this.gen;\n        const instr = this.prog.instrs[thread.offset];\n        let nextCh;\n        let lastCh;\n        let newThread;\n        const opcode = instr.opcode;\n        switch (opcode) {\n            case OpCode.Jump:\n                newThread = this.jumpTo(thread, instr.args[0]);\n                this.addThread(newThread, list, tape, delta);\n                break;\n            case OpCode.Split:\n                for (let j = 0; j < instr.args.length; j++) {\n                    const newOff = instr.args[j];\n                    const newThread = j == 0 ? this.jumpTo(thread, newOff) : this.forkTo(thread, newOff);\n                    this.addThread(newThread, list, tape, delta);\n                }\n                break;\n            case OpCode.Save:\n                newThread = this.jumpTo(thread, thread.offset + 1);\n                this.savePosition(newThread, instr.args[0], tape.index + delta);\n                if (this.tracer)\n                    this.tracer.threadQueued(thread, tape.index + delta);\n                this.addThread(newThread, list, tape, delta);\n                break;\n            case OpCode.GroupStart:\n                newThread = this.startGroup(thread, instr.args[0], tape.index + delta);\n                if (this.tracer)\n                    this.tracer.threadQueued(thread, tape.index + delta);\n                this.addThread(newThread, list, tape, delta);\n                break;\n            case OpCode.GroupEnd:\n                newThread = this.endGroup(thread, instr.args[0], tape.index + delta);\n                if (this.tracer)\n                    this.tracer.threadQueued(thread, tape.index + delta);\n                this.addThread(newThread, list, tape, delta);\n                break;\n            case OpCode.StartingChar:\n            case OpCode.MLStartingChar:\n                lastCh = this.prevCh(tape);\n                if (tape.index == 0 || (opcode == OpCode.MLStartingChar && isNewLineChar(lastCh))) {\n                    this.addThread(this.jumpBy(thread, 1), list, tape, delta);\n                }\n                break;\n            case OpCode.EndingChar:\n            case OpCode.MLEndingChar:\n                nextCh = this.nextCh(tape);\n                if (nextCh == \"\" || (opcode == OpCode.MLEndingChar && isNewLineChar(nextCh))) {\n                    this.addThread(this.jumpBy(thread, 1), list, tape, delta);\n                }\n                break;\n            case OpCode.StartOfWord:\n                break;\n            case OpCode.EndOfWord:\n                break;\n            case OpCode.RBegin:\n                {\n                    const [groupIndex, negate, end] = instr.args;\n                    const pos = (1 + groupIndex) * 2;\n                    const groupStart = thread.positions[pos];\n                    const [matchSuccess, matchEnd] = this.recurseMatch(tape, groupStart - 1, instr.offset + 1, end, false, negate == 1);\n                    if (matchSuccess) {\n                        this.addThread(this.jumpTo(thread, end + 1), list, tape, delta);\n                    }\n                }\n                break;\n            case OpCode.Begin:\n                const [consume, negate, end] = instr.args;\n                if (consume == 1) {\n                    if (this.tracer)\n                        this.tracer.threadQueued(thread, tape.index);\n                    list.push(thread);\n                }\n                else {\n                    const [matchSuccess, matchEnd] = this.recurseMatch(tape, tape.index + 1, instr.offset + 1, end, true, negate == 1);\n                    if (matchSuccess) {\n                        this.addThread(this.jumpTo(thread, end + 1), list, tape, delta);\n                    }\n                }\n                break;\n            case OpCode.EnsureState:\n                const states = instr.args;\n                for (const state of states) {\n                    if (this.currState == state) {\n                        this.addThread(this.jumpBy(thread, 1), list, tape, delta);\n                        break;\n                    }\n                }\n                break;\n            default:\n                if (this.tracer)\n                    this.tracer.threadQueued(thread, tape.index);\n                list.push(thread);\n                break;\n        }\n    }\n    matchCurrPos(tape, char, ignoreCase = false) {\n        if (ignoreCase) {\n            return char.match(tape.currChCodeLower) || char.match(tape.currChCodeUpper);\n        }\n        else {\n            return char.match(tape.currChCode);\n        }\n    }\n    hasMore(tape) {\n        return this.forward ? tape.hasMore : tape.index >= 0;\n    }\n    nextCh(tape) {\n        const next = tape.index + (this.forward ? 1 : -1);\n        return tape.charAt(next);\n    }\n    prevCh(tape) {\n        return tape.charAt(tape.index - (this.forward ? 1 : -1));\n    }\n    match(tape) {\n        if (this.end < this.start)\n            return null;\n        this.startMatching(tape);\n        let bestMatch = null;\n        while (this.currThreads.length > 0) {\n            bestMatch = this.stepChar(tape, bestMatch);\n        }\n        if (bestMatch != null)\n            tape.index = bestMatch.end;\n        return bestMatch;\n    }\n    recurseMatch(tape, tapeIndex, startOffset, endOffset, forward = true, negate = false) {\n        const savedPos = tape.index;\n        if (!tape.canAdvance(forward ? 1 : -1))\n            return [negate, -1];\n        tape.index = tapeIndex;\n        const vm = new VM(this.prog, startOffset, endOffset, forward);\n        const match = vm.match(tape);\n        const newPos = tape.index;\n        tape.index = savedPos;\n        return [(match != null && !negate) || (match == null && negate), newPos];\n    }\n    startMatching(tape) {\n        this.currThreads = [];\n        this.nextThreads = [];\n        this.gen++;\n        this.addThread(new Thread(this.start, this.gen), this.currThreads, tape);\n        this.startPos = tape.index;\n    }\n    stepChar(tape, currMatch = null) {\n        this.gen++;\n        for (let i = 0; i < this.currThreads.length; i++) {\n            const thread = this.currThreads[i];\n            const nextMatch = this.stepThread(tape, thread);\n            if (nextMatch != null) {\n                if (currMatch == null ||\n                    nextMatch.priority > currMatch.priority ||\n                    (nextMatch.priority == currMatch.priority && nextMatch.end > currMatch.end)) {\n                    currMatch = nextMatch;\n                    break;\n                }\n                else if (currMatch != nextMatch) {\n                }\n            }\n        }\n        if (this.hasMore(tape)) {\n            tape.advance(this.forward ? 1 : -1);\n        }\n        this.currThreads = this.nextThreads;\n        this.nextThreads = [];\n        return currMatch;\n    }\n    stepThread(tape, thread) {\n        if (this.tracer)\n            this.tracer.threadStepped(thread, tape.index, this.gen);\n        let currMatch = null;\n        const instrs = this.prog.instrs;\n        const instr = instrs[thread.offset];\n        const opcode = instr.opcode;\n        const args = instr.args;\n        const delta = this.forward ? 1 : -1;\n        let advanceTape = false;\n        let ch;\n        switch (opcode) {\n            case OpCode.RBegin:\n                throw new Error(\"Invalid state.  Reverse matches must be handled in addThread\");\n                break;\n            case OpCode.Begin:\n                const [consume, negate, end] = instr.args;\n                TSU.assert(consume == 1, \"Plain lookahead cannot be here\");\n                const [matchSuccess, matchEnd] = this.recurseMatch(tape, tape.index, instr.offset + 1, end, true, negate == 1);\n                if (matchSuccess) {\n                    this.addThread(this.jumpTo(thread, end + 1), this.nextThreads, tape);\n                }\n                break;\n            case OpCode.End:\n                const out = new Match(-1, -1, this.startPos, tape.index);\n                out.groups = thread.groups;\n                out.positions = thread.positions;\n                return out;\n                break;\n            case OpCode.Match:\n                if (tape.index > this.startPos) {\n                    const currPriority = instr.args[0];\n                    const matchIndex = instr.args[1];\n                    currMatch = new Match();\n                    currMatch.start = this.startPos;\n                    currMatch.end = tape.index;\n                    currMatch.priority = currPriority;\n                    currMatch.matchIndex = matchIndex;\n                    currMatch.groups = thread.groups;\n                    currMatch.positions = thread.positions;\n                }\n                break;\n            case OpCode.Char:\n            case OpCode.CIChar:\n                if (this.hasMore(tape)) {\n                    advanceTape = this.matchCurrPos(tape, instr.char, opcode == OpCode.CIChar);\n                }\n                break;\n            case OpCode.AnyNonNL:\n            case OpCode.Any:\n                if (this.hasMore(tape)) {\n                    advanceTape = opcode == OpCode.Any || !isNewLineChar(tape.currCh);\n                }\n                break;\n        }\n        if (advanceTape) {\n            this.addThread(this.jumpBy(thread, 1), this.nextThreads, tape, delta);\n        }\n        return currMatch;\n    }\n}\nexport function InstrDebugValue(instr) {\n    switch (instr.opcode) {\n        case OpCode.Match:\n            return `Match ${instr.args[0]} ${instr.args[1]}`;\n        case OpCode.Char:\n        case OpCode.CIChar: {\n            let out = `${OpCode[instr.opcode].toString()} `;\n            out += `${instr.char.debugValue()}`;\n            return out;\n        }\n        case OpCode.Any:\n            return \".\";\n        case OpCode.AnyNonNL:\n            return \"NL.\";\n        case OpCode.StartingChar:\n            return \"^\";\n        case OpCode.MLStartingChar:\n            return \"NL^\";\n        case OpCode.EndingChar:\n            return \"$NL\";\n        case OpCode.MLEndingChar:\n            return \"$NL_MultiLine\";\n        case OpCode.Save:\n            return `Save ${instr.args[0]}`;\n        case OpCode.GroupStart:\n            return `GroupStart ${instr.args[0]}`;\n        case OpCode.GroupEnd:\n            return `GroupEnd ${instr.args[0]}`;\n        case OpCode.Split:\n            return `Split ${instr.args.join(\", \")}`;\n        case OpCode.Jump:\n            return `Jump ${instr.args[0]}`;\n        case OpCode.Begin:\n            return `Begin ${instr.args.join(\" \")}`;\n        case OpCode.RBegin:\n            return `RBegin ${instr.args.join(\" \")}`;\n        case OpCode.End:\n            return `End ${instr.args.join(\" \")}`;\n        case OpCode.EnsureState:\n            return `EnsureState ${instr.args.join(\" \")}`;\n        default:\n            throw new Error(\"Invalid Opcode: \" + instr.opcode);\n    }\n}\n//# sourceMappingURL=vm.js.map","export class GroupCounter {\n    constructor() {\n        this.value = -1;\n    }\n    next() {\n        return ++this.value;\n    }\n    get current() {\n        return this.value;\n    }\n}\nexport function isSpace(ch) {\n    return ch == \" \" || ch == \"\\t\" || ch == \"\\n\" || ch == \"\\r\";\n}\n//# sourceMappingURL=utils.js.map","export function logParserDebug(parser, itemGraph) {\n    const g = parser.grammar;\n    const ptable = parser.parseTable;\n    console.log(\"===============================\\nGrammar (as default): \\n\", g.debugValue.map((x, i) => `${i + 1}  -   ${x}`), \"===============================\\nGrammar (as Bison): \\n\", g.debugValue.map((x, i) => `${x.replace(\"->\", \":\")} ; \\n`).join(\"\"), \"===============================\\nParseTable: \\n\", JSON.stringify(mergedDebugValue(ptable, itemGraph), null, 4), \"===============================\\nConflicts: \\n\", ptable.conflictActions);\n}\nexport function mergedDebugValue(ptable, itemGraph) {\n    const merged = {};\n    const ptabDV = ptable.debugValue;\n    const igDV = itemGraph?.debugValue;\n    for (const stateId in ptabDV) {\n        const actions = ptabDV[stateId];\n        if (itemGraph) {\n            const items = igDV[stateId];\n            merged[stateId] = { items: items[\"items\"], actions: actions, goto: items[\"goto\"] };\n        }\n        else {\n            merged[stateId] = actions;\n        }\n    }\n    return merged;\n}\n//# sourceMappingURL=debug.js.map","import * as TSU from \"@panyam/tsutils\";\nimport { Quant, RegexType, StartOfInput, EndOfInput, Cat, LeafChar, CharGroup, CharType, Var, BackNamedRef, BackNumRef, LookAhead, LookBack, Union, } from \"./core\";\nimport { CharClassType } from \"./charclasses\";\nimport { GroupCounter } from \"./utils\";\nexport class RegexParser {\n    constructor(pattern, config) {\n        this.pattern = pattern;\n        this.counter = new GroupCounter();\n        this.unicode = config?.unicode || false;\n    }\n    reduceLeft(stack) {\n        const r = stack.length == 1 ? stack[0] : new Cat(...stack);\n        stack.splice(0);\n        return r;\n    }\n    throwError(msg) {\n        throw new SyntaxError(`Error in JS RE '${this.pattern}': ${msg}`);\n    }\n    parse(curr = 0, end = -1) {\n        const pattern = this.pattern;\n        const stack = [];\n        if (end < 0)\n            end = pattern.length - 1;\n        while (curr <= end) {\n            const currCh = pattern[curr];\n            if (currCh == \".\") {\n                stack.push(LeafChar.Any());\n                curr++;\n            }\n            else if (currCh == \"\\\\\" && pattern[curr + 1] >= \"1\" && pattern[curr + 1] <= \"9\") {\n                curr++;\n                let num = \"\";\n                while (curr <= end && pattern[curr] >= \"0\" && pattern[curr] <= \"9\") {\n                    num = num + pattern[curr++];\n                }\n                const refNum = parseInt(num);\n                if (refNum > this.counter.current + 1) {\n                    this.throwError(\"Invalid reference: \" + refNum);\n                }\n                stack.push(new BackNumRef(refNum));\n            }\n            else if (currCh == \"\\\\\" && pattern[curr + 1] == \"k\" && pattern[curr + 2] == \"<\") {\n                curr += 3;\n                let gtPos = curr;\n                while (gtPos <= end && pattern[gtPos] != \">\")\n                    gtPos++;\n                if (gtPos > end)\n                    this.throwError(\"Expected '>' found EOI\");\n                const name = pattern.substring(curr, gtPos);\n                if (name.trim() == \"\") {\n                    this.throwError(\"Expected name\");\n                }\n                stack.push(new BackNamedRef(name));\n                curr = gtPos + 1;\n            }\n            else if (currCh == \"[\") {\n                let clPos = curr + 1;\n                while (clPos <= end && pattern[clPos] != \"]\") {\n                    if (pattern[clPos] == \"\\\\\")\n                        clPos++;\n                    clPos++;\n                }\n                if (clPos > end)\n                    this.throwError(\"Expected ']' found EOI\");\n                stack.push(this.parseCharGroup(curr + 1, clPos - 1));\n                curr = clPos + 1;\n            }\n            else if (currCh == \"^\") {\n                stack.push(new StartOfInput());\n                curr++;\n            }\n            else if (currCh == \"$\") {\n                stack.push(new EndOfInput());\n                curr++;\n            }\n            else if (currCh == \"|\") {\n                if (curr + 1 <= end) {\n                    const prev = this.reduceLeft(stack);\n                    const rest = this.parse(curr + 1, end);\n                    return new Union(prev, rest);\n                }\n                curr = end + 1;\n            }\n            else if (currCh == \"(\") {\n                curr = this.parseGroup(stack, curr, end);\n            }\n            else if (currCh == \")\" || currCh == \"]\" || currCh == \"}\") {\n                this.throwError(`Unmatched ${currCh}.  Try using \\\\${currCh}`);\n            }\n            else if (pattern[curr] == \"*\" || pattern[curr] == \"?\" || pattern[curr] == \"+\" || pattern[curr] == \"{\") {\n                curr = this.parseQuant(stack, curr, end);\n            }\n            else {\n                const [result, nchars] = this.parseChar(curr, end);\n                stack.push(result);\n                curr += nchars;\n            }\n        }\n        if (stack.length <= 0) {\n        }\n        if (stack.length == 1)\n            return stack[0];\n        return new Cat(...stack);\n    }\n    parseGroup(stack, curr, end) {\n        let clPos = curr + 1;\n        let depth = 0;\n        const pattern = this.pattern;\n        while (clPos <= end && (pattern[clPos] != \")\" || depth > 0)) {\n            if (pattern[clPos] == \"(\")\n                depth++;\n            else if (pattern[clPos] == \")\")\n                depth--;\n            if (pattern[clPos] == \"\\\\\")\n                clPos++;\n            clPos++;\n        }\n        if (clPos > end)\n            this.throwError(\"Expected ')' found EOI\");\n        curr++;\n        if (pattern[curr] == \"?\") {\n            curr++;\n            if (pattern[curr] == \":\") {\n                stack.push(this.parse(curr + 1, clPos - 1));\n            }\n            else if (pattern[curr] == \"<\" && pattern[curr + 1] != \"!\" && pattern[curr + 1] != \"=\") {\n                const groupIndex = this.counter.next();\n                let groupName = \"\";\n                let gtPos = curr + 1;\n                while (gtPos <= end && pattern[gtPos] != \">\") {\n                    groupName += pattern[gtPos];\n                    gtPos++;\n                }\n                const subExpr = this.parse(gtPos + 1, clPos - 1);\n                subExpr.groupIndex = groupIndex;\n                if (groupName.length > 0)\n                    subExpr.groupName = groupName;\n            }\n            else {\n                let after = true;\n                if (pattern[curr] == \"<\") {\n                    curr++;\n                    after = false;\n                }\n                const neg = pattern[curr++] == \"!\";\n                const cond = this.parse(curr, clPos - 1);\n                if (after) {\n                    if (stack.length == 0) {\n                    }\n                    const expr = new LookAhead(this.reduceLeft(stack), cond, neg);\n                    stack.push(expr);\n                }\n                else {\n                    const rest = this.parse(clPos + 1, end);\n                    if (rest.groupIndex < 0) {\n                        rest.groupIndex = this.counter.next();\n                        rest.groupIsSilent = true;\n                    }\n                    stack.push(new LookBack(rest, cond, neg));\n                    return end + 1;\n                }\n            }\n        }\n        else {\n            const groupIndex = this.counter.next();\n            let neg = false;\n            if (pattern[curr] == \"^\") {\n                neg = true;\n                curr++;\n            }\n            let subExpr = this.parse(curr, clPos - 1);\n            if (subExpr.groupIndex >= 0) {\n                subExpr = new Cat(subExpr);\n            }\n            subExpr.groupIndex = groupIndex;\n            stack.push(subExpr);\n        }\n        return clPos + 1;\n    }\n    parseCharGroup(curr, end) {\n        const out = [];\n        let i = curr;\n        let neg = false;\n        const pattern = this.pattern;\n        if (pattern[i] == \"^\") {\n            neg = true;\n            i++;\n        }\n        for (; i <= end;) {\n            const [currch, nchars] = this.parseChar(i, end);\n            i += nchars;\n            if (i < pattern.length && pattern[i] == \"-\") {\n                i++;\n                if (pattern[i] == \"]\" || pattern[i] == \"[\") {\n                    out.push(currch);\n                    out.push(LeafChar.Single(\"-\"));\n                }\n                else if (i <= end) {\n                    const [endch, nchars] = this.parseChar(i, end);\n                    if (currch.op != CharType.SingleChar || endch.op != CharType.SingleChar) {\n                        this.throwError(\"Char range cannot start or end in a char class\");\n                    }\n                    if (endch.args[0] < currch.args[0]) {\n                        this.throwError(\"End cannot be less than start\");\n                    }\n                    out.push(CharGroup.Range(currch, endch));\n                    i += nchars;\n                }\n                else {\n                    this.throwError(\"Unterminated char class\");\n                }\n            }\n            else {\n                out.push(currch);\n            }\n        }\n        return CharGroup.Union(neg, out);\n    }\n    parseChar(index = 0, end = 0) {\n        if (this.pattern[index] == \"\\\\\") {\n            return this.parseEscapeChar(index, end);\n        }\n        else {\n            return this.parseSingleChar(index, end);\n        }\n    }\n    parseSingleChar(index = 0, end = 0) {\n        const ch = this.pattern.charCodeAt(index);\n        return [LeafChar.Single(ch), 1];\n    }\n    parsePropertyEscape(index = 0, end = 0) {\n        const pattern = this.pattern;\n        if (pattern[index] + 1 != \"{\") {\n            this.throwError(\"Invalid property escape\");\n        }\n        index += 2;\n        let clEnd = index;\n        let eqPos = -1;\n        while (clEnd <= end && pattern[clEnd] != \"}\") {\n            if (pattern[clEnd] == \"=\")\n                eqPos = clEnd;\n            clEnd++;\n        }\n        if (clEnd > end) {\n            this.throwError(\"Invalid property escape\");\n        }\n        const propStr = pattern.substring(index, clEnd);\n        let propName = \"General_Category\";\n        let propValue = propStr;\n        if (eqPos >= 0) {\n            const parts = propStr.split(\"=\");\n            if (parts.length != 2)\n                this.throwError(\"Invalid property escape\");\n            propName = parts[0].trim();\n            propValue = parts[1].trim();\n        }\n        return [LeafChar.PropertyEscape(propName, propValue), 2 + clEnd + 1 - index];\n    }\n    parseEscapeChar(index = 0, end = 0) {\n        const pattern = this.pattern;\n        TSU.assert(pattern[index] == \"\\\\\", \"Expected '\\\\'\");\n        index++;\n        if (index > end) {\n            this.throwError(\"Encounted unexpected end of input after \\\\\");\n        }\n        const ch = pattern[index];\n        if ((this.unicode && ch == \"p\") || ch == \"P\") {\n            return this.parsePropertyEscape(index, end);\n        }\n        switch (ch) {\n            case \"w\":\n                return [LeafChar.Class(CharClassType.WORD_CHAR), 2];\n            case \"W\":\n                return [LeafChar.Class(CharClassType.WORD_CHAR, true), 2];\n            case \"d\":\n                return [LeafChar.Class(CharClassType.DIGITS), 2];\n            case \"D\":\n                return [LeafChar.Class(CharClassType.DIGITS, true), 2];\n            case \"s\":\n                return [LeafChar.Class(CharClassType.SPACES), 2];\n            case \"S\":\n                return [LeafChar.Class(CharClassType.SPACES, true), 2];\n            case \"0\":\n                if (pattern[index + 1] >= \"0\" && pattern[index + 1] <= \"9\" && this.unicode) {\n                    this.throwError(\"Invalid decimal escape\");\n                }\n                return [LeafChar.Single(\"\\0\"), 2];\n            case \"r\":\n                return [LeafChar.Single(\"\\r\"), 2];\n            case \"n\":\n                return [LeafChar.Single(\"\\n\"), 2];\n            case \"f\":\n                return [LeafChar.Single(\"\\f\"), 2];\n            case \"b\":\n                return [LeafChar.Single(\"\\b\"), 2];\n            case \"v\":\n                return [LeafChar.Single(\"\\v\"), 2];\n            case \"t\":\n                return [LeafChar.Single(\"\\t\"), 2];\n            case \"c\":\n                if (this.unicode || index >= end) {\n                    this.throwError(`Invalid char sequence at ${index}, ${end}`);\n                }\n                const next = pattern.charCodeAt(index + 1) % 32;\n                return [LeafChar.Single(next), 3];\n            case \"x\":\n                index++;\n                if (index >= end) {\n                    this.throwError(`Invalid hex sequence at ${index}, ${end}`);\n                }\n                const hexSeq = pattern.substring(index, index + 2);\n                const hexVal = parseInt(hexSeq, 16);\n                TSU.assert(!isNaN(hexVal), `Invalid hex sequence: '${hexSeq}'`);\n                return [LeafChar.Single(hexVal), 4];\n            case \"u\":\n                index++;\n                if (index > end - 3) {\n                    this.throwError(`Invalid unicode sequence at ${index}`);\n                }\n                const ucodeSeq = pattern.substring(index, index + 4);\n                const ucodeVal = parseInt(ucodeSeq, 16);\n                if (isNaN(ucodeVal)) {\n                    this.throwError(`Invalid unicode sequence: '${ucodeSeq}'`);\n                }\n                return [LeafChar.Single(ucodeVal), 6];\n            case \"^\":\n            case \"$\":\n            case \".\":\n            case \"*\":\n            case \"+\":\n            case \"?\":\n            case \"\\\\\":\n            case \"'\":\n            case '\"':\n            case \"(\":\n            case \")\":\n            case \"[\":\n            case \"]\":\n            case \"{\":\n            case \"}\":\n            case \"|\":\n            case \"/\":\n                return [LeafChar.Single(ch), 2];\n            default:\n                if (this.unicode)\n                    this.throwError(\"Invalid escape character: \" + ch);\n                return [LeafChar.Single(ch), 2];\n        }\n    }\n    parseQuant(stack, curr, end) {\n        const pattern = this.pattern;\n        const lastCh = pattern[curr - 1];\n        let minCount = 1, maxCount = 1;\n        if (pattern[curr] == \"*\") {\n            minCount = 0;\n            maxCount = TSU.Constants.MAX_INT;\n        }\n        else if (pattern[curr] == \"+\") {\n            minCount = Math.min(minCount, 1);\n            maxCount = TSU.Constants.MAX_INT;\n        }\n        else if (pattern[curr] == \"?\") {\n            minCount = 0;\n            maxCount = Math.max(maxCount, 1);\n        }\n        else if (pattern[curr] == \"{\") {\n            const clPos = pattern.indexOf(\"}\", curr + 1);\n            if (clPos <= curr || clPos > end) {\n                this.throwError(\"Unexpected end of input while looking for '}'\");\n            }\n            const sub = pattern.substring(curr + 1, clPos).trim();\n            const parts = sub.split(\",\").map((x) => parseInt(x.trim()));\n            curr = clPos;\n            if (parts.length == 1) {\n                if (isNaN(parts[0])) {\n                    if (sub.trim().length > 0) {\n                        stack.push(new Var(sub.trim()));\n                        return curr + 1;\n                    }\n                    else {\n                        this.throwError(`Invalid quantifier: /${sub}/`);\n                    }\n                }\n                minCount = maxCount = parts[0];\n            }\n            else if (parts.length == 2) {\n                minCount = isNaN(parts[0]) ? 0 : parts[0];\n                maxCount = isNaN(parts[1]) ? TSU.Constants.MAX_INT : parts[1];\n                if (minCount > maxCount) {\n                    this.throwError(`Invalid Quant /${sub}/: Min must be <= Max`);\n                }\n            }\n            else if (parts.length > 2) {\n                this.throwError(`Invalid quantifier spec: \"{${sub}}\"`);\n            }\n        }\n        else {\n            throw new Error(\"Here?\");\n        }\n        if (stack.length <= 0) {\n            this.throwError(\"Quantifier cannot appear before an expression\");\n        }\n        const last = stack[stack.length - 1];\n        if (last.tag == RegexType.QUANT && (lastCh == \"*\" || lastCh == \"?\" || lastCh == \"+\" || lastCh == \"}\")) {\n            this.throwError(\"Nothing to repeat\");\n        }\n        if (this.unicode && (last.tag == RegexType.LOOK_AHEAD || last.tag == RegexType.LOOK_BACK)) {\n            this.throwError(\"Cannot have quantifier on assertion in unicode mode\");\n        }\n        const quant = (stack[stack.length - 1] = new Quant(last));\n        quant.minCount = minCount;\n        quant.maxCount = maxCount;\n        curr++;\n        if (curr <= end && pattern[curr] == \"?\" && quant.greedy) {\n            curr++;\n            quant.greedy = false;\n        }\n        return curr;\n    }\n}\n//# sourceMappingURL=jsparser.js.map","export function assert(condition, msg) {\n    if (!condition) {\n        throw new Error(msg);\n    }\n}\n//# sourceMappingURL=types.js.map","export const INFINITY = 1e48;\nexport const MAX_INT = Math.pow(2, 32);\nexport const MAX_LONG = Math.pow(2, 64);\n//# sourceMappingURL=constants.js.map","export class TEvent {\n    constructor(name, source, payload) {\n        this.uuid = TEvent.counter++;\n        this._spawnedFrom = null;\n        this.sourceState = null;\n        this.cancelled = false;\n        this.timeStamp = -1;\n        this.children = [];\n        this.name = name;\n        this.source = source;\n        this.payload = payload;\n    }\n    get spawnedFrom() {\n        return this._spawnedFrom;\n    }\n    setSpawnedFrom(msg) {\n        this._spawnedFrom = msg;\n        if (msg == null)\n            this._rootEvent = this;\n        else\n            this._rootEvent = msg.rootEvent;\n    }\n    spawn(name, source, payload) {\n        const child = new TEvent(name, source, payload);\n        child.setSpawnedFrom(this);\n        this.children.push(child);\n        return child;\n    }\n    get rootEvent() {\n        return this._rootEvent;\n    }\n}\nTEvent.counter = 0;\nexport class State {\n    constructor() {\n        this.stateData = null;\n        this.id = State.counter++;\n    }\n    get name() {\n        return this.constructor.name;\n    }\n    enter(data) {\n        this.stateData = data;\n    }\n    handle(event) {\n    }\n}\nState.counter = 0;\nexport class EventEmitter {\n    constructor() {\n        this._eventHub = new EventHub();\n    }\n    get eventHub() {\n        return this._eventHub;\n    }\n    set eventHub(hub) {\n        const oldHub = this._eventHub;\n        this._eventHub = hub;\n        this.eventHubChanged(oldHub);\n    }\n    eventHubChanged(oldHub) {\n        console.log(\"WARNING - EventHub Change Listener not implemented: \", this.constructor.name);\n    }\n}\nexport class EventHub {\n    constructor() {\n        this._handlers = {};\n        this._events = [];\n        this._inBatchMode = false;\n    }\n    on(names, callback) {\n        return this._addHandler(names, this._handlers, callback);\n    }\n    removeOn(names, callback) {\n        return this._removeHandler(names, this._handlers, callback);\n    }\n    _ensurestrings(names) {\n        if (typeof names === \"string\") {\n            names = names.split(\",\");\n        }\n        return names.map(function (v) {\n            return v.trim();\n        });\n    }\n    _addHandler(names, handlerlist, handler) {\n        this._ensurestrings(names).forEach(function (name) {\n            handlerlist[name] = handlerlist[name] || [];\n            handlerlist[name].push(handler);\n        });\n        return this;\n    }\n    _removeHandler(names, handlerlist, handler) {\n        this._ensurestrings(names).forEach(function (name) {\n            const evHandlers = handlerlist[name] || [];\n            for (let i = 0; i < evHandlers.length; i++) {\n                if (evHandlers[i] == handler) {\n                    evHandlers.splice(i, 1);\n                    break;\n                }\n            }\n        });\n        return this;\n    }\n    emit(name, source, payload) {\n        const evt = new TEvent(name, source, payload);\n        if (this._inBatchMode) {\n            this._events.push(evt);\n            return true;\n        }\n        else {\n            return this.dispatchEvent(evt);\n        }\n    }\n    dispatchEvent(event) {\n        const evtCallbacks = this._handlers[event.name] || [];\n        for (const callback of evtCallbacks) {\n            callback(event);\n            if (event.cancelled)\n                return false;\n        }\n        return true;\n    }\n    startBatchMode() {\n        if (!this._inBatchMode) {\n            this._inBatchMode = true;\n        }\n        return this;\n    }\n    cancelBatch() {\n        this._inBatchMode = false;\n        this._events = [];\n    }\n    commitBatch() {\n        this._inBatchMode = false;\n        this.emit(EventHub.BATCH_EVENTS, this, this._events);\n        this._events = [];\n    }\n}\nEventHub.BATCH_EVENTS = \"BatchEvents\";\nexport class StateMachine {\n    constructor() {\n        this._states = {};\n        this._rootState = null;\n        this._currentState = null;\n        this._states = {};\n        this._rootState = null;\n        this._currentState = null;\n    }\n    set rootState(name) {\n        this._rootState = this.getState(name);\n        if (this._currentState == null) {\n            this._currentState = this._rootState;\n        }\n    }\n    enter(state, data = null) {\n        if (state == \"\") {\n            this._currentState = this._rootState;\n        }\n        else {\n            this._currentState = this.getState(state);\n        }\n        if (this._currentState != null) {\n            this._currentState.enter(data);\n        }\n    }\n    getState(name) {\n        if (!(name in this._states)) {\n            throw Error(\"State '\" + name + \"' not yet registered.\");\n        }\n        return this._states[name];\n    }\n    registerState(state, isRoot = false) {\n        const name = state.name;\n        if (name in this._states) {\n            throw Error(\"State '\" + name + \"' already registered.\");\n        }\n        this._states[name] = state;\n        if (isRoot || false) {\n            this.rootState = state.name;\n        }\n    }\n    handle(event) {\n        if (this._currentState == null)\n            return;\n        const nextState = this._currentState.handle(event);\n        if (nextState != null) {\n            if (nextState == \"\") {\n                if (this._rootState != null) {\n                    this.enter(this._rootState.name);\n                }\n                else {\n                    throw new Error(\"Root state has not been set\");\n                }\n            }\n            else {\n                this.enter(nextState);\n            }\n        }\n    }\n}\n//# sourceMappingURL=events.js.map","export class Browser {\n}\nBrowser.IS_EXPLORER = () => navigator && navigator.userAgent.indexOf(\"MSIE\") > -1;\nBrowser.IS_FIREFOX = () => navigator && navigator.userAgent.indexOf(\"Firefox\") > -1;\nBrowser.IS_OPERA = () => navigator && navigator.userAgent.toLowerCase().indexOf(\"op\") > -1;\nBrowser.UAHasChrome = () => navigator && navigator.userAgent.indexOf(\"Chrome\") > -1;\nBrowser.UAHasSafari = () => navigator && navigator.userAgent.indexOf(\"Safari\") > -1;\nBrowser.IS_SAFARI = () => navigator && Browser.UAHasSafari() && (!Browser.UAHasChrome() || !Browser.UAHasSafari());\nBrowser.IS_CHROME = () => navigator && Browser.UAHasChrome() && (!Browser.UAHasChrome() || !Browser.IS_OPERA());\n//# sourceMappingURL=browser.js.map","export function range(start, end = null, incr = 1) {\n    if (end == null) {\n        const absStart = Math.abs(start);\n        const arr = Array.from({ length: absStart });\n        if (start >= 0) {\n            return arr.map((x, i) => i);\n        }\n        else {\n            return arr.map((x, i) => i - (absStart - 1));\n        }\n    }\n    const out = [];\n    if (incr == null) {\n        incr = 1;\n    }\n    incr = Math.abs(incr);\n    if (start !== end) {\n        if (start < end) {\n            for (let i = start; i <= end; i += incr) {\n                out.push(i);\n            }\n        }\n        else {\n            for (let i = start; i >= end; i -= incr) {\n                out.push(i);\n            }\n        }\n    }\n    return out;\n}\nexport function gcdof(x, y) {\n    x = Math.abs(x);\n    y = Math.abs(y);\n    while (y > 0) {\n        const t = y;\n        y = x % y;\n        x = t;\n    }\n    return x;\n}\nexport class Fraction {\n    constructor(num = 0, den = 1, factorized = false) {\n        if (isNaN(num) || isNaN(den)) {\n            throw new Error(`Invalid numerator(${num}) or denminator(${den})`);\n        }\n        if (factorized) {\n            const gcd = gcdof(num, den);\n            num /= gcd;\n            den /= gcd;\n        }\n        this.num = num;\n        this.den = den;\n    }\n    static parse(val, factorized = false) {\n        const parts = val\n            .trim()\n            .split(\"/\")\n            .map((x) => x.trim());\n        let num = 1;\n        let den = 1;\n        if (parts.length == 1)\n            num = parseInt(parts[0]);\n        else if (parts.length != 2) {\n            throw new Error(\"Invalid fraction string: \" + val);\n        }\n        else {\n            if (parts[0].length > 0) {\n                num = parseInt(parts[0]);\n            }\n            if (parts[1].length > 0) {\n                den = parseInt(parts[1]);\n            }\n        }\n        if (isNaN(num) || isNaN(den)) {\n            throw new Error(\"Invalid fraction string: \" + val);\n        }\n        return new Fraction(num, den, factorized);\n    }\n    get isWhole() {\n        return this.num % this.den == 0;\n    }\n    get isZero() {\n        return this.num == 0;\n    }\n    get isInfinity() {\n        return this.den == 0;\n    }\n    get isOne() {\n        return this.num == this.den;\n    }\n    get ceil() {\n        if (this.num % this.den == 0) {\n            return this.num / this.den;\n        }\n        else {\n            return 1 + Math.floor(this.num / this.den);\n        }\n    }\n    get floor() {\n        if (this.num % this.den == 0) {\n            return this.num / this.den;\n        }\n        else {\n            return Math.floor(this.num / this.den);\n        }\n    }\n    plus(another, factorized = false) {\n        return new Fraction(this.num * another.den + this.den * another.num, this.den * another.den, factorized);\n    }\n    plusNum(another, factorized = false) {\n        return new Fraction(this.num + this.den * another, this.den, factorized);\n    }\n    minus(another, factorized = false) {\n        return new Fraction(this.num * another.den - this.den * another.num, this.den * another.den, factorized);\n    }\n    minusNum(another, factorized = false) {\n        return new Fraction(this.num - this.den * another, this.den, factorized);\n    }\n    times(another, factorized = false) {\n        return new Fraction(this.num * another.num, this.den * another.den, factorized);\n    }\n    timesNum(another, factorized = false) {\n        return new Fraction(this.num * another, this.den, factorized);\n    }\n    divby(another, factorized = false) {\n        return new Fraction(this.num * another.den, this.den * another.num, factorized);\n    }\n    divbyNum(another, factorized = false) {\n        return new Fraction(this.num, this.den * another, factorized);\n    }\n    numDivby(another, factorized = false) {\n        return new Fraction(this.den * another, this.num, factorized);\n    }\n    mod(another) {\n        const d = this.divby(another);\n        const floorOfD = Math.floor(d.num / d.den);\n        return this.minus(another.timesNum(floorOfD));\n    }\n    modNum(another) {\n        const d = this.divbyNum(another);\n        const floorOfD = Math.floor(d.num / d.den);\n        return this.minusNum(another * floorOfD);\n    }\n    get inverse() {\n        return new Fraction(this.den, this.num);\n    }\n    get factorized() {\n        const gcd = gcdof(this.num, this.den);\n        return new Fraction(this.num / gcd, this.den / gcd);\n    }\n    equals(another) {\n        return this.num * another.den == this.den * another.num;\n    }\n    equalsNum(another) {\n        return this.num == this.den * another;\n    }\n    cmp(another) {\n        return this.num * another.den - this.den * another.num;\n    }\n    cmpNum(another) {\n        return this.num - this.den * another;\n    }\n    isLT(another) {\n        return this.cmp(another) < 0;\n    }\n    isLTE(another) {\n        return this.cmp(another) <= 0;\n    }\n    isLTNum(another) {\n        return this.cmpNum(another) < 0;\n    }\n    isLTENum(another) {\n        return this.cmpNum(another) <= 0;\n    }\n    isGT(another) {\n        return this.cmp(another) > 0;\n    }\n    isGTE(another) {\n        return this.cmp(another) >= 0;\n    }\n    isGTNum(another) {\n        return this.cmpNum(another) > 0;\n    }\n    isGTENum(another) {\n        return this.cmpNum(another) >= 0;\n    }\n    toString() {\n        return this.num + \"/\" + this.den;\n    }\n    static max(f1, f2) {\n        return f1.cmp(f2) > 0 ? f1 : f2;\n    }\n    static min(f1, f2) {\n        return f1.cmp(f2) < 0 ? f1 : f2;\n    }\n}\nFraction.ZERO = new Fraction();\nFraction.ONE = new Fraction(1, 1);\nFraction.INFINITY = new Fraction(1, 0);\nexport const Frac = (a = 0, b = 1, factorized = false) => new Fraction(a, b, factorized);\n//# sourceMappingURL=numberutils.js.map","export var CharClassType;\n(function (CharClassType) {\n    CharClassType[CharClassType[\"WORD_CHAR\"] = 0] = \"WORD_CHAR\";\n    CharClassType[CharClassType[\"DIGITS\"] = 1] = \"DIGITS\";\n    CharClassType[CharClassType[\"SPACES\"] = 2] = \"SPACES\";\n})(CharClassType || (CharClassType = {}));\nconst ZERO = \"0\".charCodeAt(0);\nconst NINE = \"9\".charCodeAt(0);\nconst lA = \"a\".charCodeAt(0);\nconst lZ = \"z\".charCodeAt(0);\nconst uA = \"A\".charCodeAt(0);\nconst uZ = \"Z\".charCodeAt(0);\nconst USCORE = \"_\".charCodeAt(0);\nexport class CharClassHelper {\n    matches(charCode, neg) {\n        const res = this.match(charCode);\n        return neg ? !res : res;\n    }\n}\nconst spaceChars = \" \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff\";\nexport class Spaces extends CharClassHelper {\n    match(charCode) {\n        if (charCode >= 0x2000 && charCode <= 0x200a)\n            return true;\n        for (let i = 0; i < spaceChars.length; i++) {\n            if (spaceChars.charCodeAt(i) == charCode)\n                return true;\n        }\n        return false;\n    }\n    reString(neg) {\n        return neg ? \"\\\\S\" : \"\\\\s\";\n    }\n}\nexport class Digit extends CharClassHelper {\n    match(charCode) {\n        return charCode >= ZERO && charCode <= NINE;\n    }\n    reString(neg) {\n        return neg ? \"\\\\D\" : \"\\\\d\";\n    }\n}\nexport class WordChar extends CharClassHelper {\n    match(charCode) {\n        return (charCode == USCORE ||\n            (charCode >= ZERO && charCode <= NINE) ||\n            (charCode >= lA && charCode <= lZ) ||\n            (charCode >= uA && charCode <= uZ));\n        return true;\n    }\n    reString(neg) {\n        return neg ? \"\\\\W\" : \"\\\\w\";\n    }\n}\nexport const CharClassHelpers = [new WordChar(), new Digit(), new Spaces()];\n//# sourceMappingURL=charclasses.js.map","export var PropertyName;\n(function (PropertyName) {\n    PropertyName[PropertyName[\"gc\"] = 0] = \"gc\";\n    PropertyName[PropertyName[\"General_Category\"] = 0] = \"General_Category\";\n    PropertyName[PropertyName[\"sc\"] = 1] = \"sc\";\n    PropertyName[PropertyName[\"Script\"] = 1] = \"Script\";\n    PropertyName[PropertyName[\"scx\"] = 2] = \"scx\";\n    PropertyName[PropertyName[\"Script_Extension\"] = 2] = \"Script_Extension\";\n    PropertyName[PropertyName[\"Any\"] = 3] = \"Any\";\n    PropertyName[PropertyName[\"ASCII\"] = 4] = \"ASCII\";\n    PropertyName[PropertyName[\"AHex\"] = 5] = \"AHex\";\n    PropertyName[PropertyName[\"ASCII_Hex_Digit\"] = 5] = \"ASCII_Hex_Digit\";\n    PropertyName[PropertyName[\"Alpha\"] = 6] = \"Alpha\";\n    PropertyName[PropertyName[\"Alphabetic\"] = 6] = \"Alphabetic\";\n    PropertyName[PropertyName[\"Bidi_M\"] = 7] = \"Bidi_M\";\n    PropertyName[PropertyName[\"Bidi_Mirrored\"] = 7] = \"Bidi_Mirrored\";\n    PropertyName[PropertyName[\"Bidi_C\"] = 8] = \"Bidi_C\";\n    PropertyName[PropertyName[\"Bidi_Control\"] = 8] = \"Bidi_Control\";\n    PropertyName[PropertyName[\"CI\"] = 9] = \"CI\";\n    PropertyName[PropertyName[\"Case_Ignorable\"] = 9] = \"Case_Ignorable\";\n    PropertyName[PropertyName[\"Cased\"] = 10] = \"Cased\";\n    PropertyName[PropertyName[\"CWCF\"] = 11] = \"CWCF\";\n    PropertyName[PropertyName[\"Changes_When_Casefolded\"] = 11] = \"Changes_When_Casefolded\";\n    PropertyName[PropertyName[\"CWCM\"] = 12] = \"CWCM\";\n    PropertyName[PropertyName[\"Changes_When_Casemapped\"] = 12] = \"Changes_When_Casemapped\";\n    PropertyName[PropertyName[\"CWL\"] = 13] = \"CWL\";\n    PropertyName[PropertyName[\"Changes_When_Lowercased\"] = 13] = \"Changes_When_Lowercased\";\n    PropertyName[PropertyName[\"CWKCF\"] = 14] = \"CWKCF\";\n    PropertyName[PropertyName[\"Changes_When_NFKC_Casefolded\"] = 14] = \"Changes_When_NFKC_Casefolded\";\n    PropertyName[PropertyName[\"CWT\"] = 15] = \"CWT\";\n    PropertyName[PropertyName[\"Changes_When_Titlecased\"] = 15] = \"Changes_When_Titlecased\";\n    PropertyName[PropertyName[\"CWU\"] = 16] = \"CWU\";\n    PropertyName[PropertyName[\"Changes_When_Uppercased\"] = 16] = \"Changes_When_Uppercased\";\n    PropertyName[PropertyName[\"Dash\"] = 17] = \"Dash\";\n    PropertyName[PropertyName[\"DI\"] = 18] = \"DI\";\n    PropertyName[PropertyName[\"Default_Ignorable_Code_Point\"] = 18] = \"Default_Ignorable_Code_Point\";\n    PropertyName[PropertyName[\"Dep\"] = 19] = \"Dep\";\n    PropertyName[PropertyName[\"Deprecated\"] = 19] = \"Deprecated\";\n    PropertyName[PropertyName[\"Dia\"] = 20] = \"Dia\";\n    PropertyName[PropertyName[\"Diacritic\"] = 20] = \"Diacritic\";\n    PropertyName[PropertyName[\"Emoji\"] = 21] = \"Emoji\";\n    PropertyName[PropertyName[\"Emoji_Component\"] = 22] = \"Emoji_Component\";\n    PropertyName[PropertyName[\"Emoji_Modifier\"] = 23] = \"Emoji_Modifier\";\n    PropertyName[PropertyName[\"Emoji_Modifier_Base\"] = 24] = \"Emoji_Modifier_Base\";\n    PropertyName[PropertyName[\"Emoji_Presentation\"] = 25] = \"Emoji_Presentation\";\n    PropertyName[PropertyName[\"Ext\"] = 26] = \"Ext\";\n    PropertyName[PropertyName[\"Extender\"] = 26] = \"Extender\";\n    PropertyName[PropertyName[\"Gr_Base\"] = 27] = \"Gr_Base\";\n    PropertyName[PropertyName[\"Grapheme_Base\"] = 27] = \"Grapheme_Base\";\n    PropertyName[PropertyName[\"Gr_Ext\"] = 28] = \"Gr_Ext\";\n    PropertyName[PropertyName[\"Grapheme_Extend\"] = 28] = \"Grapheme_Extend\";\n    PropertyName[PropertyName[\"Hex\"] = 29] = \"Hex\";\n    PropertyName[PropertyName[\"Hex_Digit\"] = 29] = \"Hex_Digit\";\n    PropertyName[PropertyName[\"IDSB\"] = 30] = \"IDSB\";\n    PropertyName[PropertyName[\"IDS_Binary_Operator\"] = 30] = \"IDS_Binary_Operator\";\n    PropertyName[PropertyName[\"IDST\"] = 31] = \"IDST\";\n    PropertyName[PropertyName[\"IDS_Trinary_Operator\"] = 31] = \"IDS_Trinary_Operator\";\n    PropertyName[PropertyName[\"IDC\"] = 32] = \"IDC\";\n    PropertyName[PropertyName[\"ID_Continue\"] = 32] = \"ID_Continue\";\n    PropertyName[PropertyName[\"IDS\"] = 33] = \"IDS\";\n    PropertyName[PropertyName[\"ID_Start\"] = 33] = \"ID_Start\";\n    PropertyName[PropertyName[\"Ideo\"] = 34] = \"Ideo\";\n    PropertyName[PropertyName[\"Ideographic\"] = 34] = \"Ideographic\";\n    PropertyName[PropertyName[\"Join_C\"] = 35] = \"Join_C\";\n    PropertyName[PropertyName[\"Join_Control\"] = 35] = \"Join_Control\";\n    PropertyName[PropertyName[\"LOE\"] = 36] = \"LOE\";\n    PropertyName[PropertyName[\"Logical_Order_Exception\"] = 36] = \"Logical_Order_Exception\";\n    PropertyName[PropertyName[\"Lower\"] = 37] = \"Lower\";\n    PropertyName[PropertyName[\"Lowercase\"] = 37] = \"Lowercase\";\n    PropertyName[PropertyName[\"Math\"] = 38] = \"Math\";\n    PropertyName[PropertyName[\"NChar\"] = 39] = \"NChar\";\n    PropertyName[PropertyName[\"Noncharacter_Code_Point\"] = 39] = \"Noncharacter_Code_Point\";\n    PropertyName[PropertyName[\"Pat_Syn\"] = 40] = \"Pat_Syn\";\n    PropertyName[PropertyName[\"Pattern_Syntax\"] = 40] = \"Pattern_Syntax\";\n    PropertyName[PropertyName[\"Pat_WS\"] = 41] = \"Pat_WS\";\n    PropertyName[PropertyName[\"Pattern_White_Space\"] = 41] = \"Pattern_White_Space\";\n    PropertyName[PropertyName[\"QMark\"] = 42] = \"QMark\";\n    PropertyName[PropertyName[\"Quotation_Mark\"] = 42] = \"Quotation_Mark\";\n    PropertyName[PropertyName[\"Radical\"] = 43] = \"Radical\";\n    PropertyName[PropertyName[\"RI\"] = 44] = \"RI\";\n    PropertyName[PropertyName[\"Regional_Indicator\"] = 44] = \"Regional_Indicator\";\n    PropertyName[PropertyName[\"STerm\"] = 45] = \"STerm\";\n    PropertyName[PropertyName[\"Sentence_Terminal\"] = 45] = \"Sentence_Terminal\";\n    PropertyName[PropertyName[\"SD\"] = 46] = \"SD\";\n    PropertyName[PropertyName[\"Soft_Dotted\"] = 46] = \"Soft_Dotted\";\n    PropertyName[PropertyName[\"Term\"] = 47] = \"Term\";\n    PropertyName[PropertyName[\"Terminal_Punctuation\"] = 47] = \"Terminal_Punctuation\";\n    PropertyName[PropertyName[\"UIdeo\"] = 48] = \"UIdeo\";\n    PropertyName[PropertyName[\"Unified_Ideograph\"] = 48] = \"Unified_Ideograph\";\n    PropertyName[PropertyName[\"Upper\"] = 49] = \"Upper\";\n    PropertyName[PropertyName[\"Uppercase\"] = 49] = \"Uppercase\";\n    PropertyName[PropertyName[\"VS\"] = 50] = \"VS\";\n    PropertyName[PropertyName[\"Variation_Selector\"] = 50] = \"Variation_Selector\";\n    PropertyName[PropertyName[\"space\"] = 51] = \"space\";\n    PropertyName[PropertyName[\"White_Space\"] = 51] = \"White_Space\";\n    PropertyName[PropertyName[\"XIDC\"] = 52] = \"XIDC\";\n    PropertyName[PropertyName[\"XID_Continue\"] = 52] = \"XID_Continue\";\n    PropertyName[PropertyName[\"XIDS\"] = 53] = \"XIDS\";\n    PropertyName[PropertyName[\"XID_Start\"] = 53] = \"XID_Start\";\n})(PropertyName || (PropertyName = {}));\nexport var PropertyValue;\n(function (PropertyValue) {\n    PropertyValue[PropertyValue[\"LC\"] = 0] = \"LC\";\n    PropertyValue[PropertyValue[\"Cased_Letter\"] = 0] = \"Cased_Letter\";\n    PropertyValue[PropertyValue[\"Pe\"] = 1] = \"Pe\";\n    PropertyValue[PropertyValue[\"Close_Punctuation\"] = 1] = \"Close_Punctuation\";\n    PropertyValue[PropertyValue[\"Pc\"] = 2] = \"Pc\";\n    PropertyValue[PropertyValue[\"Connector_Punctuation\"] = 2] = \"Connector_Punctuation\";\n    PropertyValue[PropertyValue[\"Cc\"] = 3] = \"Cc\";\n    PropertyValue[PropertyValue[\"cntrl\"] = 3] = \"cntrl\";\n    PropertyValue[PropertyValue[\"Control\"] = 3] = \"Control\";\n    PropertyValue[PropertyValue[\"Sc\"] = 4] = \"Sc\";\n    PropertyValue[PropertyValue[\"Currency_Symbol\"] = 4] = \"Currency_Symbol\";\n    PropertyValue[PropertyValue[\"Pd\"] = 5] = \"Pd\";\n    PropertyValue[PropertyValue[\"Dash_Punctuation\"] = 5] = \"Dash_Punctuation\";\n    PropertyValue[PropertyValue[\"Nd\"] = 6] = \"Nd\";\n    PropertyValue[PropertyValue[\"digit\"] = 6] = \"digit\";\n    PropertyValue[PropertyValue[\"Decimal_Number\"] = 6] = \"Decimal_Number\";\n    PropertyValue[PropertyValue[\"Me\"] = 7] = \"Me\";\n    PropertyValue[PropertyValue[\"Enclosing_Mark\"] = 7] = \"Enclosing_Mark\";\n    PropertyValue[PropertyValue[\"Pf\"] = 8] = \"Pf\";\n    PropertyValue[PropertyValue[\"Final_Punctuation\"] = 8] = \"Final_Punctuation\";\n    PropertyValue[PropertyValue[\"Cf\"] = 9] = \"Cf\";\n    PropertyValue[PropertyValue[\"Format\"] = 9] = \"Format\";\n    PropertyValue[PropertyValue[\"Pi\"] = 10] = \"Pi\";\n    PropertyValue[PropertyValue[\"Initial_Punctuation\"] = 10] = \"Initial_Punctuation\";\n    PropertyValue[PropertyValue[\"L\"] = 11] = \"L\";\n    PropertyValue[PropertyValue[\"Letter\"] = 11] = \"Letter\";\n    PropertyValue[PropertyValue[\"Nl\"] = 12] = \"Nl\";\n    PropertyValue[PropertyValue[\"Letter_Number\"] = 12] = \"Letter_Number\";\n    PropertyValue[PropertyValue[\"Zl\"] = 13] = \"Zl\";\n    PropertyValue[PropertyValue[\"Line_Separator\"] = 13] = \"Line_Separator\";\n    PropertyValue[PropertyValue[\"Ll\"] = 14] = \"Ll\";\n    PropertyValue[PropertyValue[\"Lowercase_Letter\"] = 14] = \"Lowercase_Letter\";\n    PropertyValue[PropertyValue[\"M\"] = 15] = \"M\";\n    PropertyValue[PropertyValue[\"Combining_Mark\"] = 15] = \"Combining_Mark\";\n    PropertyValue[PropertyValue[\"Mark\"] = 16] = \"Mark\";\n    PropertyValue[PropertyValue[\"Sm\"] = 17] = \"Sm\";\n    PropertyValue[PropertyValue[\"Math_Symbol\"] = 17] = \"Math_Symbol\";\n    PropertyValue[PropertyValue[\"Lm\"] = 18] = \"Lm\";\n    PropertyValue[PropertyValue[\"Modifier_Letter\"] = 18] = \"Modifier_Letter\";\n    PropertyValue[PropertyValue[\"Sk\"] = 19] = \"Sk\";\n    PropertyValue[PropertyValue[\"Modifier_Symbol\"] = 19] = \"Modifier_Symbol\";\n    PropertyValue[PropertyValue[\"Mn\"] = 20] = \"Mn\";\n    PropertyValue[PropertyValue[\"Nonspacing_Mark\"] = 20] = \"Nonspacing_Mark\";\n    PropertyValue[PropertyValue[\"N\"] = 21] = \"N\";\n    PropertyValue[PropertyValue[\"Number\"] = 21] = \"Number\";\n    PropertyValue[PropertyValue[\"Ps\"] = 22] = \"Ps\";\n    PropertyValue[PropertyValue[\"Open_Punctuation\"] = 22] = \"Open_Punctuation\";\n    PropertyValue[PropertyValue[\"C\"] = 23] = \"C\";\n    PropertyValue[PropertyValue[\"Other\"] = 23] = \"Other\";\n    PropertyValue[PropertyValue[\"Lo\"] = 24] = \"Lo\";\n    PropertyValue[PropertyValue[\"Other_Letter\"] = 24] = \"Other_Letter\";\n    PropertyValue[PropertyValue[\"No\"] = 25] = \"No\";\n    PropertyValue[PropertyValue[\"Other_Number\"] = 25] = \"Other_Number\";\n    PropertyValue[PropertyValue[\"Po\"] = 26] = \"Po\";\n    PropertyValue[PropertyValue[\"Other_Punctuation\"] = 26] = \"Other_Punctuation\";\n    PropertyValue[PropertyValue[\"So\"] = 27] = \"So\";\n    PropertyValue[PropertyValue[\"Other_Symbol\"] = 27] = \"Other_Symbol\";\n    PropertyValue[PropertyValue[\"Zp\"] = 28] = \"Zp\";\n    PropertyValue[PropertyValue[\"Paragraph_Separator\"] = 28] = \"Paragraph_Separator\";\n    PropertyValue[PropertyValue[\"Co\"] = 29] = \"Co\";\n    PropertyValue[PropertyValue[\"Private_Use\"] = 29] = \"Private_Use\";\n    PropertyValue[PropertyValue[\"P\"] = 30] = \"P\";\n    PropertyValue[PropertyValue[\"punct\"] = 30] = \"punct\";\n    PropertyValue[PropertyValue[\"Punctuation\"] = 30] = \"Punctuation\";\n    PropertyValue[PropertyValue[\"Z\"] = 31] = \"Z\";\n    PropertyValue[PropertyValue[\"Separator\"] = 31] = \"Separator\";\n    PropertyValue[PropertyValue[\"Zs\"] = 32] = \"Zs\";\n    PropertyValue[PropertyValue[\"Space_Separator\"] = 32] = \"Space_Separator\";\n    PropertyValue[PropertyValue[\"Mc\"] = 33] = \"Mc\";\n    PropertyValue[PropertyValue[\"Spacing_Mark\"] = 33] = \"Spacing_Mark\";\n    PropertyValue[PropertyValue[\"Cs\"] = 34] = \"Cs\";\n    PropertyValue[PropertyValue[\"Surrogate\"] = 34] = \"Surrogate\";\n    PropertyValue[PropertyValue[\"S\"] = 35] = \"S\";\n    PropertyValue[PropertyValue[\"Symbol\"] = 35] = \"Symbol\";\n    PropertyValue[PropertyValue[\"Lt\"] = 36] = \"Lt\";\n    PropertyValue[PropertyValue[\"Titlecase_Letter\"] = 36] = \"Titlecase_Letter\";\n    PropertyValue[PropertyValue[\"Cn\"] = 37] = \"Cn\";\n    PropertyValue[PropertyValue[\"Unassigned\"] = 37] = \"Unassigned\";\n    PropertyValue[PropertyValue[\"Lu\"] = 38] = \"Lu\";\n    PropertyValue[PropertyValue[\"Uppercase_Letter\"] = 38] = \"Uppercase_Letter\";\n})(PropertyValue || (PropertyValue = {}));\nexport function propertyNameFor(value) {\n    value = value.trim();\n    if (!(value in PropertyName)) {\n        throw new SyntaxError(\"Invalid property name: \" + value);\n    }\n    return PropertyName[value];\n}\nexport function propertyValueFor(value) {\n    value = value.trim();\n    if (!(value in PropertyValue)) {\n        throw new SyntaxError(\"Invalid property value: \" + value);\n    }\n    return PropertyValue[value];\n}\nexport function propertyNameString(value) {\n    if (!(value in PropertyName)) {\n        throw new Error(\"Invalid property name: \" + value);\n    }\n    return PropertyName[value];\n}\nexport function propertyValueString(value) {\n    if (!(value in PropertyValue)) {\n        throw new Error(\"Invalid property value: \" + value);\n    }\n    return PropertyValue[value];\n}\n//# sourceMappingURL=propertyescapes.js.map","import * as TSU from \"@panyam/tsutils\";\nimport { RegexType, CharType, } from \"./core\";\nimport { OpCode, Prog, Instr } from \"./vm\";\nexport class Compiler {\n    constructor(regexResolver, listener = null) {\n        this.regexResolver = regexResolver;\n        this.listener = listener;\n        this.emitGroups = false;\n        this.emitPosition = true;\n    }\n    compile(rules) {\n        const out = new Prog();\n        const split = rules.length <= 1 ? new Instr(OpCode.Split) : out.add(OpCode.Split, null);\n        rules.forEach((rule, i) => {\n            split.add(out.instrs.length);\n            const ignoreCase = rule.expr.ignoreCase == null ? false : rule.expr.ignoreCase;\n            const dotAll = rule.expr.dotAll == null ? true : rule.expr.dotAll;\n            const multiline = rule.expr.multiline == null ? true : rule.expr.multiline;\n            if (rule.needsSpecificStates && rule.activeStates != null) {\n                const ensureInstr = out.add(OpCode.EnsureState, null);\n                rule.activeStates.forEach((state) => {\n                    const ind = out.registerState(state);\n                    ensureInstr.add(ind);\n                });\n            }\n            this.compileExpr(rule.expr, out, ignoreCase, dotAll, multiline);\n            out.add(OpCode.Match, null).add(rule.priority, rule.matchIndex >= 0 ? rule.matchIndex : i);\n        });\n        return out;\n    }\n    compileExpr(expr, prog, ignoreCase, dotAll, multiline) {\n        const start = prog.length;\n        const currOffset = prog.length;\n        if (expr.groupIndex >= 0) {\n            if (this.emitPosition)\n                prog.add(OpCode.Save).add((1 + expr.groupIndex) * 2);\n            if (this.emitGroups)\n                prog.add(OpCode.GroupStart).add(1 + expr.groupIndex);\n        }\n        if (expr.tag == RegexType.CHAR) {\n            this.compileChar(expr, prog, ignoreCase, dotAll, multiline);\n        }\n        else if (expr.tag == RegexType.START_OF_INPUT) {\n            const ml = expr.multiline == null ? multiline : expr.multiline;\n            prog.add(ml ? OpCode.MLStartingChar : OpCode.StartingChar);\n        }\n        else if (expr.tag == RegexType.END_OF_INPUT) {\n            const ml = expr.multiline == null ? multiline : expr.multiline;\n            prog.add(ml ? OpCode.MLEndingChar : OpCode.EndingChar);\n        }\n        else if (expr.tag == RegexType.START_OF_WORD) {\n            prog.add(OpCode.StartOfWord);\n        }\n        else if (expr.tag == RegexType.END_OF_WORD) {\n            prog.add(OpCode.EndOfWord);\n        }\n        else if (expr.tag == RegexType.CAT) {\n            this.compileCat(expr, prog, ignoreCase, dotAll, multiline);\n        }\n        else if (expr.tag == RegexType.UNION) {\n            this.compileUnion(expr, prog, ignoreCase, dotAll, multiline);\n        }\n        else if (expr.tag == RegexType.QUANT) {\n            this.compileQuant(expr, prog, ignoreCase, dotAll, multiline);\n        }\n        else if (expr.tag == RegexType.VAR) {\n            this.compileVar(expr, prog, ignoreCase, dotAll, multiline);\n        }\n        else if (expr.tag == RegexType.BACK_NAMED_REF) {\n            this.compileBackNamedRef(expr, prog, ignoreCase, dotAll, multiline);\n        }\n        else if (expr.tag == RegexType.BACK_NUM_REF) {\n            this.compileBackNumRef(expr, prog, ignoreCase, dotAll, multiline);\n        }\n        else if (expr.tag == RegexType.LOOK_AHEAD) {\n            this.compileLookAhead(expr, prog, ignoreCase, dotAll, multiline);\n        }\n        else if (expr.tag == RegexType.LOOK_BACK) {\n            this.compileLookBack(expr, prog, ignoreCase, dotAll, multiline);\n        }\n        else {\n            throw new Error(\"Regex Type not yet supported: \" + expr.tag);\n        }\n        if (expr.groupIndex >= 0) {\n            if (this.emitGroups)\n                prog.add(OpCode.GroupEnd).add(1 + expr.groupIndex);\n            if (this.emitPosition)\n                prog.add(OpCode.Save).add((1 + expr.groupIndex) * 2 + 1);\n        }\n        if (this.listener && prog.length > currOffset) {\n            this.listener(expr, prog, currOffset, prog.length - currOffset);\n        }\n        return prog.length - start;\n    }\n    compileChar(char, prog, ignoreCase, dotAll, multiline) {\n        if (char.op == CharType.AnyChar) {\n            prog.add(dotAll ? OpCode.Any : OpCode.AnyNonNL);\n        }\n        else {\n            const instr = prog.add(ignoreCase ? OpCode.CIChar : OpCode.Char);\n            instr.char = char;\n        }\n    }\n    compileCat(cat, prog, ignoreCase, dotAll, multiline) {\n        for (const child of cat.children) {\n            this.compileExpr(child, prog, ignoreCase, dotAll, multiline);\n        }\n    }\n    compileBackNumRef(ne, prog, ignoreCase, dotAll, multiline) {\n        throw new Error(\"BackNumRef Not Implemented\");\n    }\n    compileBackNamedRef(ne, prog, ignoreCase, dotAll, multiline) {\n        throw new Error(\"BackNameRef Not Implemented\");\n    }\n    compileVar(v, prog, ignoreCase, dotAll, multiline) {\n        const name = v.name.trim();\n        const expr = this.regexResolver ? this.regexResolver(name) : null;\n        if (expr == null) {\n            throw new Error(`Cannot find expression: ${name}`);\n        }\n        this.compileExpr(expr, prog, ignoreCase, dotAll, multiline);\n    }\n    compileUnion(union, prog, ignoreCase, dotAll, multiline) {\n        const split = prog.add(OpCode.Split);\n        const jumps = [];\n        for (let i = 0; i < union.options.length; i++) {\n            split.add(prog.length);\n            this.compileExpr(union.options[i], prog, ignoreCase, dotAll, multiline);\n            if (i < union.options.length - 1) {\n                jumps.push(prog.add(OpCode.Jump));\n            }\n        }\n        for (const jmp of jumps) {\n            jmp.add(prog.length);\n        }\n    }\n    compileQuant(quant, prog, ignoreCase, dotAll, multiline) {\n        if (quant.minCount == 0 && quant.maxCount == TSU.Constants.MAX_INT) {\n            this.compileAtleast0(quant.expr, prog, quant.greedy, ignoreCase, dotAll, multiline);\n        }\n        else if (quant.minCount == 1 && quant.maxCount == TSU.Constants.MAX_INT) {\n            this.compileAtleast1(quant.expr, prog, quant.greedy, ignoreCase, dotAll, multiline);\n        }\n        else if (quant.minCount == 0 && quant.maxCount == 1) {\n            this.compileOptional(quant.expr, prog, quant.greedy, ignoreCase, dotAll, multiline);\n        }\n        else {\n            for (let i = 0; i < quant.minCount; i++) {\n                this.compileExpr(quant.expr, prog, ignoreCase, dotAll, multiline);\n            }\n            if (quant.isUnlimited) {\n                this.compileAtleast0(quant.expr, prog, quant.greedy, ignoreCase, dotAll, multiline);\n            }\n            else {\n                for (let i = quant.minCount; i < quant.maxCount; i++) {\n                    this.compileOptional(quant.expr, prog, quant.greedy, ignoreCase, dotAll, multiline);\n                }\n            }\n        }\n    }\n    compileAtleast1(expr, prog, greedy = true, ignoreCase, dotAll, multiline) {\n        const l1 = prog.length;\n        this.compileExpr(expr, prog, ignoreCase, dotAll, multiline);\n        const split = prog.add(OpCode.Split);\n        const l3 = prog.length;\n        if (greedy) {\n            split.add(l1, l3);\n        }\n        else {\n            split.add(l3, l1);\n        }\n    }\n    compileAtleast0(expr, prog, greedy, ignoreCase, dotAll, multiline) {\n        const split = prog.add(OpCode.Split);\n        const l1 = split.offset;\n        const l2 = prog.length;\n        this.compileExpr(expr, prog, ignoreCase, dotAll, multiline);\n        prog.add(OpCode.Jump).add(l1);\n        const l3 = prog.length;\n        if (greedy) {\n            split.add(l2, l3);\n        }\n        else {\n            split.add(l3, l2);\n        }\n    }\n    compileOptional(expr, prog, greedy, ignoreCase, dotAll, multiline) {\n        const split = prog.add(OpCode.Split);\n        const l1 = prog.length;\n        this.compileExpr(expr, prog, ignoreCase, dotAll, multiline);\n        const l2 = prog.length;\n        if (greedy) {\n            split.add(l1, l2);\n        }\n        else {\n            split.add(l2, l1);\n        }\n    }\n    compileLookAhead(la, prog, ignoreCase, dotAll, multiline) {\n        this.compileExpr(la.expr, prog, ignoreCase, dotAll, multiline);\n        const begin = prog.add(OpCode.Begin).add(0, la.negate ? 1 : 0);\n        this.compileExpr(la.cond, prog, ignoreCase, dotAll, multiline);\n        const end = prog.add(OpCode.End).add(begin.offset);\n        begin.add(end.offset);\n    }\n    compileLookBack(lb, prog, ignoreCase, dotAll, multiline) {\n        this.compileExpr(lb.expr, prog, ignoreCase, dotAll, multiline);\n        TSU.assert(lb.expr.groupIndex >= 0, \"LookBack Assertion requires expression to have a group Index\");\n        const begin = prog.add(OpCode.RBegin).add(lb.expr.groupIndex, lb.negate ? 1 : 0);\n        this.compileExpr(lb.cond.reverse(), prog, ignoreCase, dotAll, multiline);\n        const end = prog.add(OpCode.End).add(begin.offset);\n        begin.add(end.offset);\n    }\n}\n//# sourceMappingURL=compiler.js.map"],"names":["RegexType","CharType","Regex","constructor","this","parent","reString","groupIndex","groupName","groupIsSilent","ignoreCase","dotAll","multiline","setOptions","options","debugValue","out","isVariable","toString","evalREString","modifiers","mod","length","StartOfInput","super","arguments","tag","START_OF_INPUT","reverse","EndOfInput","END_OF_INPUT","Assertion","expr","cond","negate","LookAhead","LOOK_AHEAD","LookBack","LOOK_BACK","Quant","minCount","maxCount","greedy","QUANT","isUnlimited","quant","Cat","children","CAT","child","add","map","c","join","push","opt","Union","UNION","option","Char","op","neg","CHAR","match","ch","result","matchChar","LeafChar","args","Any","AnyChar","Class","charClass","CharClass","Single","charCodeAt","SingleChar","PropertyEscape","propNameOrId","propValueOrId","matches","Error","compareTo","another","i","String","fromCharCode","replace","CharGroup","chars","d","CharRange","Intersection","Range","start","end","Var","name","reversed","VAR","BackNamedRef","BACK_NAMED_REF","BackRef","BackNumRef","num","BACK_NUM_REF","Rule","config","skip","priority","matchIndex","activeStates","stateCanActivate","state","size","has","needsSpecificStates","advanceIf","tape","pos","index","currCh","charAt","advance","RegexParser","counter","parse","pattern","ignoreSpaces","obCount","stack","hasMore","x","prev","reduceLeft","rest","parseCharGroup","parseQuant","nextCh","throwError","ignoreSpaces2","next","subExpr","parseChar","Math","min","max","foundComma","p1","p2","trim","part1","parseInt","part2","isNaN","last","currch","endch","parseEscapeChar","parseSingleChar","parsePropertyEscape","foundEq","propName","propValue","WORD_CHAR","DIGITS","SPACES","hexSeq","hexVal","canAdvance","ucodeSeq","substring","ucodeVal","r","splice","msg","TokenizerError","message","offset","type","value","Object","setPrototypeOf","prototype","UnexpectedTokenError","foundToken","expectedTokens","TapeInterface","forward","delta","hasIndex","prevCh","currChCode","currChCodeLower","toLowerCase","currChCodeUpper","toUpperCase","charCodeAtLower","charCodeAtUpper","Tape","input","_rawInput","content","startIndex","endIndex","Token","id","idCounter","groups","positions","lookahead","lookback","isOneOf","expected","tok","TokenBuffer","nextToken","tokenizerContext","buffer","peek","consume","nth","matchFunc","ensure","nextAction","token","consumeIf","t","expectToken","ensureToken","nextMatches","OpCode","isNewLineChar","Match","Prog","startCondition","scIsInclusive","instrs","stateMapping","Map","registerState","set","get","opcode","char","Instr","initializer","instrDebugValue","InstrDebugValue","instr","comment","Thread","gen","parentId","registers","regIncr","regId","regAcquire","regRelease","regValue","VM","getState","currState","setState","prog","configs","threadCounter","currThreads","nextThreads","startPos","genForOffset","savePosition","thread","tapeIndex","jumpBy","jumpTo","newOffset","forkTo","startGroup","newThread","endGroup","addThread","list","lastCh","Jump","Split","j","newOff","Save","tracer","threadQueued","GroupStart","GroupEnd","StartingChar","MLStartingChar","EndingChar","MLEndingChar","StartOfWord","EndOfWord","RBegin","groupStart","matchSuccess","matchEnd","recurseMatch","Begin","EnsureState","states","matchCurrPos","startMatching","bestMatch","stepChar","startOffset","endOffset","savedPos","newPos","currMatch","nextMatch","stepThread","threadStepped","advanceTape","End","currPriority","CIChar","AnyNonNL","GroupCounter","current","isSpace","logParserDebug","parser","itemGraph","g","grammar","ptable","parseTable","console","log","JSON","stringify","merged","ptabDV","igDV","stateId","actions","items","goto","mergedDebugValue","conflictActions","unicode","SyntaxError","curr","refNum","gtPos","clPos","parseGroup","nchars","depth","after","clEnd","eqPos","propStr","parts","split","indexOf","sub","assert","condition","MAX_INT","pow","TEvent","source","payload","uuid","_spawnedFrom","sourceState","cancelled","timeStamp","spawnedFrom","setSpawnedFrom","_rootEvent","rootEvent","spawn","State","stateData","enter","data","handle","event","EventHub","_handlers","_events","_inBatchMode","on","names","callback","_addHandler","removeOn","_removeHandler","_ensurestrings","v","handlerlist","handler","forEach","evHandlers","emit","evt","dispatchEvent","evtCallbacks","startBatchMode","cancelBatch","commitBatch","BATCH_EVENTS","gcdof","y","abs","IS_EXPLORER","navigator","userAgent","IS_FIREFOX","IS_OPERA","UAHasChrome","UAHasSafari","IS_SAFARI","IS_CHROME","Fraction","den","factorized","gcd","val","isWhole","isZero","isInfinity","isOne","ceil","floor","plus","plusNum","minus","minusNum","times","timesNum","divby","divbyNum","numDivby","floorOfD","modNum","inverse","equals","equalsNum","cmp","cmpNum","isLT","isLTE","isLTNum","isLTENum","isGT","isGTE","isGTNum","isGTENum","f1","f2","ZERO","ONE","INFINITY","CharClassType","NINE","lA","lZ","uA","uZ","USCORE","CharClassHelper","charCode","res","CharClassHelpers","spaceChars","PropertyName","PropertyValue","propertyNameFor","propertyValueFor","Compiler","regexResolver","listener","emitGroups","emitPosition","compile","rules","rule","ensureInstr","ind","compileExpr","currOffset","compileChar","ml","START_OF_WORD","END_OF_WORD","compileCat","compileUnion","compileQuant","compileVar","compileBackNamedRef","compileBackNumRef","compileLookAhead","compileLookBack","cat","ne","union","jumps","jmp","compileAtleast0","compileAtleast1","compileOptional","l1","l3","l2","la","begin","lb"],"ignoreList":[],"sourceRoot":""}