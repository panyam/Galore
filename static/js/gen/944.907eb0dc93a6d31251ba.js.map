{"version":3,"file":"944.907eb0dc93a6d31251ba.js","mappings":"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","sources":["webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/parser.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/analyzer.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/grammar.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/ll.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/dsl.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/ptables.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/utils.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/lr.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/sets.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/graph.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/factory.js","webpack://galore/./node_modules/.pnpm/tlex@1.0.2/node_modules/tlex/lib/esm/builder.js","webpack://galore/./node_modules/.pnpm/tlex@1.0.2/node_modules/tlex/lib/esm/tokenizer.js","webpack://galore/./node_modules/.pnpm/tlex@1.0.2/node_modules/tlex/lib/esm/samples.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/lritems.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/errors.js","webpack://galore/./node_modules/.pnpm/galore@file+../node_modules/galore/lib/esm/printers.js"],"sourcesContent":["import * as TLEX from \"tlex\";\nexport class PFNode {\n    constructor(id, sym, value, ...children) {\n        this.id = id;\n        this.sym = sym;\n        this.value = value;\n        this.children = [];\n        this.children = children || [];\n    }\n    get childCount() {\n        return this.children.length;\n    }\n    childAt(index) {\n        if (index < 0)\n            return this.children[this.children.length + index];\n        return this.children[index];\n    }\n    get isTerminal() {\n        return this.sym.isTerminal;\n    }\n    add(node, index = -1) {\n        if (this.isTerminal) {\n            throw new Error(`Cannot add children (${node.sym.label}) to a terminal node: ${this.sym.label}`);\n        }\n        if (index < 0) {\n            this.children.push(node);\n        }\n        else {\n            this.children.splice(index, 0, node);\n        }\n        return this;\n    }\n    splice(index, numToDelete, ...nodes) {\n        this.children.splice(index, numToDelete, ...nodes);\n        return this;\n    }\n    get reprString() {\n        return this.debugValue(false).join(\"\\n\");\n    }\n    debugValue(raw = true) {\n        if (raw) {\n            const out = [this.sym.label];\n            if (this.value)\n                out.push(this.value);\n            if (this.children.length > 0)\n                out.push(this.children.map((c) => c.debugValue(raw)));\n            return out;\n        }\n        else {\n            const out = [];\n            const value = this.value;\n            out.push(this.value == null ? this.sym.label : this.sym.label + \" - \" + this.value);\n            this.children.forEach((node) => node.debugValue(raw).forEach((l) => out.push(\"  \" + l)));\n            return out;\n        }\n    }\n}\nexport class PTNode extends PFNode {\n    constructor() {\n        super(...arguments);\n        this.parent = null;\n    }\n    add(node, index = -1) {\n        super.add(node, index);\n        node.parent = this;\n        return this;\n    }\n    splice(index, numToDelete, ...nodes) {\n        for (const node of nodes)\n            node.parent = this;\n        return super.splice(index, numToDelete, ...nodes);\n    }\n}\nexport class ParserBase {\n    setTokenizer(tokenizer) {\n        this.tokenbuffer = new TLEX.TokenBuffer(tokenizer, null);\n        return this;\n    }\n    getSym(token) {\n        const out = this.grammar.getSym(token.tag);\n        if (out == null) {\n            throw new Error(\"Invalid token tag: \" + token.tag + \", Value: \" + token.value);\n        }\n        return out;\n    }\n}\nexport class SimpleParser extends ParserBase {\n    parse(input, delegate = null) {\n        if (typeof input === \"string\") {\n            input = new TLEX.Tape(input);\n        }\n        return this.parseInput(input, delegate);\n    }\n}\nexport class ParallelParser extends ParserBase {\n    parse(input, delegate = null) {\n        if (typeof input === \"string\") {\n            input = new TLEX.Tape(input);\n        }\n        return this.parseInput(input, delegate);\n    }\n}\n//# sourceMappingURL=parser.js.map","import * as TSU from \"@panyam/tsutils\";\nimport { Str } from \"./grammar\";\nimport { Trie } from \"./sets\";\nexport function removeUselessSymbols(g, fromSymbol = null) {\n    const derives_terminal = g.terminalDerivingSymbols;\n    g.removeRules((r) => !derives_terminal.has(r.nt) || r.rhs.syms.findIndex((s) => !s.isTerminal && !derives_terminal.has(s)) >= 0);\n    g.refresh();\n    const reachable_symbols = g.reachableSymbols(fromSymbol);\n    g.removeRules((r) => !reachable_symbols.has(r.nt) || r.rhs.syms.findIndex((s) => !s.isTerminal && !reachable_symbols.has(s)) >= 0);\n    g.refresh();\n}\nexport function expandNullProductions(grammar, str, results) {\n    results = results || {};\n    if (str.length > 0) {\n        const nullables = grammar.nullables;\n        const key = str.toString();\n        if (!(key in results)) {\n            results[key] = str;\n            str.syms.forEach((sym, index) => {\n                if (nullables.isNullable(sym)) {\n                    const newStr = str.copy().splice(index, 1);\n                    expandNullProductions(grammar, newStr, results);\n                }\n            });\n        }\n    }\n    return results;\n}\nexport function removeNullProductions(grammar, nt = null) {\n    if (nt == null) {\n        grammar.forEachNT((nt) => removeNullProductions(grammar, nt));\n    }\n    else {\n        const results = {};\n        grammar.rulesForNT(nt).forEach((r) => expandNullProductions(grammar, r.rhs, results));\n        grammar.removeRules((r) => r.nt == nt);\n        for (const key in results) {\n            grammar.add(nt, results[key]);\n        }\n        grammar.removeRules((r) => r.nt == nt && r.rhs.length == 0);\n    }\n}\nexport function removeCycles(grammar) {\n    removeNullProductions(grammar);\n}\nexport function hasDirectLeftRecursion(sym, grammar) {\n    return false;\n}\nexport function leftFactor(grammar, nt = null) {\n    if (nt == null) {\n        grammar.forEachNT((nt) => leftFactor(grammar, nt));\n    }\n    else {\n        const symTrie = new Trie((s) => s.label);\n        grammar.forEachRule(nt, (rule) => {\n            symTrie.add(rule.rhs.syms);\n        });\n        const x = symTrie.debugValue;\n        grammar.removeRules((r) => r.nt == nt);\n        const lf = (curr, nt, prefix) => {\n            if (curr.children.size == 0) {\n                const a = 3;\n                if (prefix.length > 0)\n                    grammar.add(nt, prefix.copy());\n            }\n            else if (curr.children.size == 1 && !curr.isLeaf) {\n                const childNode = curr.children.values().next().value;\n                TSU.assert(childNode.value != null);\n                lf(childNode, nt, prefix.append(childNode.value));\n            }\n            else {\n                const newSym = curr.children.size > 0 ? grammar.newAuxNT() : null;\n                prefix = prefix.copy();\n                grammar.add(nt, newSym == null ? prefix : prefix.append(newSym));\n                if (curr.isLeaf && newSym != null) {\n                    grammar.add(newSym, new Str());\n                }\n                if (newSym != null) {\n                    for (const child of curr.children.values()) {\n                        TSU.assert(child.value != null);\n                        lf(child, newSym, new Str(child.value));\n                    }\n                }\n            }\n        };\n        for (const child of symTrie.root.children.values()) {\n            lf(child, nt, new Str(child.value));\n        }\n    }\n}\nexport function removeDirectLeftRecursion(grammar, nt = null) {\n    if (nt == null) {\n        grammar.forEachNT((nt) => removeDirectLeftRecursion(grammar, nt));\n    }\n    else {\n        const lrecRules = [];\n        const betaRules = [];\n        grammar.rulesForNT(nt).forEach((rule) => {\n            if (rule.rhs.length > 0 && rule.rhs.syms[0] == nt) {\n                lrecRules.push(rule.rhs.slice(1, rule.rhs.length));\n            }\n            else {\n                betaRules.push(rule.rhs);\n            }\n        });\n        if (lrecRules.length == 0)\n            return;\n        grammar.removeRules((r) => r.nt == nt);\n        const auxSym = grammar.newAuxNT();\n        for (const rule of betaRules) {\n            grammar.add(nt, rule.copy().append(auxSym));\n        }\n        grammar.add(auxSym, new Str());\n        for (const rule of lrecRules) {\n            grammar.add(auxSym, rule.copy().append(auxSym));\n        }\n    }\n}\nexport function removeIndirectLeftRecursion(grammar) {\n    TSU.assert(false, \"Not yet implemented\");\n}\n//# sourceMappingURL=analyzer.js.map","import * as TSU from \"@panyam/tsutils\";\nimport { allMinimalCycles } from \"./graph\";\nimport { IDSet, SymbolSet, FollowSets } from \"./sets\";\nexport class Sym {\n    constructor(grammar, label, isTerminal, id = null) {\n        this.grammar = grammar;\n        this.label = label;\n        this.isTerminal = isTerminal;\n        this.isAuxiliary = false;\n        this.auxType = null;\n        this.precedence = 1;\n        this.assocLeft = true;\n        this.creationId = -1;\n        this.isTerminal = isTerminal;\n        this.label = label;\n        if (id == null) {\n            this.id = Sym.idCounter--;\n        }\n        else {\n            this.id = id;\n        }\n    }\n    compareTo(another) {\n        return this.label.localeCompare(another.label);\n    }\n    equals(another) {\n        return this.label == another.label;\n    }\n    toString() {\n        return this.label;\n    }\n}\nSym.idCounter = -1;\nexport class Str {\n    constructor(...syms) {\n        this.syms = syms || [];\n    }\n    append(...lits) {\n        for (const l of lits)\n            this.syms.push(l);\n        return this;\n    }\n    extend(...strs) {\n        for (const s of strs)\n            this.append(...s.syms);\n        return this;\n    }\n    copy() {\n        return new Str(...this.syms);\n    }\n    add(lit) {\n        this.syms.push(lit);\n    }\n    isTerminal(index) {\n        return this.syms[index].isTerminal;\n    }\n    get length() {\n        return this.syms.length;\n    }\n    toString() {\n        return this.syms.map((s) => s.toString()).join(\" \");\n    }\n    slice(startIndex, endIndex) {\n        return new Str(...this.syms.slice(startIndex, endIndex));\n    }\n    splice(index, numToDelete, ...itemsToAdd) {\n        this.syms.splice(index, numToDelete, ...itemsToAdd);\n        return this;\n    }\n    compareTo(another) {\n        for (let i = 0; i < this.syms.length && i < another.syms.length; i++) {\n            const diff = this.syms[i].compareTo(another.syms[i]);\n            if (diff != 0)\n                return diff;\n        }\n        return this.syms.length - another.syms.length;\n    }\n    equals(another) {\n        return this.compareTo(another) == 0;\n    }\n    containsAt(offset, another) {\n        let i = 0;\n        for (; i < another.length && offset + i < this.syms.length; i++) {\n            if (!this.syms[offset + i].equals(another.syms[i]))\n                return false;\n        }\n        return i == another.length;\n    }\n    get debugString() {\n        return this.syms.map((lit) => lit.label).join(\" \");\n    }\n}\nexport class RuleAction {\n    constructor(value) {\n        this.value = value;\n    }\n    get isFunction() {\n        return typeof this.value === \"string\";\n    }\n    get isChildPosition() {\n        return typeof this.value === \"number\";\n    }\n}\nexport class Rule {\n    constructor(nt, rhs, action = null) {\n        this.nt = nt;\n        this.rhs = rhs;\n        this.action = action;\n        if (nt.isTerminal) {\n            throw new Error(\"Cannot add rules to a terminal\");\n        }\n    }\n    get debugString() {\n        return `${this.nt.label} -> ${this.rhs.debugString}`;\n    }\n    equals(another) {\n        return this.compareTo(another) == 0;\n    }\n    compareTo(another) {\n        TSU.assert(!isNaN(this.id));\n        const diff = this.nt.compareTo(another.nt);\n        if (diff == 0) {\n            this.rhs.compareTo(another.rhs);\n        }\n        return diff;\n    }\n}\nexport class Grammar {\n    static make(callback) {\n        const g = new Grammar();\n        callback(g);\n        return g;\n    }\n    constructor(config) {\n        this.startSymbol = null;\n        this.modified = true;\n        this.symbolSet = new IDSet((s) => s.label);\n        this.allRules = [];\n        this._rulesForNT = null;\n        this._followSets = null;\n        this._hasNull = false;\n        this.auxNTCount = 0;\n        config = config || {};\n        this.auxNTPrefix = config.auxNTPrefix || \"$\";\n        this.Null = this.newTerm(\"\");\n        this.Eof = this.newTerm(\"$end\");\n    }\n    rulesForNT(nt) {\n        TSU.assert(!nt.isTerminal);\n        if (this._rulesForNT == null) {\n            this._rulesForNT = {};\n            for (const rule of this.allRules) {\n                if (!(rule.nt.label in this._rulesForNT)) {\n                    this._rulesForNT[rule.nt.label] = [];\n                }\n                this._rulesForNT[rule.nt.label].push(rule);\n            }\n        }\n        if (!(nt.label in this._rulesForNT)) {\n            this._rulesForNT[nt.label] = [];\n        }\n        return this._rulesForNT[nt.label];\n    }\n    get nullables() {\n        return this.firstSets.nullables;\n    }\n    get firstSets() {\n        return this.followSets.firstSets;\n    }\n    get followSets() {\n        if (this.modified || this._followSets == null) {\n            this.refresh();\n        }\n        TSU.assert(this._followSets != null);\n        return this._followSets;\n    }\n    get augStartRule() {\n        return this._AugStartRule;\n    }\n    augmentStartSymbol(label = \"$accept\") {\n        TSU.assert(this._AugStartRule == null, \"Ensure this grammar has not yet been augmented.\");\n        TSU.assert(this.startSymbol != null, \"Start symbol not yet set\");\n        const augSym = this.newNT(label);\n        this._AugStartRule = new Rule(augSym, new Str(this.startSymbol));\n        this.addRule(this._AugStartRule, 0);\n        return this;\n    }\n    refresh() {\n        this.symbolSet.entries.forEach((s, i) => (s.id = i));\n        this._rulesForNT = null;\n        this.allRules.forEach((rule, i) => {\n            rule.id = i;\n        });\n        this._followSets = new FollowSets(this);\n        this.modified = false;\n        return this;\n    }\n    addTerminals(...terminals) {\n        for (const t of terminals) {\n            this.newTerm(t);\n        }\n    }\n    get terminals() {\n        return this.symbolSet.entries.filter((x) => x.isTerminal);\n    }\n    get allNonTerminals() {\n        return this.symbolSet.entries.filter((x) => !x.isTerminal);\n    }\n    get nonTerminals() {\n        return this.symbolSet.entries.filter((x) => !x.isTerminal && !x.isAuxiliary);\n    }\n    get auxNonTerminals() {\n        return this.symbolSet.entries.filter((x) => x.isAuxiliary);\n    }\n    get allSymbols() {\n        return this.symbolSet.entries;\n    }\n    forEachNT(visitor) {\n        for (const sym of this.symbolSet.entries) {\n            if (sym.isTerminal)\n                continue;\n            if (visitor(sym) == false)\n                return;\n        }\n    }\n    forEachRule(nt, visitor) {\n        const rules = nt == null ? this.allRules : this.rulesForNT(nt) || [];\n        for (let i = 0; i < rules.length; i++) {\n            if (visitor(rules[i], i) == false)\n                return false;\n        }\n        return true;\n    }\n    getRule(nt, index) {\n        if (typeof nt === \"string\")\n            nt = this.getSym(nt);\n        TSU.assert(nt != null);\n        return this.rulesForNT(nt)[index];\n    }\n    findRule(nt, production) {\n        return this.rulesForNT(nt).findIndex((r) => r.nt == nt && r.rhs.equals(production));\n    }\n    add(nt, production, action = null) {\n        let nonterm = null;\n        if (typeof nt === \"string\") {\n            nonterm = this.getSym(nt);\n            if (nonterm == null) {\n                nonterm = this.newNT(nt);\n            }\n        }\n        else {\n            nonterm = this.ensureSym(nt);\n        }\n        return this.addRule(new Rule(nonterm, production, action));\n    }\n    addRule(rule, index = -1) {\n        if (this.findRule(rule.nt, rule.rhs) >= 0) {\n            throw new Error(\"Duplicate rule: \" + rule.debugString);\n        }\n        rule.id = this.allRules.length;\n        if (rule.rhs.length == 0)\n            this._hasNull = true;\n        if (index < 0) {\n            this.allRules.push(rule);\n        }\n        else {\n            this.allRules.splice(index, 0, rule);\n        }\n        this._rulesForNT = null;\n        this.modified = true;\n        return rule;\n    }\n    removeRules(pred) {\n        this.allRules = this.allRules.filter((r) => !pred(r));\n        this._rulesForNT = null;\n        this.modified = true;\n        return true;\n    }\n    removeSymbols(pred) {\n        let modified = false;\n        const newRules = [];\n        this.allRules.forEach((r) => {\n            if (pred(r.nt))\n                return;\n            if (r.rhs.length == 0) {\n                newRules.push(r);\n            }\n            else {\n                const newRhs = new Str(...r.rhs.syms.filter((s) => !pred(s)));\n                modified = modified || r.rhs.length != newRhs.length;\n                if (newRhs.length > 0) {\n                    newRules.push(new Rule(r.nt, newRhs));\n                }\n            }\n        });\n        this.allRules = newRules;\n        modified = this.symbolSet.remove(pred) || modified;\n        this.modified = this.modified || modified;\n        return modified;\n    }\n    getSymById(id) {\n        return this.symbolSet.get(id);\n    }\n    getSym(label) {\n        return this.symbolSet.getByKey(label);\n    }\n    ensureSym(sym, throwIfExists = false) {\n        const sym2 = this.symbolSet.ensure(sym, throwIfExists);\n        if (sym == sym2) {\n            if (sym2.creationId < 0) {\n                sym2.creationId = this.symbolSet.size;\n            }\n        }\n        else {\n            TSU.assert(!throwIfExists, \"Should have already thrown error\");\n        }\n        return sym2;\n    }\n    T(label, throwIfExists = false) {\n        let t = this.getSym(label);\n        if (t != null) {\n            if (throwIfExists)\n                throw new Error(`Terminal ${label} is already exists`);\n            if (!t.isTerminal)\n                throw new Error(`Symbol (${label}) already exists as a non-terminal`);\n        }\n        else {\n            t = new Sym(this, label, true);\n            t = this.ensureSym(t, true);\n        }\n        return t;\n    }\n    NT(label, isAuxiliary = false, throwIfExists = false) {\n        let nt = this.getSym(label);\n        if (nt != null) {\n            if (throwIfExists)\n                throw new Error(`Non-terminal ${label} is already exists`);\n            if (nt.isTerminal)\n                throw new Error(`Symbol (${label}) already exists as a terminal`);\n        }\n        else {\n            nt = new Sym(this, label, false);\n            nt.isAuxiliary = isAuxiliary;\n            nt = this.ensureSym(nt, true);\n            if (!isAuxiliary && this.startSymbol == null) {\n                this.startSymbol = nt;\n            }\n        }\n        return nt;\n    }\n    newTerm(label) {\n        return this.T(label, true);\n    }\n    newNT(label, isAuxiliary = false) {\n        return this.NT(label, isAuxiliary, true);\n    }\n    isTerminal(label) {\n        const t = this.getSym(label);\n        return t != null && t.isTerminal;\n    }\n    isNT(label) {\n        const t = this.getSym(label);\n        return t != null && !t.isTerminal && !t.isAuxiliary;\n    }\n    isAuxNT(label) {\n        const t = this.getSym(label);\n        return t != null && !t.isTerminal && t.isAuxiliary;\n    }\n    seq(...exps) {\n        if (exps.length == 1) {\n            return this.normalizeRule(exps[0]);\n        }\n        else {\n            const out = new Str();\n            for (const e of exps) {\n                const s = this.normalizeRule(e);\n                for (let i = 0; i < s.length; i++) {\n                    out.add(s.syms[i]);\n                }\n            }\n            return out;\n        }\n    }\n    anyof(...rules) {\n        if (rules.length == 1) {\n            return this.normalizeRule(rules[0]);\n        }\n        else {\n            return new Str(this.ensureAuxNT(...rules.map((r) => this.normalizeRule(r))));\n        }\n    }\n    opt(exp) {\n        const out = this.anyof(exp, new Str());\n        const nt = out.syms[0];\n        TSU.assert(out.syms.length == 1 && nt.isAuxiliary, \"NT must be an auxiliary symbol\");\n        nt.auxType = \"opt\";\n        return out;\n    }\n    atleast0(exp, leftRec = true) {\n        const s = this.normalizeRule(exp);\n        let auxNT = this.findAuxNT((auxNT) => {\n            const rules = this.rulesForNT(auxNT);\n            if (rules.length != 2)\n                return false;\n            let which = 0;\n            if (rules[0].rhs.length == 0) {\n                which = 1;\n            }\n            else if (rules[1].rhs.length == 0) {\n                which = 0;\n            }\n            else {\n                return false;\n            }\n            const rule = rules[which].rhs;\n            if (rule.length != 1 + exp.length)\n                return false;\n            if (rule.syms[0].equals(auxNT)) {\n                return rule.containsAt(1, s);\n            }\n            else if (rule.syms[rule.length - 1].equals(auxNT)) {\n                return rule.containsAt(0, s);\n            }\n            return false;\n        });\n        if (auxNT == null) {\n            auxNT = this.newAuxNT();\n            auxNT.auxType = leftRec ? \"atleast0:left\" : \"atleast0\";\n            this.add(auxNT, new Str());\n            if (leftRec) {\n                this.add(auxNT, new Str(auxNT).extend(s));\n            }\n            else {\n                this.add(auxNT, s.copy().append(auxNT));\n            }\n        }\n        return new Str(auxNT);\n    }\n    atleast1(exp, leftRec = true) {\n        const s = this.normalizeRule(exp);\n        let auxNT = this.findAuxNT((auxNT) => {\n            const rules = this.rulesForNT(auxNT);\n            if (rules.length != 2)\n                return false;\n            let which = 0;\n            if (rules[0].rhs.equals(s)) {\n                which = 1;\n            }\n            else if (rules[1].rhs.equals(s)) {\n                which = 0;\n            }\n            else {\n                return false;\n            }\n            const rule = rules[which].rhs;\n            if (rule.length != 1 + exp.length)\n                return false;\n            if (rule.syms[0].equals(auxNT)) {\n                return rule.containsAt(1, s);\n            }\n            else if (rule.syms[rule.length - 1].equals(auxNT)) {\n                return rule.containsAt(0, s);\n            }\n            return false;\n        });\n        if (auxNT == null) {\n            auxNT = this.newAuxNT();\n            auxNT.auxType = leftRec ? \"atleast1:left\" : \"atleast1\";\n            this.add(auxNT, s);\n            if (leftRec) {\n                this.add(auxNT, new Str(auxNT).extend(s));\n            }\n            else {\n                this.add(auxNT, s.copy().append(auxNT));\n            }\n        }\n        return new Str(auxNT);\n    }\n    normalizeRule(exp) {\n        if (typeof exp === \"string\") {\n            const lit = this.getSym(exp);\n            if (lit == null)\n                throw new Error(`Invalid symbol: '${exp}'`);\n            return new Str(lit);\n        }\n        else {\n            return exp;\n        }\n    }\n    newAuxNTName() {\n        return this.auxNTPrefix + this.auxNTCount++;\n    }\n    newAuxNT(name = \"\") {\n        if (name == \"\")\n            name = this.newAuxNTName();\n        return this.newNT(name, true);\n    }\n    ensureAuxNT(...rules) {\n        let nt = this.findAuxNTByRules(...rules);\n        if (nt == null) {\n            nt = this.newAuxNT();\n            nt.auxType = \"anyof\";\n            for (const rule of rules)\n                this.add(nt, rule);\n        }\n        return nt;\n    }\n    findAuxNT(filter) {\n        for (const auxNT of this.symbolSet.entries) {\n            if (!auxNT.isAuxiliary)\n                continue;\n            if (filter(auxNT))\n                return auxNT;\n        }\n        return null;\n    }\n    findAuxNTByRules(...rules) {\n        return this.findAuxNT((auxNT) => {\n            const ntRules = this.rulesForNT(auxNT);\n            if (ntRules.length != rules.length)\n                return false;\n            for (let i = 0; i < ntRules.length; i++) {\n                if (!ntRules[i].rhs.equals(rules[i]))\n                    return false;\n            }\n            return true;\n        });\n    }\n    print(options = null) {\n        options = options || {};\n        const ruleSep = options.ruleSep || \"->\";\n        const includeSemiColon = options.includeSemiColon || false;\n        const lambdaSymbol = options.lambdaSymbol || \"\";\n        const out = [];\n        this.forEachRule(null, (rule, index) => {\n            let r = `${rule.nt.label} ${ruleSep} `;\n            if (rule.rhs.length > 0)\n                r += rule.rhs.debugString;\n            else\n                r += lambdaSymbol;\n            if (includeSemiColon)\n                r += \" ;\";\n            out.push(r);\n        });\n        return out;\n    }\n    get debugValue() {\n        const out = [];\n        this.forEachRule(null, (rule, index) => {\n            out.push(`${rule.nt.label} -> ${rule.rhs.debugString}`);\n        });\n        return out;\n    }\n    get terminalDerivingSymbols() {\n        const out = new SymbolSet(this, null);\n        let nadded = -1;\n        let allDerive = true;\n        while (nadded != 0) {\n            nadded = 0;\n            for (const rule of this.allRules) {\n                allDerive = true;\n                for (const sym of rule.rhs.syms) {\n                    if (!out.has(sym)) {\n                        if (sym.isTerminal) {\n                            out.add(sym);\n                            nadded++;\n                        }\n                        else {\n                            allDerive = false;\n                        }\n                    }\n                }\n                if (allDerive && !out.has(rule.nt)) {\n                    out.add(rule.nt);\n                    nadded++;\n                }\n            }\n        }\n        return out;\n    }\n    reachableSymbols(fromSymbol = null) {\n        if (fromSymbol == null) {\n            fromSymbol = this._AugStartRule ? this._AugStartRule.nt : this.startSymbol;\n        }\n        TSU.assert(fromSymbol != null, \"Start symbol does not exist\");\n        const reachable = new SymbolSet(this, false).add(fromSymbol);\n        let queue = [fromSymbol];\n        while (queue.length > 0) {\n            const newQueue = [];\n            for (const curr of queue) {\n                for (const rule of this.rulesForNT(curr)) {\n                    for (const sym of rule.rhs.syms) {\n                        if (!sym.isTerminal && !reachable.has(sym)) {\n                            newQueue.push(sym);\n                            reachable.add(sym);\n                        }\n                    }\n                }\n            }\n            queue = newQueue;\n        }\n        return reachable;\n    }\n    get cycles() {\n        const edgeFunctor = (node) => {\n            const out = [];\n            this.forEachRule(node, (rule, ruleIndex) => {\n                rule.rhs.syms.forEach((s, j) => {\n                    if (s.isTerminal)\n                        return;\n                    if (this.nullables.isStrNullable(rule.rhs, 0, j - 1) && this.nullables.isStrNullable(rule.rhs, j + 1)) {\n                        out.push([s, [node, ruleIndex]]);\n                    }\n                });\n            });\n            return out;\n        };\n        return allMinimalCycles(this.allNonTerminals, (val) => val.label, edgeFunctor);\n    }\n    get leftRecursion() {\n        const edgeFunctor = (node) => {\n            const out = [];\n            this.forEachRule(node, (rule, ruleIndex) => {\n                rule.rhs.syms.forEach((s, j) => {\n                    if (s.isTerminal)\n                        return;\n                    out.push([s, ruleIndex]);\n                    return this.nullables.isNullable(s);\n                });\n            });\n            return out;\n        };\n        return allMinimalCycles(this.allNonTerminals, (val) => val.id, edgeFunctor);\n    }\n}\n//# sourceMappingURL=grammar.js.map","import * as TSU from \"@panyam/tsutils\";\nimport { Sym } from \"./grammar\";\nimport { PTNode, SimpleParser as ParserBase } from \"./parser\";\nimport { printGrammar } from \"./utils\";\nexport class ParseTable {\n    constructor(grammar) {\n        this.grammar = grammar;\n        this.refresh();\n    }\n    refresh() {\n        this.entries = new Map();\n        this.grammar.followSets.refresh();\n        this.grammar.forEachRule(null, (rule, index) => {\n            this.processRule(rule, index);\n        });\n        const printed = printGrammar(this.grammar, false);\n        const t1 = this.grammar.cycles;\n        const t2 = this.grammar.leftRecursion;\n        return this;\n    }\n    get count() {\n        let c = 0;\n        for (const nt of this.entries.values()) {\n            for (const term of nt.values()) {\n                c += term.length;\n            }\n        }\n        return c;\n    }\n    ensureEntry(nt, term) {\n        TSU.assert(!nt.isTerminal && term.isTerminal);\n        let entriesForNT = this.entries.get(nt.id);\n        if (!entriesForNT) {\n            entriesForNT = new Map();\n            this.entries.set(nt.id, entriesForNT);\n        }\n        let entries = entriesForNT.get(term.id);\n        if (!entries) {\n            entries = [];\n            entriesForNT.set(term.id, entries);\n        }\n        return entries;\n    }\n    add(nt, term, entry) {\n        const entries = this.ensureEntry(nt, term);\n        if (entries.findIndex((e) => e.equals(entry)) < 0) {\n            entries.push(entry);\n        }\n        return entries.length == 1;\n    }\n    get(nt, term) {\n        return this.ensureEntry(nt, term);\n    }\n    forEachEntry(visitor) {\n        for (const ntId of this.entries.keys()) {\n            const ntMap = this.entries.get(ntId) || null;\n            TSU.assert(ntMap != null);\n            const nonterm = this.grammar.getSymById(ntId);\n            TSU.assert(nonterm != null);\n            for (const termId of ntMap.keys()) {\n                const term = this.grammar.getSymById(termId);\n                TSU.assert(term != null);\n                const items = ntMap.get(termId) || [];\n                if (visitor(nonterm, term, items) == false)\n                    return;\n            }\n        }\n    }\n    get debugValue() {\n        const out = {};\n        this.forEachEntry((nt, term, items) => {\n            out[nt.label] = out[nt.label] || {};\n            out[nt.label][term.label] = out[nt.label][term.label] || [];\n            const entries = out[nt.label][term.label];\n            for (const item of items) {\n                entries.push(item.debugString);\n            }\n        });\n        return out;\n    }\n    processRule(rule, index) {\n        const firstSets = this.grammar.firstSets;\n        let ruleIsNullable = false;\n        firstSets.forEachTermIn(rule.rhs, 0, (term) => {\n            if (term == null) {\n                ruleIsNullable = true;\n            }\n            else {\n                this.add(rule.nt, term, rule);\n            }\n        });\n        if (ruleIsNullable) {\n            this.grammar.followSets.forEachTerm(rule.nt, (term) => {\n                TSU.assert(term != null, \"Follow sets cannot have null\");\n                this.add(rule.nt, term, rule);\n            });\n        }\n    }\n}\nexport class ParseStack {\n    constructor(parseTable) {\n        this.idCounter = 0;\n        this.parseTable = parseTable;\n        this.stack = [];\n        const g = parseTable.grammar;\n        TSU.assert(g.startSymbol != null, \"Start symbol not selected\");\n        this.docNode = this.push(g.Eof, new PTNode(this.idCounter++, new Sym(g, \"<DOC>\", false), null));\n        this.rootNode = this.push(g.startSymbol);\n        this.docNode.add(this.rootNode);\n    }\n    get debugString() {\n        return \"Stack: [\" + this.stack.map((x) => x[0].label).join(\", \") + \"]\";\n    }\n    push(sym, node = null) {\n        if (!node)\n            node = new PTNode(this.idCounter++, sym, null);\n        this.stack.push([sym, node]);\n        return node;\n    }\n    top() {\n        return this.stack[this.stack.length - 1];\n    }\n    pop() {\n        if (this.stack.length == 0) {\n            TSU.assert(false, \"Stacks are empty\");\n        }\n        return this.stack.pop();\n    }\n    get isEmpty() {\n        return this.stack.length == 0;\n    }\n}\nexport class Parser extends ParserBase {\n    constructor(parseTable) {\n        super();\n        this.parseTable = parseTable;\n        TSU.assert(parseTable.grammar.startSymbol != null, \"Start symbol not selected\");\n    }\n    get grammar() {\n        return this.parseTable.grammar;\n    }\n    parseInput(input, delegate = null) {\n        this.stack = new ParseStack(this.parseTable);\n        const tokenbuffer = this.tokenbuffer;\n        const stack = this.stack;\n        const g = this.grammar;\n        let token;\n        let topItem;\n        let topNode;\n        do {\n            token = tokenbuffer.peek(input);\n            [topItem, topNode] = stack.top();\n            const nextSym = token == null ? g.Eof : this.getSym(token);\n            const nextValue = token == null ? null : token.value;\n            if (topItem.isTerminal) {\n                if (topItem == nextSym) {\n                    this.consumeTokenAndPop(input, nextSym, token);\n                }\n                else {\n                    this.processInvalidToken(nextSym, token);\n                }\n            }\n            else {\n                const entries = this.parseTable.get(topItem, nextSym);\n                if (entries.length != 1) {\n                    console.log(\"TopItem: \", topItem);\n                    console.log(\"nextSym: \", nextSym);\n                    this.processInvalidReductions(topNode, topItem, nextSym, nextValue, entries);\n                }\n                else {\n                    const [sym, ptnode] = this.stack.pop();\n                    TSU.assert(ptnode == topNode);\n                    TSU.assert(sym == entries[0].nt);\n                    TSU.assert(ptnode.sym == sym);\n                    this.popSymAndPushRule(ptnode, entries[0]);\n                }\n            }\n            [topItem, topNode] = stack.top();\n        } while (topItem != g.Eof);\n        return stack.rootNode;\n    }\n    popSymAndPushRule(parentNode, rule) {\n        for (let i = rule.rhs.syms.length - 1; i >= 0; i--) {\n            const sym = rule.rhs.syms[i];\n            const node = this.stack.push(sym);\n            parentNode.add(node, 0);\n        }\n    }\n    consumeTokenAndPop(tape, nextSym, nextToken) {\n        const [sym, ptnode] = this.stack.top();\n        TSU.assert(sym == nextSym);\n        TSU.assert(ptnode.sym == nextSym);\n        ptnode.value = nextToken.value;\n        this.tokenbuffer.next(tape);\n        this.stack.pop();\n    }\n    processInvalidToken(nextSym, nextValue) {\n        throw new Error(\"Invalid token: \" + nextSym.label);\n        return true;\n    }\n    processInvalidReductions(topNode, currSym, nextSym, nextValue, entries) {\n        throw new Error(`Invalid # reductions ${entries.length} found ${currSym.label} -> ${nextSym.label}`);\n        return true;\n    }\n}\n//# sourceMappingURL=ll.js.map","import * as TSU from \"@panyam/tsutils\";\nimport * as TLEX from \"tlex\";\nimport { Grammar, Str, RuleAction } from \"./grammar\";\nconst str2regex = (s) => {\n    if (typeof s === \"number\")\n        return \"\" + s;\n    return s.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n};\nexport var TokenType;\n(function (TokenType) {\n    TokenType[\"STRING\"] = \"STRING\";\n    TokenType[\"REGEX\"] = \"REGEX\";\n    TokenType[\"NUMBER\"] = \"NUMBER\";\n    TokenType[\"SPACES\"] = \"SPACES\";\n    TokenType[\"IDENT\"] = \"IDENT\";\n    TokenType[\"PCT_IDENT\"] = \"PCT_IDENT\";\n    TokenType[\"STAR\"] = \"STAR\";\n    TokenType[\"PLUS\"] = \"PLUS\";\n    TokenType[\"QMARK\"] = \"QMARK\";\n    TokenType[\"PIPE\"] = \"PIPE\";\n    TokenType[\"DOLLAR_NUM\"] = \"DOLLAR_NUM\";\n    TokenType[\"DOLLAR_IDENT\"] = \"DOLLAR_IDENT\";\n    TokenType[\"OPEN_PAREN\"] = \"OPEN_PAREN\";\n    TokenType[\"CLOSE_PAREN\"] = \"CLOSE_PAREN\";\n    TokenType[\"OPEN_BRACE\"] = \"OPEN_BRACE\";\n    TokenType[\"CLOSE_BRACE\"] = \"CLOSE_BRACE\";\n    TokenType[\"OPEN_SQ\"] = \"OPEN_SQ\";\n    TokenType[\"CLOSE_SQ\"] = \"CLOSE_SQ\";\n    TokenType[\"COMMENT\"] = \"COMMENT\";\n    TokenType[\"ARROW\"] = \"ARROW\";\n    TokenType[\"COLCOLHYPHEN\"] = \"COLCOLHYPHEN\";\n    TokenType[\"COLON\"] = \"COLON\";\n    TokenType[\"SEMI_COLON\"] = \"SEMI_COLON\";\n})(TokenType || (TokenType = {}));\nexport function load(input, params) {\n    params = params || {};\n    const g = new Grammar(params.grammar || {});\n    const eparser = new Loader(input, { ...params, grammar: g });\n    const tokenFunc = eparser.generatedTokenizer.next.bind(eparser.generatedTokenizer);\n    const debug = params.debug || \"\";\n    if (debug.split(\"|\").findIndex((p) => p == \"all\" || p == \"lexer\") >= 0) {\n        console.log(\"Prog: \\n\", `${eparser.generatedTokenizer.vm.prog.debugValue().join(\"\\n\")}`);\n    }\n    return [g, tokenFunc];\n}\nexport function Tokenizer() {\n    const lexer = new TLEX.Tokenizer();\n    lexer.add(/->/, { tag: TokenType.ARROW });\n    lexer.add(/\\[/, { tag: TokenType.OPEN_SQ });\n    lexer.add(/\\]/, { tag: TokenType.CLOSE_SQ });\n    lexer.add(/\\(/, { tag: TokenType.OPEN_PAREN });\n    lexer.add(/\\)/, { tag: TokenType.CLOSE_PAREN });\n    lexer.add(/\\{/, { tag: TokenType.OPEN_BRACE });\n    lexer.add(/\\}/, { tag: TokenType.CLOSE_BRACE });\n    lexer.add(/\\*/, { tag: TokenType.STAR });\n    lexer.add(/\\+/, { tag: TokenType.PLUS });\n    lexer.add(/\\?/, { tag: TokenType.QMARK });\n    lexer.add(/;/, { tag: TokenType.SEMI_COLON });\n    lexer.add(/:/, { tag: TokenType.COLON });\n    lexer.add(/\\|/, { tag: TokenType.PIPE });\n    lexer.add(/\\s+/m, { tag: TokenType.SPACES }, () => null);\n    lexer.add(/\\/\\*.*?\\*\\//s, { tag: TokenType.COMMENT }, () => null);\n    lexer.add(/\\/\\/.*$/m, { tag: TokenType.COMMENT }, () => null);\n    lexer.add(TLEX.Samples.DOUBLE_QUOTE_STRING, { tag: TokenType.STRING }, (rule, tape, token) => {\n        token.value = tape.substring(token.start + 1, token.end - 1);\n        return token;\n    });\n    lexer.add(TLEX.Samples.SINGLE_QUOTE_STRING, { tag: TokenType.STRING }, (rule, tape, token) => {\n        token.value = tape.substring(token.start + 1, token.end - 1);\n        return token;\n    });\n    lexer.add(TLEX.Samples.JS_REGEX, { tag: TokenType.REGEX }, (rule, tape, token) => {\n        const pattern = tape.substring(token.positions[1][0], token.positions[1][1]);\n        const flags = tape.substring(token.positions[3][0], token.positions[3][1]);\n        token.value = [pattern, flags];\n        return token;\n    });\n    lexer.add(/\\d+/, { tag: TokenType.NUMBER }, (rule, tape, token) => {\n        token.value = parseInt(tape.substring(token.start, token.end));\n        return token;\n    });\n    lexer.add(/%([\\w][\\w\\d_]*)/, { tag: TokenType.PCT_IDENT }, (rule, tape, token) => {\n        token.value = tape.substring(token.start + 1, token.end);\n        return token;\n    });\n    lexer.add(/\\$\\d+/, { tag: TokenType.DOLLAR_NUM }, (rule, tape, token) => {\n        token.value = parseInt(tape.substring(token.start + 1, token.end));\n        return token;\n    });\n    lexer.add(/\\$([\\w][\\w\\d_]*)/, { tag: TokenType.DOLLAR_IDENT }, (rule, tape, token) => {\n        token.value = tape.substring(token.start + 1, token.end);\n        return token;\n    });\n    lexer.add(/[\\w][\\w\\d_]*/, { tag: TokenType.IDENT });\n    return lexer;\n}\nexport var NodeType;\n(function (NodeType) {\n    NodeType[\"GRAMMAR\"] = \"GRAMMAR\";\n    NodeType[\"DECL\"] = \"DECL\";\n    NodeType[\"RULE\"] = \"RULE\";\n    NodeType[\"PROD_NULL\"] = \"PROD_NULL\";\n    NodeType[\"PROD_STR\"] = \"PROD_STR\";\n    NodeType[\"PROD_UNION\"] = \"PROD_UNION\";\n    NodeType[\"PROD_NAME\"] = \"PROD_NAME\";\n    NodeType[\"PROD_STRING\"] = \"PROD_STRING\";\n    NodeType[\"PROD_NUM\"] = \"PROD_NUM\";\n    NodeType[\"PROD_IDENT\"] = \"PROD_IDENT\";\n    NodeType[\"PROD_STAR\"] = \"PROD_STAR\";\n    NodeType[\"PROD_PLUS\"] = \"PROD_PLUS\";\n    NodeType[\"PROD_OPTIONAL\"] = \"PROD_OPTIONAL\";\n    NodeType[\"IDENT\"] = \"IDENT\";\n    NodeType[\"ERROR\"] = \"ERROR\";\n    NodeType[\"COMMENT\"] = \"COMMENT\";\n})(NodeType || (NodeType = {}));\nexport class Loader {\n    constructor(input, config) {\n        this.leftRecursive = false;\n        this.generatedTokenizer = new TLEX.Tokenizer();\n        this.regexSyntax = \"js\";\n        config = config || {};\n        this.symbolsByLabel = {};\n        this.grammar = config.grammar || new Grammar();\n        this.leftRecursive = \"leftRecursive\" in config ? config.leftRecursive || false : true;\n        this.newSymbolCallback = config.newSymbolCallback || null;\n        this.tokenHandlers = config.tokenHandlers || {};\n        this.parse(input);\n    }\n    symbolForLabel(label) {\n        return this.symbolsByLabel[label] || null;\n    }\n    registerSymbol(label, sym) {\n        TSU.assert(!(label in this.symbolsByLabel), `${label} is already registered`);\n        this.symbolsByLabel[label] = sym;\n    }\n    ensureSymbol(label, assumedTerminal) {\n        let currSym = this.symbolForLabel(label);\n        if (currSym != null)\n            return currSym;\n        else if (this.newSymbolCallback) {\n            currSym = this.newSymbolCallback(label, assumedTerminal) || null;\n        }\n        if (currSym == null) {\n            if (assumedTerminal) {\n                currSym = this.grammar.newTerm(label);\n            }\n            else {\n                currSym = this.grammar.newNT(label);\n            }\n        }\n        this.registerSymbol(label, currSym);\n        return currSym;\n    }\n    parse(input) {\n        const et = Tokenizer();\n        const ntFunc = (tape, owner) => {\n            const out = et.next(tape, this);\n            return out;\n        };\n        this.tokenizer = new TLEX.TokenBuffer(ntFunc, this);\n        this.parseGrammar(new TLEX.Tape(input));\n    }\n    parseRegex(tape, tag, priority = 0, syntax = \"\") {\n        if (syntax == \"\")\n            syntax = this.regexSyntax;\n        if (syntax == \"js\") {\n            const tokPattern = this.tokenizer.expectToken(tape, TokenType.STRING, TokenType.NUMBER, TokenType.REGEX);\n            let rule;\n            if (!tag || tag.length == 0) {\n                tag = \"/\" + tokPattern.value[0] + \"/\" + tokPattern.value[1];\n            }\n            if (tokPattern.tag == TokenType.STRING || tokPattern.tag == TokenType.NUMBER) {\n                const pattern = str2regex(tokPattern.value);\n                rule = TLEX.Builder.build(pattern, { tag: tag, priority: priority + 20 });\n            }\n            else if (tokPattern.tag == TokenType.REGEX) {\n                let re = tokPattern.value[0];\n                if (tokPattern.value[1].length > 0) {\n                    re = new RegExp(tokPattern.value[0], tokPattern.value[1]);\n                }\n                rule = TLEX.Builder.build(re, { tag: tag, priority: priority + 10 });\n            }\n            else {\n                throw new TLEX.UnexpectedTokenError(tokPattern);\n            }\n            return rule;\n        }\n        else {\n            let patternStr = \"\";\n            while (tape.hasMore && tape.currCh != \"\\n\") {\n                patternStr += tape.currCh;\n                tape.advance();\n            }\n            patternStr = patternStr.trim();\n            if (!tag || tag.length == 0) {\n                tag = \"/\" + patternStr + \"/\";\n            }\n            return new TLEX.Rule(TLEX.Builder.exprFromFlexRE(patternStr), { tag: tag, priority: priority });\n        }\n    }\n    parseGrammar(tape) {\n        let peeked = this.tokenizer.peek(tape);\n        while (peeked != null) {\n            if (peeked.tag == TokenType.IDENT) {\n                this.parseDecl(tape);\n            }\n            else if (peeked.tag == TokenType.PCT_IDENT) {\n                this.tokenizer.next(tape);\n                this.parseDirective(tape, peeked.value);\n            }\n            else {\n                throw new SyntaxError(`Declaration must start with IDENT or PCT_IDENT.  Found: '${peeked.value}' instead.`);\n            }\n            peeked = this.tokenizer.peek(tape);\n        }\n    }\n    parseDirective(tape, directive) {\n        if (directive == \"start\") {\n            const next = this.tokenizer.expectToken(tape, TokenType.IDENT);\n            this.grammar.startSymbol = this.ensureSymbol(next.value, false);\n        }\n        else if (directive == \"resyntax\") {\n            const next = this.tokenizer.expectToken(tape, TokenType.IDENT);\n            if (next.value != \"js\" && next.value != \"flex\") {\n                throw new SyntaxError(\"Invalid regex syntax: \" + next.value);\n            }\n            this.regexSyntax = next.value;\n        }\n        else if (directive.startsWith(\"skip\")) {\n            const rule = this.parseRegex(tape, \"\", 30, directive.endsWith(\"flex\") ? \"flex\" : \"\");\n            const tokenHandler = this.parseTokenHandler(tape);\n            if (tokenHandler) {\n                this.generatedTokenizer.addRule(rule, (rule, tape, token) => {\n                    tokenHandler(rule, tape, token, this);\n                    return null;\n                });\n            }\n            else {\n                this.generatedTokenizer.addRule(rule, () => null);\n            }\n        }\n        else if (directive.startsWith(\"token\") || directive.startsWith(\"define\")) {\n            const isDef = directive.startsWith(\"define\");\n            const tokName = this.tokenizer.expectToken(tape, TokenType.IDENT, TokenType.STRING);\n            let label = tokName.value;\n            if (tokName.tag == TokenType.STRING || tokName.tag == TokenType.NUMBER) {\n                label = `\"${tokName.value}\"`;\n            }\n            const rule = this.parseRegex(tape, label, 0, directive.endsWith(\"flex\") ? \"flex\" : \"\");\n            if (isDef) {\n                this.generatedTokenizer.addVar(label, rule.expr);\n            }\n            else {\n                const tokenHandler = this.parseTokenHandler(tape);\n                this.generatedTokenizer.addRule(rule, tokenHandler);\n                this.ensureSymbol(label, true);\n            }\n        }\n        else {\n            throw new Error(\"Invalid directive: \" + directive);\n        }\n    }\n    parseTokenHandler(tape) {\n        if (!this.tokenizer.consumeIf(tape, TokenType.OPEN_BRACE)) {\n            return null;\n        }\n        const funcName = this.tokenizer.expectToken(tape, TokenType.IDENT);\n        const out = (rule, tape, token, owner) => {\n            const handler = this.tokenHandlers[funcName.value];\n            if (!handler)\n                throw new Error(\"Handler method not found: \" + funcName.value);\n            token = handler(token, tape, owner);\n            return token;\n        };\n        this.tokenizer.expectToken(tape, TokenType.CLOSE_BRACE);\n        return out;\n    }\n    parseDecl(tape) {\n        const ident = this.tokenizer.expectToken(tape, TokenType.IDENT);\n        if (this.tokenizer.consumeIf(tape, TokenType.ARROW, TokenType.COLON)) {\n            const nt = this.ensureSymbol(ident.value, false);\n            if (nt.isTerminal) {\n                nt.isTerminal = false;\n            }\n            else if (nt.isAuxiliary) {\n                throw new Error(\"NT is already auxiliary and cannot be reused.\");\n            }\n            for (const [rhs, action] of this.parseProductions(tape, this.grammar, nt)) {\n                const rule = this.grammar.add(nt, rhs, action);\n            }\n            this.tokenizer.expectToken(tape, TokenType.SEMI_COLON);\n        }\n    }\n    parseProductions(tape, grammar, nt) {\n        const out = [];\n        while (this.tokenizer.peek(tape) != null) {\n            const rule = this.parseProd(tape, grammar);\n            out.push(rule);\n            if (this.tokenizer.consumeIf(tape, TokenType.PIPE)) {\n                continue;\n            }\n            else if (this.tokenizer.nextMatches(tape, TokenType.CLOSE_SQ, TokenType.CLOSE_PAREN, TokenType.SEMI_COLON)) {\n                break;\n            }\n        }\n        return out;\n    }\n    parseProd(tape, grammar) {\n        const out = new Str();\n        while (true) {\n            if (this.tokenizer.nextMatches(tape, TokenType.CLOSE_PAREN, TokenType.CLOSE_SQ, TokenType.SEMI_COLON, TokenType.PIPE, TokenType.OPEN_BRACE)) {\n                break;\n            }\n            let curr = null;\n            if (this.tokenizer.consumeIf(tape, TokenType.OPEN_PAREN)) {\n                const rules = this.parseProductions(tape, grammar, null);\n                if (rules.length == 0) {\n                }\n                else if (rules.length == 1) {\n                    curr = rules[0][0];\n                }\n                else {\n                    curr = grammar.anyof(...rules.map((r) => r[0]));\n                }\n                this.tokenizer.expectToken(tape, TokenType.CLOSE_PAREN);\n            }\n            else if (this.tokenizer.consumeIf(tape, TokenType.OPEN_SQ)) {\n                const rules = this.parseProductions(tape, grammar, null);\n                if (rules.length == 0) {\n                }\n                else if (rules.length == 1) {\n                    curr = grammar.opt(rules[0][0]);\n                }\n                else {\n                    curr = grammar.opt(grammar.anyof(...rules.map((r) => r[0])));\n                }\n                this.tokenizer.expectToken(tape, TokenType.CLOSE_SQ);\n            }\n            else if (this.tokenizer.nextMatches(tape, TokenType.IDENT, TokenType.STRING, TokenType.NUMBER, TokenType.REGEX)) {\n                const token = this.tokenizer.next(tape);\n                let label = token.value;\n                if (token.tag == TokenType.STRING || token.tag == TokenType.NUMBER) {\n                    label = `\"${token.value}\"`;\n                    const pattern = str2regex(token.value);\n                    const rule = TLEX.Builder.build(pattern, { tag: label, priority: 20 });\n                    this.generatedTokenizer.addRule(rule);\n                }\n                else if (token.tag == TokenType.REGEX) {\n                    label = \"/\" + token.value[0] + \"/\" + token.value[1];\n                    let re = token.value[0];\n                    if (token.value[1].length > 0) {\n                        re = new RegExp(token.value[0], token.value[1]);\n                    }\n                    const rule = TLEX.Builder.build(re, { tag: label, priority: 10 });\n                    this.generatedTokenizer.addRule(rule);\n                }\n                else {\n                }\n                const currSym = this.ensureSymbol(label, true);\n                curr = new Str(currSym);\n            }\n            else {\n                throw new TLEX.UnexpectedTokenError(this.tokenizer.peek(tape));\n            }\n            if (curr == null) {\n                throw new Error(\"Could not determine node\");\n            }\n            if (this.tokenizer.consumeIf(tape, TokenType.STAR)) {\n                curr = grammar.atleast0(curr, this.leftRecursive);\n            }\n            else if (this.tokenizer.consumeIf(tape, TokenType.PLUS)) {\n                curr = grammar.atleast1(curr, this.leftRecursive);\n            }\n            else if (this.tokenizer.consumeIf(tape, TokenType.QMARK)) {\n                curr = grammar.opt(curr);\n            }\n            out.extend(curr);\n        }\n        let action = null;\n        if (this.tokenizer.consumeIf(tape, TokenType.OPEN_BRACE)) {\n            const next = this.tokenizer.expectToken(tape, TokenType.DOLLAR_NUM, TokenType.IDENT);\n            action = new RuleAction(next.value);\n            this.tokenizer.expectToken(tape, TokenType.CLOSE_BRACE);\n        }\n        return [out, action];\n    }\n}\n//# sourceMappingURL=dsl.js.map","import * as TSU from \"@panyam/tsutils\";\nimport { Grammar, Str, Sym, Rule } from \"./grammar\";\nimport { LRAction, ParseTable } from \"./lr\";\nimport { LRItem, LR0ItemGraph, LR1ItemGraph } from \"./lritems\";\nexport function makeParseTable(g, type = \"lr1\") {\n    switch (type) {\n        case \"lr1\":\n            return makeLRParseTable(g);\n        case \"lalr\":\n            return makeLALRParseTable(g);\n    }\n    return makeSLRParseTable(g);\n}\nexport function makeSLRParseTable(grammar) {\n    const ig = makeSLRAutomaton(grammar);\n    return [makeParseTableFromLA(ig, grammar), ig];\n}\nexport function makeSLRAutomaton(grammar) {\n    const ig = new LR0ItemGraph(grammar).refresh();\n    for (const itemSet of ig.itemSets.entries) {\n        evalLASetsForSLRItem(grammar, ig, itemSet);\n    }\n    return ig;\n}\nexport function evalLASetsForSLRItem(grammar, ig, itemSet) {\n    for (const itemId of itemSet.values) {\n        const item = ig.items.get(itemId);\n        const rule = item.rule;\n        if (item.position >= rule.rhs.length) {\n            grammar.followSets.forEachTerm(rule.nt, (term) => {\n                if (term != null) {\n                    TSU.assert(term.isTerminal);\n                    itemSet.addLookAhead(item, term);\n                }\n            });\n        }\n    }\n}\nexport function makeLRParseTable(grammar) {\n    const ig = new LR1ItemGraph(grammar).refresh();\n    const parseTable = makeParseTableFromLA(ig, grammar);\n    return [parseTable, ig];\n}\nexport function makeLALRParseTable(grammar) {\n    const [parseTable, ig] = makeSLRParseTable(grammar);\n    if (!parseTable.hasConflicts) {\n        return [parseTable, ig];\n    }\n    const g2 = grammarFromLR0ItemGraph(ig, grammar);\n    const prevSets = {};\n    for (const startState in ig.gotoSets) {\n        for (const symId in ig.gotoSets[startState]) {\n            const nextSet = ig.gotoSets[startState][symId];\n            if (!(nextSet.id in prevSets)) {\n                prevSets[nextSet.id] = {};\n            }\n            if (!(symId in prevSets[nextSet.id])) {\n                prevSets[nextSet.id][symId] = new Set();\n            }\n            prevSets[nextSet.id][symId].add(startState);\n        }\n    }\n    for (const startState in parseTable.conflictActions) {\n        const itemSet = ig.itemSets.get(startState);\n        evalLASetsForLALRItem(grammar, g2, ig, itemSet, prevSets);\n    }\n    return [makeParseTableFromLA(ig, grammar), ig];\n}\nexport function makeParseTableFromLA(ig, grammar) {\n    const parseTable = new ParseTable(grammar);\n    for (const itemSet of ig.itemSets.entries) {\n        for (const itemId of itemSet.values) {\n            const item = ig.items.get(itemId);\n            const rule = item.rule;\n            if (item.position < rule.rhs.length) {\n                const sym = rule.rhs.syms[item.position];\n                if (sym.isTerminal) {\n                    const nextSet = ig.getGoto(itemSet, sym);\n                    if (nextSet) {\n                        parseTable.addAction(itemSet.id, sym, LRAction.Shift(nextSet.id));\n                    }\n                }\n            }\n            else if (!rule.nt.equals(grammar.augStartRule.nt)) {\n                const lookaheads = itemSet.getLookAheads(item);\n                for (const lookahead of lookaheads) {\n                    parseTable.addAction(itemSet.id, lookahead, LRAction.Reduce(rule));\n                }\n            }\n        }\n        ig.forEachGoto(itemSet, (sym, next) => {\n            if (sym != null && !sym.isTerminal) {\n                parseTable.addAction(itemSet.id, sym, LRAction.Goto(next.id));\n            }\n        });\n        const lr1Item = ig.items.ensure(new LRItem(grammar.augStartRule, 1));\n        itemSet.addLookAhead(lr1Item, grammar.Eof);\n        if (itemSet.has(lr1Item.id)) {\n            parseTable.addAction(itemSet.id, grammar.Eof, LRAction.Accept());\n        }\n    }\n    return parseTable;\n}\nexport function evalLASetsForLALRItem(grammar, augGrammar, ig, itemSet, prevSets) {\n    function findP(rule, i, currState, states) {\n        if (i < 0) {\n            const transitions = ig.gotoSets[currState];\n            TSU.assert((transitions[rule.nt.id] || null) != null, \"Transition on rule.nt missing from start state\");\n            states.add(currState);\n        }\n        else {\n            const sym = rule.rhs.syms[i];\n            const prevStates = prevSets[currState][sym.id] || null;\n            TSU.assert(prevStates != null, \"Prev set should not be null\");\n            prevStates.forEach((nextState) => findP(rule, i - 1, nextState, states));\n        }\n    }\n    itemSet.clearLookAheads();\n    for (const itemId of itemSet.values) {\n        const item = ig.items.get(itemId);\n        const rule = item.rule;\n        if (item.position >= rule.rhs.length) {\n            const pSet = new Set();\n            findP(rule, rule.rhs.length - 1, itemSet.id, pSet);\n            pSet.forEach((p) => {\n                const pALabel = `[${p}:${rule.nt.label}]`;\n                const pA = augGrammar.getSym(pALabel);\n                TSU.assert(pA != null, \"Augmented grammar symbol [p:A] not found\");\n                augGrammar.followSets.forEachTerm(pA, (term) => {\n                    if (term != null && term != augGrammar.Eof) {\n                        TSU.assert(term.isTerminal);\n                        const label = term.label.substring(term.label.indexOf(\":\") + 1, term.label.length - 1).trim();\n                        const T = grammar.getSym(label);\n                        TSU.assert(T != null, `T (${label}) in [r:T] cannot be null`);\n                        itemSet.addLookAhead(item, T);\n                    }\n                });\n            });\n        }\n    }\n}\nexport function grammarFromLR0ItemGraph(ig, g) {\n    const g2 = new Grammar();\n    function ensureG2Sym(pi, sym) {\n        const newSymLabel = `[${pi}:${sym.label}]`;\n        const newSym = g2.ensureSym(new Sym(g2, newSymLabel, sym.isTerminal), false);\n        if (pi == 0 && g.startSymbol == sym && g.startSymbol != newSym && !sym.isTerminal) {\n            g2.startSymbol = newSym;\n        }\n        return newSym;\n    }\n    for (const startState in ig.gotoSets) {\n        const transitions = ig.gotoSets[startState];\n        for (const symId in transitions) {\n            const sym = g.getSymById(symId);\n            ensureG2Sym(startState, sym);\n        }\n    }\n    function buildRuleFrom(startSet, A, rule) {\n        let pi = startSet;\n        const newSyms = rule.rhs.syms.map((xi, index) => {\n            const nextSym = ensureG2Sym(pi, xi);\n            const transitions = ig.gotoSets[pi];\n            const nextSet = transitions[xi.id] || null;\n            TSU.assert(nextSet != null, \"Next set transition *must* be valid\");\n            pi = nextSet.id;\n            return nextSym;\n        });\n        return new Str(...newSyms);\n    }\n    for (const startState in ig.gotoSets) {\n        const transitions = ig.gotoSets[startState];\n        for (const symId in transitions) {\n            const startSym = g.getSymById(symId);\n            const p1 = startState;\n            if (!startSym.isTerminal) {\n                const newA = ensureG2Sym(p1, startSym);\n                g.forEachRule(startSym, (rule, index) => {\n                    const newRHS = buildRuleFrom(p1, startSym, rule);\n                    const newRule = new Rule(newA, newRHS);\n                    g2.addRule(newRule);\n                });\n            }\n        }\n    }\n    return g2;\n}\n//# sourceMappingURL=ptables.js.map","export function printGrammar(g, hideAux = true) {\n    let out = \"\";\n    g.forEachNT((nt) => {\n        if (!hideAux || !nt.isAuxiliary) {\n            out += nt.label + \" -> \";\n            out += printRules(g, g.rulesForNT(nt), hideAux) + \"\\n\\n\";\n        }\n    });\n    return out;\n}\nexport function printRules(g, rules, hideAux = true) {\n    let out = \"\";\n    const indentStr = \"    \";\n    for (let i = 0; i < rules.length; i++) {\n        const rule = rules[i];\n        if (i > 0) {\n            if (!hideAux) {\n                out += \"\\n\";\n                out += indentStr;\n            }\n            out += \" | \";\n        }\n        out += printRule(g, rule.rhs, hideAux);\n    }\n    if (!hideAux) {\n        out += \"\\n\";\n        out += indentStr;\n    }\n    out += \" ;\";\n    return out;\n}\nexport function printRule(g, rule, hideAux = true) {\n    return rule.debugString;\n}\nfunction printTree(node, level = 0) {\n    let out = \"\";\n    let indentStr = \"\";\n    for (let i = 0; i < level; i++)\n        indentStr += \"  \";\n    out += indentStr + node.sym.label + \" - \" + node.value;\n    for (const child of node.children)\n        out += \"\\n\" + printTree(child, level + 1);\n    return out;\n}\n//# sourceMappingURL=utils.js.map","import * as TSU from \"@panyam/tsutils\";\nimport { PTNode, SimpleParser as ParserBase, } from \"./parser\";\nimport { ParseError } from \"./errors\";\nexport var LRActionType;\n(function (LRActionType) {\n    LRActionType[LRActionType[\"ACCEPT\"] = 0] = \"ACCEPT\";\n    LRActionType[LRActionType[\"SHIFT\"] = 1] = \"SHIFT\";\n    LRActionType[LRActionType[\"REDUCE\"] = 2] = \"REDUCE\";\n    LRActionType[LRActionType[\"GOTO\"] = 3] = \"GOTO\";\n})(LRActionType || (LRActionType = {}));\nexport class LRAction {\n    constructor() {\n        this.gotoState = null;\n        this.rule = null;\n    }\n    toString() {\n        if (this.tag == LRActionType.ACCEPT)\n            return \"Acc\";\n        else if (this.tag == LRActionType.SHIFT) {\n            return \"S\" + this.gotoState;\n        }\n        else if (this.tag == LRActionType.REDUCE) {\n            return \"R \" + this.rule.id;\n        }\n        else {\n            return \"\" + this.gotoState;\n        }\n    }\n    equals(another) {\n        return this.tag == another.tag && this.gotoState == another.gotoState && this.rule == another.rule;\n    }\n    static Shift(goto) {\n        const out = new LRAction();\n        out.tag = LRActionType.SHIFT;\n        out.gotoState = goto;\n        return out;\n    }\n    static Reduce(rule) {\n        const out = new LRAction();\n        out.tag = LRActionType.REDUCE;\n        out.rule = rule;\n        return out;\n    }\n    static Goto(gotoState) {\n        const out = new LRAction();\n        out.tag = LRActionType.GOTO;\n        out.gotoState = gotoState;\n        return out;\n    }\n    static Accept() {\n        const out = new LRAction();\n        out.tag = LRActionType.ACCEPT;\n        return out;\n    }\n}\nexport class ParseTable {\n    constructor(grammar) {\n        this.grammar = grammar;\n        this.conflictActions = {};\n        this.actions = {};\n    }\n    get hasConflicts() {\n        return Object.keys(this.conflictActions).length > 0;\n    }\n    getActions(stateId, next, ensure = false) {\n        let l1;\n        if (stateId in this.actions) {\n            l1 = this.actions[stateId];\n        }\n        else if (ensure) {\n            l1 = this.actions[stateId] = {};\n        }\n        else {\n            return [];\n        }\n        if (next.id in l1) {\n            return l1[next.id];\n        }\n        else if (ensure) {\n            return (l1[next.id] = []);\n        }\n        return [];\n    }\n    addAction(stateId, next, action) {\n        const actions = this.getActions(stateId, next, true);\n        if (actions.findIndex((ac) => ac.equals(action)) < 0) {\n            actions.push(action);\n        }\n        if (actions.length > 1) {\n            this.conflictActions[stateId] = this.conflictActions[stateId] || {};\n            this.conflictActions[stateId][next.label] = true;\n        }\n        return this;\n    }\n    get debugValue() {\n        const out = {};\n        for (const fromId in this.actions) {\n            out[fromId] = {};\n            for (const symId in this.actions[fromId]) {\n                const sym = this.grammar.getSymById(symId);\n                const actions = this.actions[fromId][sym.id] || [];\n                if (actions.length > 0) {\n                    out[fromId][sym.label] = actions.map((a) => a.toString());\n                }\n            }\n        }\n        return out;\n    }\n}\nexport class ParseStack {\n    constructor() {\n        this.stateStack = [];\n        this.nodeStack = [];\n    }\n    push(state, node) {\n        this.stateStack.push(state);\n        this.nodeStack.push(node);\n    }\n    top(nth = 0) {\n        return [this.stateStack[this.stateStack.length - 1 - nth], this.nodeStack[this.nodeStack.length - 1 - nth]];\n    }\n    pop() {\n        const out = this.top();\n        this.stateStack.pop();\n        this.nodeStack.pop();\n        return out;\n    }\n    popN(n = 1) {\n        const L = this.stateStack.length;\n        this.stateStack.splice(L - n, n);\n        this.nodeStack.splice(L - n, n);\n    }\n    get isEmpty() {\n        return this.stateStack.length == 0 || this.nodeStack.length == 0;\n    }\n}\nexport class Parser extends ParserBase {\n    constructor(parseTable, config = {}) {\n        super();\n        this.parseTable = parseTable;\n    }\n    get grammar() {\n        return this.parseTable.grammar;\n    }\n    parseInput(input, context) {\n        context = context || {};\n        this.tokenbuffer.tokenizerContext = context.tokenizerContext;\n        if (context.buildParseTree != false)\n            context.buildParseTree = true;\n        if (context.copySingleChild != false)\n            context.copySingleChild = true;\n        let idCounter = 0;\n        const stack = new ParseStack();\n        stack.push(0, new PTNode(idCounter++, this.grammar.augStartRule.nt, null));\n        const tokenbuffer = this.tokenbuffer;\n        const g = this.grammar;\n        let output = null;\n        function resolveActions(actions) {\n            if (context?.actionResolver) {\n                return context.actionResolver(actions, stack, tokenbuffer);\n            }\n            else {\n                if (actions.length > 1) {\n                    throw new Error(\"Multiple actions found.\");\n                }\n                return actions[0];\n            }\n        }\n        function nextToken() {\n            try {\n                return tokenbuffer.peek(input);\n            }\n            catch (err) {\n                if (!context?.onTokenError || !context?.onTokenError(err, input)) {\n                    throw err;\n                }\n                return nextToken();\n            }\n        }\n        while (true) {\n            let token = nextToken();\n            if (token == null) {\n                if (stack.isEmpty) {\n                    break;\n                }\n            }\n            else if (context.onNextToken) {\n                token = context.onNextToken(token);\n            }\n            const nextSym = token == null ? g.Eof : this.getSym(token);\n            const nextValue = token == null ? null : token.value;\n            let [topState, topNode] = stack.top();\n            const actions = this.parseTable.getActions(topState, nextSym);\n            if (actions == null || actions.length == 0) {\n                throw new ParseError(`Unexpected Token: '${nextSym.label}'`, \"UnexpectedToken\", {\n                    state: topState,\n                    token: token,\n                    nextSym: nextSym,\n                });\n            }\n            const action = resolveActions(actions);\n            if (action.tag == LRActionType.ACCEPT) {\n                break;\n            }\n            else if (action.tag == LRActionType.SHIFT) {\n                tokenbuffer.next(input);\n                const newNode = new PTNode(idCounter++, nextSym, nextValue);\n                stack.push(action.gotoState, newNode);\n            }\n            else {\n                TSU.assert(action.rule != null, \"Nonterm and ruleindex must be provided for a reduction action\");\n                const ruleLen = action.rule.rhs.length;\n                let newNode = new PTNode(idCounter++, action.rule.nt, null);\n                if (context.buildParseTree) {\n                    for (let i = ruleLen - 1; i >= 0; i--) {\n                        const childNode = stack.top(i)[1];\n                        if (context.beforeAddingChildNode) {\n                            for (const node of context.beforeAddingChildNode(newNode, childNode)) {\n                                newNode.add(node);\n                            }\n                        }\n                        else if (childNode != null) {\n                            newNode.add(childNode);\n                        }\n                    }\n                }\n                if (action.rule.action) {\n                    if (action.rule.action.isFunction) {\n                        const handlerName = action.rule.action.value;\n                        const handler = context.ruleHandlers[handlerName];\n                        if (!handler)\n                            throw new Error(\"Action handler not found: \" + handlerName);\n                        newNode.value = handler(action.rule, newNode, ...newNode.children);\n                    }\n                    else {\n                        newNode.value = newNode.children[action.rule.action.value - 1].value;\n                    }\n                }\n                else if (context.onReduction) {\n                    newNode = context.onReduction(newNode, action.rule);\n                }\n                else if (newNode.children.length == 1 && context.copySingleChild) {\n                    newNode.value = newNode.children[0].value;\n                }\n                stack.popN(ruleLen);\n                [topState, topNode] = stack.top();\n                const newAction = resolveActions(this.parseTable.getActions(topState, action.rule.nt));\n                TSU.assert(newAction != null && newAction.gotoState != null, \"Top item does not have an action.\");\n                stack.push(newAction.gotoState, newNode);\n                output = newNode;\n            }\n        }\n        return output;\n    }\n}\n//# sourceMappingURL=lr.js.map","import * as TSU from \"@panyam/tsutils\";\nconst defaultKeyFunc = (x) => x.key;\nexport class Trie {\n    constructor(keyFunc) {\n        this.root = new TrieNode();\n        this.keyFunc = keyFunc;\n    }\n    add(values, fromIndex = 0) {\n        let curr = this.root;\n        for (let i = fromIndex; i < values.length; i++) {\n            const key = this.keyFunc(values[i]);\n            if (curr.children.has(key)) {\n                curr = curr.children.get(key);\n            }\n            else {\n                const newNode = new TrieNode();\n                newNode.value = values[i];\n                newNode.parent = curr;\n                curr.children.set(key, newNode);\n                curr = newNode;\n            }\n        }\n        curr.isLeaf = true;\n        return curr;\n    }\n    get debugValue() {\n        return this.root.debugValue;\n    }\n}\nexport class TrieNode {\n    constructor() {\n        this.isLeaf = false;\n        this.value = null;\n        this.parent = null;\n        this.children = new Map();\n    }\n    get debugValue() {\n        const out = { value: this.value, children: {} };\n        if (this.isLeaf)\n            out[\"isLeaf\"] = true;\n        for (const [key, value] of this.children.entries()) {\n            out.children[key] = value.debugValue;\n        }\n        return out;\n    }\n}\nexport class IDSet {\n    constructor(keyFunc = defaultKeyFunc) {\n        this._entries = [];\n        this._entriesByKey = {};\n        this.keyFunc = keyFunc;\n    }\n    clear() {\n        this._entries = [];\n        this._entriesByKey = {};\n    }\n    remove(predicate) {\n        const e2 = [];\n        this._entriesByKey = {};\n        let modified = false;\n        for (let l = 0; l < this._entries.length; l++) {\n            const e = this._entries[l];\n            if (!predicate(e)) {\n                e.id = e2.length;\n                e2.push(e);\n                this._entriesByKey[this.keyFunc(e)] = e;\n            }\n            else {\n                modified = true;\n            }\n        }\n        this._entries = e2;\n        return modified;\n    }\n    get entries() {\n        return this._entries;\n    }\n    get(id) {\n        TSU.assert(id >= 0 && id < this._entries.length);\n        return this._entries[id];\n    }\n    getByKey(key) {\n        return this._entriesByKey[key] || null;\n    }\n    ensure(entry, throwIfExists = false) {\n        if (this.has(entry)) {\n            if (throwIfExists)\n                throw new Error(`Entry ${this.keyFunc(entry)} already exists`);\n            return this._entriesByKey[this.keyFunc(entry)];\n        }\n        else {\n            this._entriesByKey[this.keyFunc(entry)] = entry;\n            entry.id = this._entries.length;\n            this._entries.push(entry);\n            return entry;\n        }\n    }\n    has(entry) {\n        return this.keyFunc(entry) in this._entriesByKey;\n    }\n    get size() {\n        return this._entries.length;\n    }\n}\nexport class SymbolSet {\n    constructor(grammar, enforceSymbolType = true) {\n        this.entries = new Set();\n        this.hasNull = false;\n        this.grammar = grammar;\n        this.enforceSymbolType = enforceSymbolType;\n    }\n    get debugString() {\n        return \"<\" + this.labels().sort().join(\", \") + \">\";\n    }\n    labels(skipAux = false) {\n        const out = [];\n        for (const i of this.entries) {\n            const exp = this.grammar.getSymById(i);\n            TSU.assert(exp != null);\n            if (!skipAux || !exp.isAuxiliary)\n                out.push(exp.label);\n        }\n        if (this.hasNull)\n            out.push(\"\");\n        return out;\n    }\n    addFrom(another, includeNull = true) {\n        return another.addTo(this, includeNull);\n    }\n    addTo(another, includeNull = true) {\n        const before = another.entries.size;\n        for (const termid of this.entries) {\n            another.entries.add(termid);\n        }\n        if (includeNull) {\n            another.hasNull = this.hasNull || another.hasNull;\n        }\n        return another.entries.size - before;\n    }\n    has(term) {\n        return this.entries.has(term.id);\n    }\n    add(term) {\n        TSU.assert(this.enforceSymbolType == null || this.enforceSymbolType == term.isTerminal, `Terminal types being enforced: ${this.enforceSymbolType}`);\n        this.entries.add(term.id);\n        return this;\n    }\n    delete(term) {\n        return this.entries.delete(term.id);\n    }\n    get size() {\n        return this.entries.size + (this.hasNull ? 1 : 0);\n    }\n}\nexport class NullableSet {\n    constructor(grammar) {\n        this.grammar = grammar;\n        this.refresh();\n    }\n    get nonterms() {\n        const out = [];\n        this.entries.forEach((id) => {\n            const e = this.grammar.getSymById(id);\n            TSU.assert(e != null && !e.isTerminal);\n            out.push(e);\n        });\n        return out;\n    }\n    refresh() {\n        this.entries = new Set();\n        this.visited = {};\n        let beforeCount = 0;\n        do {\n            beforeCount = this.entries.size;\n            this.grammar.allNonTerminals.forEach((nt) => this.visit(nt));\n        } while (beforeCount != this.entries.size);\n    }\n    visit(nt) {\n        for (const rule of this.grammar.rulesForNT(nt)) {\n            if (this.isStrNullable(rule.rhs)) {\n                this.add(nt);\n                break;\n            }\n        }\n    }\n    isNullable(nt) {\n        return !nt.isTerminal && this.entries.has(nt.id);\n    }\n    isStrNullable(str, fromIndex = 0, toIndex = null) {\n        if (toIndex == null) {\n            toIndex = str.length - 1;\n        }\n        for (let i = fromIndex; i <= toIndex; i++) {\n            if (!this.isNullable(str.syms[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    add(nt) {\n        TSU.assert(!nt.isTerminal);\n        this.entries.add(nt.id);\n    }\n}\nclass SymSymbolSets {\n    constructor(grammar) {\n        this.entries = {};\n        this._count = 0;\n        this.grammar = grammar;\n    }\n    refresh() {\n        this.entries = {};\n        this._count = 0;\n    }\n    forEachTerm(nt, visitor) {\n        const entries = this.entriesFor(nt);\n        entries.entries.forEach((x) => {\n            const term = this.grammar.getSymById(x);\n            TSU.assert(term != null && term.isTerminal);\n            visitor(term);\n        });\n        if (entries.hasNull)\n            visitor(null);\n    }\n    get debugValue() {\n        const out = {};\n        for (const x in this.entries)\n            out[this.grammar.getSymById(x).label] = this.entries[x].debugString;\n        return out;\n    }\n    get count() {\n        let c = 0;\n        for (const x in this.entries)\n            c += this.entries[x].size;\n        return c;\n    }\n    entriesFor(sym) {\n        if (sym.id in this.entries) {\n            return this.entries[sym.id];\n        }\n        else {\n            const out = new SymbolSet(this.grammar);\n            this.entries[sym.id] = out;\n            return out;\n        }\n    }\n    addNull(nt) {\n        const entries = this.entriesFor(nt);\n        if (entries.hasNull)\n            return false;\n        entries.hasNull = true;\n        return true;\n    }\n    add(nt, source, includeNull = true) {\n        if (nt.isTerminal) {\n            TSU.assert(false, \"Should not be here\");\n        }\n        const entries = this.entriesFor(nt);\n        if (source.isTerminal) {\n            if (entries.has(source))\n                return false;\n            entries.add(source);\n            this._count++;\n        }\n        else {\n            const srcEntries = this.entriesFor(source);\n            const destEntries = this.entriesFor(nt);\n            const count = srcEntries.addTo(destEntries, includeNull);\n            this._count += count;\n        }\n        return true;\n    }\n}\nexport class FirstSets extends SymSymbolSets {\n    constructor(grammar, nullables) {\n        super(grammar);\n        if (!nullables) {\n            nullables = new NullableSet(grammar);\n        }\n        this.nullables = nullables;\n        this.refresh();\n    }\n    forEachTermIn(str, fromIndex = 0, visitor) {\n        const syms = str.syms;\n        const visited = {};\n        let allNullable = true;\n        for (let j = fromIndex; allNullable && j < syms.length; j++) {\n            const symj = syms[j];\n            if (symj.isTerminal) {\n                visitor(symj);\n                allNullable = false;\n            }\n            else {\n                const nt = symj;\n                this.forEachTerm(nt, (term) => {\n                    if (term != null && !(term.id in visited)) {\n                        visited[term.id] = true;\n                        visitor(term);\n                    }\n                });\n                if (!this.nullables.isNullable(symj)) {\n                    allNullable = false;\n                }\n            }\n        }\n        if (allNullable)\n            visitor(null);\n    }\n    refresh() {\n        super.refresh();\n        let beforeCount = 0;\n        do {\n            beforeCount = this.count;\n            this.grammar.forEachRule(null, (rule) => {\n                this.processRule(rule);\n            });\n        } while (beforeCount != this.count);\n    }\n    processRule(rule) {\n        const nullables = this.nullables;\n        let allNullable = true;\n        for (const s of rule.rhs.syms) {\n            this.add(rule.nt, s, false);\n            if (s.isTerminal || !nullables.isNullable(s)) {\n                allNullable = false;\n                break;\n            }\n        }\n        if (allNullable)\n            this.addNull(rule.nt);\n    }\n}\nexport class FollowSets extends SymSymbolSets {\n    constructor(grammar, firstSets) {\n        super(grammar);\n        this.firstSets = firstSets || new FirstSets(grammar);\n        this.refresh();\n    }\n    get nullables() {\n        return this.firstSets.nullables;\n    }\n    refresh() {\n        super.refresh();\n        const g = this.grammar;\n        TSU.assert(g.startSymbol != null, \"Select start symbol of the grammar\");\n        this.add(g.startSymbol, g.Eof);\n        let beforeCount = 0;\n        do {\n            beforeCount = this.count;\n            this.grammar.forEachRule(null, (rule) => this.processRule(rule));\n        } while (beforeCount != this.count);\n    }\n    processRule(rule) {\n        const syms = rule.rhs.syms;\n        const firstSets = this.firstSets;\n        const nullables = this.firstSets.nullables;\n        for (let i = 0; i < syms.length; i++) {\n            const sym = syms[i];\n            if (sym.isTerminal)\n                continue;\n            firstSets.forEachTermIn(rule.rhs, i + 1, (term) => {\n                if (term != null)\n                    this.add(sym, term);\n            });\n        }\n        for (let i = syms.length - 1; i >= 0; i--) {\n            if (syms[i].isTerminal)\n                continue;\n            let allNullable = true;\n            for (let j = i + 1; j < syms.length; j++) {\n                const symj = syms[j];\n                if (symj.isTerminal || !nullables.isNullable(symj)) {\n                    allNullable = false;\n                    break;\n                }\n            }\n            if (allNullable) {\n                this.add(syms[i], rule.nt);\n            }\n        }\n    }\n}\n//# sourceMappingURL=sets.js.map","import * as TSU from \"@panyam/tsutils\";\nexport function allMinimalCycles(nodes, idFunc, edges) {\n    const cycles = [];\n    const inACycle = {};\n    nodes.forEach((node) => {\n        if (!(idFunc(node) in inACycle)) {\n            const startNode = node;\n            const visited = {};\n            let queue = [[node, []]];\n            while (queue.length > 0) {\n                const newQueue = [];\n                for (let i = 0; i < queue.length; i++) {\n                    const [node, c] = queue[i];\n                    TSU.assert(node != null);\n                    const e = edges(node);\n                    let cycle = [...c];\n                    for (const [nextNode, edgeData] of e) {\n                        if (nextNode == startNode) {\n                            cycle.push([edgeData, nextNode]);\n                            cycle.forEach(([e, n], i) => (inACycle[n] = true));\n                            cycles.push([startNode, cycle]);\n                            cycle = cycle.slice(0, cycle.length - 1);\n                        }\n                        else if (!(idFunc(nextNode) in visited)) {\n                            visited[idFunc(nextNode)] = true;\n                            newQueue.push([nextNode, [...cycle, [edgeData, nextNode]]]);\n                        }\n                    }\n                }\n                queue = newQueue;\n            }\n        }\n    });\n    return cycles;\n}\nexport function digraph() {\n}\n//# sourceMappingURL=graph.js.map","import { load as loadGrammar } from \"./dsl\";\nimport { makeParseTable } from \"./ptables\";\nimport { Parser } from \"./lr\";\nimport { logParserDebug } from \"./debug\";\nexport function newLRParser(input, params = null) {\n    const options = params || {};\n    const [ptable, tokenFunc, itemGraph] = newParseTable(input, options);\n    const parser = new Parser(ptable);\n    if (options.tokenizer || tokenFunc) {\n        parser.setTokenizer(options.tokenizer || tokenFunc);\n    }\n    const debug = options.debug || \"\";\n    if (debug.split(\"|\").findIndex((p) => p == \"all\" || p == \"parser\") >= 0) {\n        logParserDebug(parser, itemGraph);\n    }\n    return [parser, tokenFunc, itemGraph];\n}\nexport function newParseTable(input, params = null) {\n    const options = params || {};\n    const [g, tokenFunc] = loadGrammar(input, options);\n    g.augmentStartSymbol();\n    const [ptable, itemGraph] = makeParseTable(g, options.type);\n    return [ptable, tokenFunc, itemGraph];\n}\n//# sourceMappingURL=factory.js.map","import { Rule, Regex } from \"./core\";\nimport { RegexParser as JSREParser } from \"./jsparser\";\nimport { RegexParser as FlexREParser } from \"./flexparser\";\nimport { Tape } from \"./tape\";\nexport function build(pattern, config) {\n    if (typeof pattern === \"string\") {\n        const rule = new Rule(exprFromJSRE(pattern, config), config);\n        rule.pattern = pattern;\n        return rule;\n    }\n    else if (pattern.constructor.name == \"RegExp\") {\n        const rule = new Rule(exprFromJSRE(pattern, config), config);\n        rule.pattern = pattern.source;\n        return rule;\n    }\n    else {\n        return new Rule(pattern, config);\n    }\n}\nexport function flatten(re, index = 0, rules) {\n    rules = rules || [];\n    if (typeof re === \"string\") {\n        rules.push(build(re, { tag: index }));\n    }\n    else if (re.constructor == RegExp) {\n        rules.push(build(re, { tag: index }));\n    }\n    else if (re.constructor == Rule) {\n        rules.push(re);\n    }\n    else if (re.constructor == Regex) {\n        rules.push(new Rule(re));\n    }\n    else {\n        const res = re;\n        for (let i = 0; i < res.length; i++) {\n            flatten(res[i], i, rules);\n        }\n    }\n    return rules;\n}\nexport function exprFromFlexRE(pattern) {\n    const parser = new FlexREParser();\n    try {\n        const expr = parser.parse(new Tape(pattern));\n        if (expr.dotAll == null)\n            expr.dotAll = false;\n        if (expr.multiline == null)\n            expr.multiline = false;\n        return expr;\n    }\n    catch (error) {\n        console.log(\"Error in FLEX RE: \", pattern);\n        throw error;\n    }\n}\nexport function exprFromJSRE(re, config) {\n    config = config || {};\n    const isRegExp = typeof re !== \"string\";\n    const pattern = typeof re === \"string\" ? re : re.source;\n    if (isRegExp)\n        config.unicode = re.unicode;\n    const expr = new JSREParser(pattern, config).parse();\n    if (typeof re !== \"string\") {\n        expr.dotAll = re.dotAll;\n        expr.ignoreCase = re.ignoreCase;\n        expr.multiline = re.multiline;\n    }\n    return expr;\n}\nexport function jsRE(strings, ...keys) {\n    const merged = String.raw(strings, ...keys);\n    return exprFromJSRE(merged);\n}\nexport function flexRE(strings, ...keys) {\n    const merged = String.raw(strings, ...keys);\n    return exprFromFlexRE(merged);\n}\n//# sourceMappingURL=builder.js.map","import { Union } from \"./core\";\nimport { VM } from \"./vm\";\nimport { Compiler } from \"./compiler\";\nimport { Tape as DefaultTape } from \"./tape\";\nimport { TokenizerError } from \"./errors\";\nimport * as Builder from \"./builder\";\nimport { Token } from \"./token\";\nexport function toToken(tag, m, tape) {\n    const out = new Token(tag, m.matchIndex, m.start, m.end);\n    for (let i = 0; i < m.positions.length; i += 2) {\n        if (m.positions[i] >= 0) {\n            out.positions[Math.floor(i / 2)] = [m.positions[i], m.positions[i + 1]];\n        }\n    }\n    for (const [groupIndex, tapeIndex] of m.groups) {\n        const gi = Math.abs(groupIndex);\n        if (!(gi in out.groups)) {\n            out.groups[gi] = [];\n        }\n        out.groups[gi].push(tapeIndex);\n    }\n    if (tape != null)\n        out.value = tape.substring(m.start, m.end);\n    return out;\n}\nexport class BaseTokenizer {\n    constructor() {\n        this._prog = null;\n        this._vm = null;\n        this.onError = null;\n        this.allRules = [];\n        this.onMatchHandlers = [];\n        this.matchHandlersByValue = {};\n        this.variables = new Map();\n        this.compiler = new Compiler((name) => {\n            let out = this.variables.get(name) || null;\n            if (out == null)\n                out = this.findRuleByValue(name)?.expr || null;\n            if (out == null)\n                throw new Error(`Invalid regex reference: ${name}`);\n            return out;\n        });\n    }\n    getVar(name) {\n        return this.variables.get(name) || null;\n    }\n    addVar(name, regex) {\n        let currValue = this.variables.get(name) || null;\n        if (currValue == null) {\n            currValue = regex;\n        }\n        else {\n            currValue = new Union(currValue, regex);\n        }\n        this.variables.set(name, regex);\n        return this;\n    }\n    findRuleByValue(value) {\n        return this.allRules.find((r) => r.tag == value) || null;\n    }\n    add(pattern, config, onMatch = null) {\n        if (typeof config === \"function\") {\n            onMatch = config;\n            config = null;\n        }\n        return this.addRule(Builder.build(pattern, config), onMatch);\n    }\n    addRule(rule, onMatch = null) {\n        rule.matchIndex = this.allRules.length;\n        this.allRules.push(rule);\n        this.onMatchHandlers.push(onMatch);\n        this._prog = null;\n        this._vm = null;\n        return this;\n    }\n    on(tag, onMatch) {\n        this.matchHandlersByValue[tag] = onMatch;\n        return this;\n    }\n    get prog() {\n        if (this._prog == null) {\n            const sortedRules = this.sortRules();\n            this._prog = this.compiler.compile(sortedRules);\n        }\n        return this._prog;\n    }\n    get vm() {\n        if (this._vm == null) {\n            this._vm = new VM(this.prog);\n        }\n        return this._vm;\n    }\n    sortRules() {\n        const sortedRules = this.allRules.map((rule) => rule);\n        sortedRules.sort((r1, r2) => {\n            if (r1.priority != r2.priority)\n                return r2.priority - r1.priority;\n            return r1.matchIndex - r2.matchIndex;\n        });\n        return sortedRules;\n    }\n}\nexport class Tokenizer extends BaseTokenizer {\n    constructor() {\n        super(...arguments);\n        this.idCounter = 0;\n    }\n    getState() {\n        return this.vm.getState();\n    }\n    setState(state) {\n        this.vm.setState(state);\n    }\n    reset() {\n        this.idCounter = 0;\n        if (this._vm) {\n            this._vm.setState(0);\n        }\n    }\n    next(tape, owner) {\n        if (!tape.hasMore) {\n            return null;\n        }\n        const startIndex = tape.index;\n        const startChar = tape.currCh;\n        const m = this.vm.match(tape);\n        if (m == null) {\n            let err = null;\n            if (tape.index == startIndex + 1) {\n                err = new TokenizerError(`Unexpected Character: ${startChar}`, startIndex, 1, \"UnexpectedCharacter\", startChar);\n            }\n            else {\n                err = new TokenizerError(`Unexpected Symbol: ${tape.substring(startIndex, tape.index)}`, startIndex, tape.index - startIndex, \"UnexpectedLexeme\");\n            }\n            if (this.onError) {\n                err = this.onError(err, tape, startIndex);\n            }\n            if (err != null) {\n                throw err;\n            }\n            else {\n                return this.next(tape, owner);\n            }\n        }\n        const rule = this.allRules[m.matchIndex];\n        let token = toToken(rule.tag, m, tape);\n        token.id = this.idCounter++;\n        let onMatch = this.onMatchHandlers[m.matchIndex];\n        if (!onMatch) {\n            onMatch = this.matchHandlersByValue[rule.tag];\n        }\n        if (onMatch) {\n            token = onMatch(rule, tape, token, owner);\n            if (token == null) {\n                return this.next(tape, owner);\n            }\n        }\n        else if (rule.skip) {\n            return this.next(tape, owner);\n        }\n        return token;\n    }\n    tokenize(tape, owner = null) {\n        const tokens = [];\n        if (typeof tape === \"string\") {\n            tape = new DefaultTape(tape);\n        }\n        let next = this.next(tape, owner);\n        while (next) {\n            tokens.push(next);\n            try {\n                next = this.next(tape, owner);\n            }\n            catch (err) {\n                tokens.push({\n                    tag: \"ERROR\",\n                    start: err.offset,\n                    end: err.offset + err.length,\n                    value: err.message,\n                });\n                break;\n            }\n        }\n        return tokens;\n    }\n}\n//# sourceMappingURL=tokenizer.js.map","import { flexRE } from \"./builder\";\nexport const SINGLE_QUOTE_STRING = flexRE `[\"]([^\"\\\\\\n]|\\\\.|\\\\\\n)*[\"]`;\nexport const DOUBLE_QUOTE_STRING = flexRE `[']([^'\\\\\\n]|\\\\.|\\\\\\n)*[']`;\nexport const SIMPLE_JS_STRING = '\"(.*?(?<!\\\\\\\\))\"';\nexport const JS_REGEX_WITHOUT_LB = String.raw `/([^\\\\/]|\\\\.)*/([imus]*)`;\nexport const JS_REGEX = String.raw `/(.+?(?<!\\\\))/([imus]*)`;\n//# sourceMappingURL=samples.js.map","import * as TSU from \"@panyam/tsutils\";\nimport { IDSet } from \"./sets\";\nexport class LRItem {\n    constructor(rule, position = 0) {\n        this.id = 0;\n        this.rule = rule;\n        this.position = position;\n    }\n    advance() {\n        TSU.assert(this.position < this.rule.rhs.length);\n        return new LRItem(this.rule, this.position + 1);\n    }\n    copy() {\n        return new LRItem(this.rule, this.position);\n    }\n    get key() {\n        TSU.assert(!isNaN(this.rule.id), \"Rule's ID is not yet set.\");\n        return this.rule.id + \":\" + this.position;\n    }\n    compareTo(another) {\n        let diff = this.rule.id - another.rule.id;\n        if (diff == 0)\n            diff = this.position - another.position;\n        return diff;\n    }\n    equals(another) {\n        return this.compareTo(another) == 0;\n    }\n    get debugString() {\n        const rule = this.rule;\n        const pos = this.position;\n        const pre = rule.rhs.syms.slice(0, pos).join(\" \");\n        const post = rule.rhs.syms.slice(pos).join(\" \");\n        return `${rule.id}  -  ${rule.nt} -> ${pre}  ${post}`;\n    }\n}\nexport class LRItemSet {\n    constructor(ig, ...entries) {\n        this.id = 0;\n        this._key = null;\n        this._lookaheads = {};\n        this._hasLookAheads = false;\n        this.itemGraph = ig;\n        this.values = entries;\n    }\n    copy() {\n        const out = new LRItemSet(this.itemGraph, ...this.values);\n        out._lookaheads = { ...this._lookaheads };\n        out._hasLookAheads = this._hasLookAheads;\n        return out;\n    }\n    addLookAhead(item, sym) {\n        if (!(item.id in this._lookaheads)) {\n            this._lookaheads[item.id] = [];\n        }\n        for (const s of this._lookaheads[item.id])\n            if (s == sym)\n                return false;\n        this._hasLookAheads = true;\n        this._key = null;\n        this._lookaheads[item.id].push(sym);\n        this._lookaheads[item.id].sort((s1, s2) => s1.id - s2.id);\n        return true;\n    }\n    clearLookAheads() {\n        this._lookaheads = {};\n    }\n    getLookAheads(item) {\n        return this._lookaheads[item.id] || [];\n    }\n    get key() {\n        if (this._key == null) {\n            this._key = this.revalKey();\n        }\n        return this._key;\n    }\n    revalKey() {\n        if (this.hasLookAheads) {\n            this.values.sort();\n            return this.values\n                .map((itemId) => {\n                const la = this._lookaheads[itemId] || [];\n                return itemId + \"[\" + la.map((s) => s.id).join(\",\") + \"]\";\n            })\n                .join(\"/\");\n        }\n        else {\n            this.values.sort();\n            return this.values.join(\"/\");\n        }\n    }\n    has(itemId) {\n        return this.values.indexOf(itemId) >= 0;\n    }\n    equals(another) {\n        return this.key == another.key;\n    }\n    add(itemId) {\n        if (!this.has(itemId)) {\n            this.values.push(itemId);\n            this._key = null;\n        }\n        return this;\n    }\n    get size() {\n        return this.values.length;\n    }\n    get debugString() {\n        return this.debugValue.join(\"\\n\");\n    }\n    get hasLookAheads() {\n        return this._hasLookAheads;\n    }\n    get debugValue() {\n        if (this.hasLookAheads) {\n            const items = this.values.map((v) => this.itemGraph.items.get(v));\n            items.sort((i1, i2) => i1.compareTo(i2));\n            return items.map((item) => {\n                const las = this.getLookAheads(item)\n                    .map((s) => s.label)\n                    .sort((s1, s2) => s1.localeCompare(s2))\n                    .join(\", \");\n                return las.length > 0 ? `${item.debugString} / ( ${las} )` : item.debugString;\n            });\n        }\n        else {\n            const items = this.values.map((v) => this.itemGraph.items.get(v));\n            items.sort((i1, i2) => i1.compareTo(i2));\n            return items.map((i) => i.debugString);\n        }\n    }\n}\nexport class LRItemGraph {\n    constructor(grammar) {\n        this.grammar = grammar;\n        this.gotoSets = {};\n        this.items = new IDSet();\n        this.itemSets = new IDSet();\n    }\n    startItem() {\n        const startSymbol = this.grammar.startSymbol;\n        TSU.assert(startSymbol != null, \"Start symbol must be set\");\n        TSU.assert((this.grammar.augStartRule || null) != null, \"Grammar is not augmented\");\n        return this.items.ensure(new LRItem(this.grammar.augStartRule));\n    }\n    reset() {\n        this.grammar.refresh();\n        this.gotoSets = {};\n        this.items.clear();\n        this.itemSets.clear();\n        this.startSet();\n    }\n    refresh() {\n        this.reset();\n        this.grammar.refresh();\n        this.evalGotoSets();\n        return this;\n    }\n    evalGotoSets() {\n        const out = this.itemSets;\n        for (let i = 0; i < out.size; i++) {\n            const currSet = out.get(i);\n            for (const sym of this.grammar.allSymbols) {\n                if (sym != this.grammar.Null) {\n                    const gotoSet = this.goto(currSet, sym);\n                    if (gotoSet.size > 0) {\n                        this.setGoto(currSet, sym, gotoSet);\n                    }\n                }\n            }\n        }\n    }\n    goto(itemSet, sym) {\n        const out = this.newItemSet();\n        for (const itemId of itemSet.values) {\n            const item = this.items.get(itemId);\n            const rule = item.rule;\n            if (item.position < rule.rhs.length) {\n                if (rule.rhs.syms[item.position] == sym) {\n                    this.advanceItemAndAdd(item, itemSet, out);\n                }\n            }\n        }\n        return this.closure(out);\n    }\n    advanceItemAndAdd(itemToAdvance, fromItemSet, toItemSet) {\n        const newItem = this.items.ensure(itemToAdvance.advance());\n        toItemSet.add(newItem.id);\n        for (const laSym of fromItemSet.getLookAheads(itemToAdvance)) {\n            toItemSet.addLookAhead(newItem, laSym);\n        }\n    }\n    newItemSet(...items) {\n        return new LRItemSet(this, ...items.map((item) => item.id));\n    }\n    get size() {\n        return this.itemSets.size;\n    }\n    ensureGotoSet(fromSet) {\n        if (!(fromSet.id in this.gotoSets)) {\n            this.gotoSets[fromSet.id] = {};\n        }\n        return this.gotoSets[fromSet.id];\n    }\n    setGoto(fromSet, sym, toSet) {\n        const entries = this.ensureGotoSet(fromSet);\n        entries[sym.id] = toSet;\n    }\n    getGoto(fromSet, sym) {\n        return (this.gotoSets[fromSet.id] || {})[sym.id] || null;\n    }\n    forEachGoto(itemSet, visitor) {\n        const gotoSet = this.gotoSets[itemSet.id] || {};\n        for (const symid in gotoSet) {\n            const sym = this.grammar.getSymById(symid);\n            const next = gotoSet[symid];\n            if (visitor(sym, next) == false)\n                break;\n        }\n    }\n    gotoSetFor(itemSet) {\n        return this.gotoSets[itemSet.id] || {};\n    }\n    get debugValue() {\n        const out = {};\n        this.itemSets.entries.forEach((iset) => {\n            out[iset.id] = { items: [], goto: {} };\n            out[iset.id][\"items\"] = iset.debugValue;\n            const g = this.gotoSets[iset.id];\n            for (const symid in g) {\n                const sym = this.grammar.getSymById(symid);\n                out[iset.id][\"goto\"] = out[iset.id][\"goto\"] || {};\n                out[iset.id][\"goto\"][sym.label] = g[symid].id;\n            }\n        });\n        return out;\n    }\n}\nexport class LR0ItemGraph extends LRItemGraph {\n    startSet() {\n        const startItem = this.startItem();\n        const newset = this.newItemSet(startItem);\n        return this.closure(newset);\n    }\n    closure(itemSet) {\n        const out = new LRItemSet(this, ...itemSet.values);\n        for (let i = 0; i < out.values.length; i++) {\n            const itemId = out.values[i];\n            const item = this.items.get(itemId);\n            const rule = item.rule;\n            if (item.position < rule.rhs.length) {\n                const sym = rule.rhs.syms[item.position];\n                if (!sym.isTerminal) {\n                    for (const rule of this.grammar.rulesForNT(sym)) {\n                        const newItem = this.items.ensure(new LRItem(rule, 0));\n                        out.add(newItem.id);\n                    }\n                }\n            }\n        }\n        return out.size == 0 ? out : this.itemSets.ensure(out);\n    }\n}\nexport class LR1ItemGraph extends LRItemGraph {\n    startSet() {\n        const startItem = this.startItem();\n        const newset = this.newItemSet(startItem);\n        newset.addLookAhead(startItem, this.grammar.Eof);\n        return this.closure(newset);\n    }\n    closure(itemSet) {\n        const out = itemSet.copy();\n        for (let i = 0; i < out.values.length; i++) {\n            const itemId = out.values[i];\n            const item = this.items.get(itemId);\n            if (item.position >= item.rule.rhs.length)\n                continue;\n            const rhs = item.rule.rhs;\n            const B = rhs.syms[item.position];\n            if (B.isTerminal)\n                continue;\n            for (const lookahead of out.getLookAheads(item)) {\n                const suffix = rhs.copy().append(lookahead);\n                this.grammar.firstSets.forEachTermIn(suffix, item.position + 1, (term) => {\n                    if (term != null) {\n                        const bRules = this.grammar.rulesForNT(B);\n                        for (const br of bRules) {\n                            const newItem = this.items.ensure(new LRItem(br, 0));\n                            out.add(newItem.id);\n                            out.addLookAhead(newItem, term);\n                        }\n                    }\n                });\n            }\n        }\n        return out.size == 0 ? out : this.itemSets.ensure(out);\n    }\n}\n//# sourceMappingURL=lritems.js.map","export class ParseError extends Error {\n    constructor(message, type, value = null) {\n        super(message);\n        this.type = type;\n        this.value = value;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n    get name() {\n        return this.constructor.name;\n    }\n}\n//# sourceMappingURL=errors.js.map","import { LRActionType } from \"./lr\";\nfunction escapeHtml(text) {\n    return text\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/'/g, \"&#039;\");\n}\nexport function parseTableToHtml(parseTable, config = {}) {\n    const parseTableClass = config.parseTableClass || \"parseTable\";\n    const itemGraph = config.itemGraph || null;\n    const symbols = config.gotoSymbolSorter\n        ? [...parseTable.grammar.allSymbols].sort(config.gotoSymbolSorter)\n        : parseTable.grammar.allSymbols;\n    let out = `<table border = 1 class = '${parseTableClass}'>`;\n    out += \"<thead><td></td>\";\n    for (const sym of symbols) {\n        out += `<td class = \"symHeaderCell\" symID = \"${sym.id}\">${sym.label}</td>`;\n    }\n    const numStates = Object.keys(parseTable.actions).length;\n    for (let i = 0; i < numStates; i++) {\n        out += \"<tr>\";\n        let stateLabel = `${i}`;\n        let stateTitle = \"\";\n        if (itemGraph && i < itemGraph.itemSets.size) {\n            const itemSet = itemGraph.itemSets.get(i);\n            const items = itemSet.debugValue;\n            stateTitle = items.join(\"\\n\");\n            if (items.length > 0) {\n                const firstItem = items[0];\n                const match = firstItem.match(/^\\d+\\s*-\\s*(.+)$/);\n                const hint = match ? match[1] : firstItem;\n                stateLabel = `<div class=\"stateNum\">${i}</div><div class=\"stateHint\">${escapeHtml(hint)}</div>`;\n            }\n        }\n        let stateHasConflicts = false;\n        for (const sym of symbols) {\n            if (parseTable.getActions(i, sym).length > 1) {\n                stateHasConflicts = true;\n                break;\n            }\n        }\n        const stateHeaderClass = stateHasConflicts ? \"stateHeaderCell hasConflicts\" : \"stateHeaderCell\";\n        out += `<td class = \"${stateHeaderClass}\" stateID = \"${i}\" title=\"${escapeHtml(stateTitle)}\">${stateLabel}</td>`;\n        for (const sym of symbols) {\n            const actions = parseTable.getActions(i, sym);\n            let cellClass = \" actionCell\";\n            if (actions.length == 0) {\n                cellClass += \" emptyActions\";\n            }\n            else {\n                if (actions.length > 1) {\n                    cellClass += \" multipleActions\";\n                }\n            }\n            out += `<td class = \"${cellClass}\" stateId = ${i} symID = \"${sym.id}\">`;\n            const lines = [];\n            for (const action of actions) {\n                if (action.tag == LRActionType.GOTO) {\n                    lines.push(`<div class = \"gotoActionCell\">${action.gotoState}</div>`);\n                }\n                else if (action.tag == LRActionType.ACCEPT) {\n                    lines.push(`<div class = \"acceptActionCell\">ACCEPT</div>`);\n                }\n                else if (action.tag == LRActionType.SHIFT) {\n                    lines.push(`<div class = \"shiftActionCell\">S${action.gotoState}</div>`);\n                }\n                else if (action.tag == LRActionType.REDUCE) {\n                    lines.push(`<div class = \"reduceActionCell\">R${action.rule.id}</div>`);\n                }\n            }\n            out += lines.join(\"\\n\");\n            out += \"</td>\";\n        }\n        out += \"</tr>\";\n    }\n    out += \"</thead>\";\n    out += \"</table>\";\n    return out;\n}\n//# sourceMappingURL=printers.js.map"],"names":["PFNode","constructor","id","sym","value","children","this","childCount","length","childAt","index","isTerminal","add","node","Error","label","push","splice","numToDelete","nodes","reprString","debugValue","join","raw","out","map","c","forEach","l","PTNode","super","arguments","parent","ParserBase","setTokenizer","tokenizer","tokenbuffer","getSym","token","grammar","tag","SimpleParser","parse","input","delegate","parseInput","ParallelParser","removeUselessSymbols","g","fromSymbol","derives_terminal","terminalDerivingSymbols","removeRules","r","has","nt","rhs","syms","findIndex","s","refresh","reachable_symbols","reachableSymbols","expandNullProductions","str","results","nullables","key","toString","isNullable","newStr","copy","removeNullProductions","forEachNT","rulesForNT","removeCycles","hasDirectLeftRecursion","leftFactor","symTrie","forEachRule","rule","lf","curr","prefix","size","isLeaf","newSym","newAuxNT","append","child","values","childNode","next","root","removeDirectLeftRecursion","lrecRules","betaRules","slice","auxSym","removeIndirectLeftRecursion","Sym","isAuxiliary","auxType","precedence","assocLeft","creationId","idCounter","compareTo","another","localeCompare","equals","Str","lits","extend","strs","lit","startIndex","endIndex","itemsToAdd","i","diff","containsAt","offset","debugString","RuleAction","isFunction","isChildPosition","Rule","action","isNaN","Grammar","make","callback","config","startSymbol","modified","symbolSet","allRules","_rulesForNT","_followSets","_hasNull","auxNTCount","auxNTPrefix","Null","newTerm","Eof","firstSets","followSets","augStartRule","_AugStartRule","augmentStartSymbol","augSym","newNT","addRule","entries","addTerminals","terminals","t","filter","x","allNonTerminals","nonTerminals","auxNonTerminals","allSymbols","visitor","rules","getRule","findRule","production","nonterm","ensureSym","pred","removeSymbols","newRules","newRhs","remove","getSymById","get","getByKey","throwIfExists","sym2","ensure","T","NT","isNT","isAuxNT","seq","exps","normalizeRule","e","anyof","ensureAuxNT","opt","exp","atleast0","leftRec","auxNT","findAuxNT","which","atleast1","newAuxNTName","name","findAuxNTByRules","ntRules","print","options","ruleSep","includeSemiColon","lambdaSymbol","nadded","allDerive","reachable","queue","newQueue","cycles","allMinimalCycles","val","ruleIndex","j","isStrNullable","leftRecursion","ParseTable","Map","processRule","count","term","ensureEntry","entriesForNT","set","entry","forEachEntry","ntId","keys","ntMap","termId","items","item","ruleIsNullable","forEachTermIn","forEachTerm","ParseStack","parseTable","stack","docNode","rootNode","top","pop","isEmpty","Parser","topItem","topNode","peek","nextSym","nextValue","consumeTokenAndPop","processInvalidToken","console","log","processInvalidReductions","ptnode","popSymAndPushRule","parentNode","tape","nextToken","currSym","str2regex","replace","TokenType","NodeType","load","params","eparser","Loader","tokenFunc","generatedTokenizer","bind","debug","split","p","vm","prog","Tokenizer","lexer","ARROW","OPEN_SQ","CLOSE_SQ","OPEN_PAREN","CLOSE_PAREN","OPEN_BRACE","CLOSE_BRACE","STAR","PLUS","QMARK","SEMI_COLON","COLON","PIPE","SPACES","COMMENT","STRING","substring","start","end","REGEX","pattern","positions","flags","NUMBER","parseInt","PCT_IDENT","DOLLAR_NUM","DOLLAR_IDENT","IDENT","leftRecursive","regexSyntax","symbolsByLabel","newSymbolCallback","tokenHandlers","symbolForLabel","registerSymbol","ensureSymbol","assumedTerminal","et","owner","parseGrammar","parseRegex","priority","syntax","tokPattern","expectToken","re","RegExp","patternStr","hasMore","currCh","advance","trim","peeked","parseDecl","SyntaxError","parseDirective","directive","startsWith","endsWith","tokenHandler","parseTokenHandler","isDef","tokName","addVar","expr","consumeIf","funcName","handler","ident","parseProductions","parseProd","nextMatches","makeParseTable","type","makeLRParseTable","makeLALRParseTable","makeSLRParseTable","ig","makeSLRAutomaton","makeParseTableFromLA","itemSet","itemSets","evalLASetsForSLRItem","itemId","position","addLookAhead","hasConflicts","g2","grammarFromLR0ItemGraph","prevSets","startState","gotoSets","symId","nextSet","Set","conflictActions","evalLASetsForLALRItem","getGoto","addAction","Shift","lookaheads","getLookAheads","lookahead","Reduce","forEachGoto","Goto","lr1Item","Accept","augGrammar","findP","currState","states","transitions","prevStates","nextState","clearLookAheads","pSet","pALabel","pA","indexOf","ensureG2Sym","pi","newSymLabel","buildRuleFrom","startSet","A","newSyms","xi","startSym","p1","newA","newRHS","newRule","printGrammar","hideAux","indentStr","printRule","printRules","LRActionType","LRAction","gotoState","ACCEPT","SHIFT","REDUCE","goto","GOTO","actions","Object","getActions","stateId","l1","ac","fromId","a","stateStack","nodeStack","state","nth","popN","n","L","context","tokenizerContext","buildParseTree","copySingleChild","output","resolveActions","actionResolver","err","onTokenError","onNextToken","topState","newNode","ruleLen","beforeAddingChildNode","handlerName","ruleHandlers","onReduction","newAction","defaultKeyFunc","Trie","keyFunc","TrieNode","fromIndex","IDSet","_entries","_entriesByKey","clear","predicate","e2","SymbolSet","enforceSymbolType","hasNull","labels","sort","skipAux","addFrom","includeNull","addTo","before","termid","delete","NullableSet","nonterms","visited","beforeCount","visit","toIndex","SymSymbolSets","_count","entriesFor","addNull","source","srcEntries","destEntries","FirstSets","allNullable","symj","FollowSets","idFunc","edges","inACycle","startNode","cycle","nextNode","edgeData","digraph","newLRParser","ptable","itemGraph","newParseTable","parser","build","exprFromJSRE","flatten","res","exprFromFlexRE","F","dotAll","multiline","error","isRegExp","unicode","ignoreCase","jsRE","strings","String","flexRE","toToken","m","matchIndex","Math","floor","groupIndex","tapeIndex","groups","gi","abs","BaseTokenizer","_prog","_vm","onError","onMatchHandlers","matchHandlersByValue","variables","compiler","findRuleByValue","getVar","regex","currValue","find","onMatch","on","sortedRules","sortRules","compile","VM","r1","r2","getState","setState","reset","startChar","match","skip","tokenize","tokens","message","SINGLE_QUOTE_STRING","DOUBLE_QUOTE_STRING","JS_REGEX","LRItem","pos","pre","post","LRItemSet","_key","_lookaheads","_hasLookAheads","s1","s2","revalKey","hasLookAheads","v","i1","i2","las","LRItemGraph","startItem","evalGotoSets","currSet","gotoSet","setGoto","newItemSet","advanceItemAndAdd","closure","itemToAdvance","fromItemSet","toItemSet","newItem","laSym","ensureGotoSet","fromSet","toSet","symid","gotoSetFor","iset","LR0ItemGraph","newset","LR1ItemGraph","B","suffix","bRules","br","ParseError","setPrototypeOf","prototype","escapeHtml","text","parseTableToHtml","parseTableClass","symbols","gotoSymbolSorter","numStates","stateLabel","stateTitle","firstItem","stateHasConflicts","cellClass","lines"],"ignoreList":[],"sourceRoot":""}